<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024全国密码数学挑战赛</title>
    <link href="/2024/09/09/2024%E5%85%A8%E5%9B%BD%E5%AF%86%E7%A0%81%E6%95%B0%E5%AD%A6%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    <url>/2024/09/09/2024%E5%85%A8%E5%9B%BD%E5%AF%86%E7%A0%81%E6%95%B0%E5%AD%A6%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N1=<span class="hljs-number">0xa4d80845630d3b332f74f667ec8a0e49aba15b6f0c4f4006161d62c91b78cf6811421cc76609d2d9dba2c43be9d8ecdc6a0dff64a8041dcde52c7f92820b0a38fc91419e8ec9a5c69d47edc6e347934b4d87f97c5759886dac6c1143ff55b8eb11acfaa6cc70956a8ec7796e1a063b123bc2e467e30937c5a69c7ab5f8ed17e1</span><br>e1=<span class="hljs-number">0x3458c2e97adef45f741c7db11ece6c0814aa5b6fad9144242cdaa16a6b4f3622477935f98a41765b92892b4de22a391cf08767447df113f5151c86edd109b97f9b045fd8ad5d7a51084684d4e2353db6c0e474d5d79f399a2bf4fd867ec85b7960845ab5497f705914912f797804c06dcff57139e040596d22b141e54835e0d3</span><br>c1=<span class="hljs-number">0x91b097a5b1f6b12accdbda15cd2247384e1b3ed8311085a0f3e0dbb5fffce650a355600a02674189d1b7f4075df079c70354a08646e85ecf31dd150220cd1d4ce22d55a946500f4bd8def74fb0acea3e8d2e7bb1d27ebf2ca2e80fc28c3f0d88a041d4a556a18147f66b88c65f19c99b4b94c3f78d468b8accb4da7e7ce31b29</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_1$ 的取值范围为[$2^{249}$,$2^{250}$]</p><p>满足维纳攻击界限 $d &lt; \frac{1}{3}N^{\frac{1}{4}}$，直接解出flag即可</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N2=<span class="hljs-number">0xd231f2c194d3971821984dec9cf1ef58d538975f189045ef8a706f6165aab4929096f61a3eb7dd8021bf3fdc41fe3b3b0e4ecc579b4b5e7e035ffcc383436c9656533949881dca67c26d0e770e4bf62a09718dbabc2b40f2938f16327e347f187485aa48b044432e82f5371c08f6e0bbde46c713859aec715e2a2ca66574f3eb</span><br>e2=<span class="hljs-number">0x5b5961921a49e3089262761e89629ab6dff2da1504a0e5eba1bb7b20d63c785a013fd6d9e021c01baf1b23830954d488041b92bca2fe2c92e3373dedd7e625da11275f6f18ee4aef336d0637505545f70f805902ddbacb21bb8276d34a0f6dfe37ede87dd95bb1494dbb5763639ba3984240f1178e32aa36ee3c5fcc8115dde5</span><br>c2=<span class="hljs-number">0x6a88a8fa2b8f28d96284298bab2061efeb35e3a086370e19523c15c429f5d783b9d4f32e31a402916f45ad4f2760ab30e77177335af44756bfbeef0f168b5e0dc8c3ddf75d141c358969cca0e7c2b8ab99ef8e33b031be1cbccd95b687682ac7b0dcc0d56f5651ee671d6358128d2e0801f247a6af4fe0dc5e8fb199eba0780f</span><br></code></pre></td></tr></table></figure><p>已知信息: 私钥 $d_2$ 的取值范围为[$2^{285}$,$2^{286}$]</p><p>满足 $BD$ 界限 $d &lt; N^{0.292}$，直接解出flag即可</p><table><thead><tr><th>m&#x2F;delta</th><th>.275</th><th>.276</th><th>.277</th><th>.278</th><th>.279</th><th>.280</th></tr></thead><tbody><tr><td><strong>10</strong></td><td></td><td>F</td><td></td><td>F</td><td>F</td><td>F</td></tr><tr><td><strong>11</strong></td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr></tbody></table><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N3=<span class="hljs-number">0xf4c548636db62ffcc7ac4a0797952bea9a65bd426175af2435f72657e67ec8194667bfa94ce23c6f1e5baf3201867ab41701f6b8768e71009c41a3d5e9e7c109455341d549c7611f9f52851a2f017906aa9ccbedb95d238468e2c8577d30ecc4f158e3811fd5e2a6051443d468e3506bbc39bba710e34a604ac9e85d0feef8b3</span><br>e3=<span class="hljs-number">0x16f4b438ba14e05afa944f7da9904f8c78ea52e4ca0be7fa2b5f84e22ddd7b0578a3477b19b7bb4a7f825acc45da2dd10e62dbd94a3386b97d92ee817b0c66c1507514a7860b9139bc2ac3a4e0fe304199214da00a4ca82bfcb7b18253e7e6144828e584dac2dfb9a03fabaf2376ce7c269923fbb60fc68325b9f6443e1f896f</span><br>c3=<span class="hljs-number">0x26b1823cf836b226e2f5c90fdcd8420dbfcd02765b26e52ef3e5c0ab494c2f4650e475e280b0b5fff0d5016621186420b09e4706a5866e4a3319f23ef09d92c4e36acba39a0f6213fbe5ee1a736ce383e6e12351e6cbfd43f10a96b7fe34bdbaf948f2fb075d9063723c9f747fe6247ae9209e5d417faf2e37e6fee2eb863556</span><br></code></pre></td></tr></table></figure><p>已知信息: 私钥 $d_3$ 的取值范围为[$2^{299},2^{300}$]</p><p>很明显这里的私钥 $d$ 已经接近了 $BD$ 的理论界限 $N^{0.292}$，但是在格的维数过大的情况下理论计算时间非常大（直接BD调参数应该是算不出来的）</p><p>我们参考的<a href="https://link.springer.com/article/10.1007/s10623-023-01295-5">这一篇论文</a>，使用 binary search 爆破 $p$ 的高位<br>大概统计了一下，j爆破到10是需要很久的，我们当时已经完成了大部分的题目，分解出的 $p$ 或者 $q$ 的MSB是0b111，根据这个缩小了一点范围（取巧了）</p><p><code>经统计，从j=1开始，如果没缩范围，需要遍历984次；缩了范围，需要217次</code><br><code>对于m=12的bd，每次584s（10分钟），217次是35h（1.5天），984次是160h（6.6天）</code></p><blockquote><p>设定 $s :&#x3D; p + q$，$s_m$ 和 $s_l$ 分别表示 $s$ 的MSBs和LSBs, 则 $s &#x3D; 2^{L}s_m + s_l$, 其中 $L$ 为 $s_l$ 的比特位数<br>代入关系式 $ed &#x3D; 1 + k(N - (p + q - 1))$, 可得 $ed &#x3D; 1 + k(N - (2^{L}s_m + s_l - 1))$. 如果通过遍历的方法得到 $s_m$ 的值, 令 $f(x,y) &#x3D; x(N + 1 - 2^{L}s_m - y)$ 以及 $x &#x3D; k,y &#x3D; s_l$.<br>假设 $s$ 和 $s_l$ 的界限分别为 $Y$和 $Y_1$, 有 $Y_1 &lt; Y$. 这样处理相当于把界限从 $Y$ 缩小到 $Y_1$, 使其满足攻击条件.<br>假设 $e &#x3D; N^{\alpha}$，$d &#x3D; N^{\beta}$. 在这种情况下再用Boneh-Durfee格攻击寻找满足 $f(x,y) \equiv 0 \pmod{e},|x_0| &lt; X :&#x3D; 2N^{\alpha + \beta - 1},|y_0| &lt; Y_1$ 的解 $(x_0,y_0) &#x3D; (k,s_l)$ 即可成功分解 $N$.</p></blockquote><p>实际上我们的程序优化并不完善，最后解出来大概是160H</p><p><a href="https://tangcuxiaojikuai.xyz/post/4a67318c.html#more">糖醋小鸡块</a>师傅的博客中的剪枝思路也非常好，转载一下：</p><ul><li>如果把当前 $p$ 的高位后面全部补充0的值当做 $p_0$，那么 $N$ 除以 $p_0$ 得到的结果应该大于 $q$，也就是应该大于512bit</li><li>如果把当前 $p$ 的高位后面全部补充1的值当做 $p_1$，那么 $N$ 除以 $p_1$ 得到的结果应该小于 $q$，也就是应该小于512bit</li></ul><p>按照这个思路能够将搜索空间减少到原来的十分之一不到，一天内就可以出来结果（TQL）</p><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N4=<span class="hljs-number">0xd46dd141810786e451320ca452b379024fd263501ae767760f3dcf34b79806b85e36b0fee538dac61a5872c37d051a8a026384d09f12b7e1adae7eb15c4d75878007ee0043c2186cf8999c59eb66f689f55baf190bd80e70bf47b553be76bd4efffc782a51b43314d54b83fc19461e1beb6021164f64723b505e5a619cb62335</span><br>e4=<span class="hljs-number">0x92fbeeef2d40eb125234cfe4c063c4607f12aec7e3014b32fb4600e58c4eac1ec485192a1b03745632f2966311ad68bd1e49dd9d08b2bff67f58e214c8d7bae0142559994c24e347ff7555c86aa30ccd03cf794e6f00eead7f15e24f33da61fae11ec81e4e09bcc76c1a0ed5ca8c2f512856cdb42470beee7111a2410188697d</span><br>c4=<span class="hljs-number">0x8c5e9db89f96d769f6514836407755caf71b7bc6f5db2246200b0f824dac7ea3be5ba022c0e191d76c69b7d20c7cad5c49e381479c7cbe7ba055ce8aec2cad1a19d42aa5c4b8c07c67e22c70289891d53c3d55dff50e506ec7fb480df44f9b3219f8c73e0702d8072e9f6aabed8bb5d35f583bea30ce850b154d4fd8c39e4fb8</span><br></code></pre></td></tr></table></figure><p>已知信息: 私钥 $d_4$ 的取值范围为[$2^{399},2^{400}$], 此外已知 $d_4$ 的汉明重量较轻, 其最高310位比特（MSBs）汉明重量不超过5, 剩余90位比特较为随机</p><p>Low Hamming Weight，<a href="https://link.springer.com/chapter/10.1007/11836810_15">参考论文</a>，综述(原链接挂了就这样贴上来吧)：</p><iframe src="/pdf/Implementation of RSA Attack Using 2-Dimensional Latticesby Constructing Hypotheses of Keys With Low Hamming Weight.pdf" width="600" height="500"></iframe><p>这个不超过5的意思是就是 $d_4$ 的MSBs中只有4个1<br>最高位必定是1的情况下我们可以爆破剩余的三个1的位置<br>剩下90的LSBs就可以通过构造二维格来求解<br>因为二维格求解的时间非常短，所以使得我们遍历 310 为的MSBs是可行的</p><blockquote><p>令 $G &#x3D; \left(<br>\begin{array}{cc}<br>a &amp; b \<br>c &amp; d<br>\end{array}<br>\right)$，$v &#x3D; \begin{pmatrix}<br>0 \<br>R<br>\end{pmatrix}$，其中 $C &#x3D; N^{\beta - \delta + 0.5}$，$R &#x3D; ed_m$，遍历小整数对 $(z_1,z_2)$<br>通过解方程 $G_{red}\begin{pmatrix}<br>z_1 \<br>z_2<br>\end{pmatrix}<br> &#x3D; G\begin{pmatrix}<br>x \<br>-y<br>\end{pmatrix} - G_{red}[G_{red}^{-1}v]$ 求出 $(x_0,y_0) ：&#x3D; (d_l,k)$<br>其中 $d_l$ 是 $d$ 的未知LSBs，求出正确解后即可分解 $N$，在这里我们设置了$(z_1,z_2)$ 为0提高遍历效率</p></blockquote><p>我们的程序在4分钟成功分解了 $N$</p><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N5=<span class="hljs-number">0x94eab94581f4931a5ea6aabcfe0598600fa3e0a06573887aed69e274f14484472dc3feaf50d4ef384e502f747f5605c1d2a4c8172b6ef134b7e96d6c383a9cb967ccbbd8b3647848d34928982a274999c2df00bd7dd11bf25acd61411e3395637e85dd84ecf785ff1027eed91f3976c8186e2e940edcb5fed8d759a5028b47a1</span><br>e5=<span class="hljs-number">0x124c552642ef2467aaecde51b0f3e1bee2ebe87bae39a956ad56cf7eec669cdc7b9664ea435b4c3492b8e610e0a182e1a76c7af443ca2962672b4e703c4f359cf8d88a67db77be2491b74bcdae58691b69e6ea06d067815b26fc0d669d8c06f11a728154dc8cdf983a056633fecadc417df4304625c3e6f91ec3d655a91a29e9</span><br>c5=<span class="hljs-number">0x63e09028c774513b5420236f8405f970c8d97c8347697c44f50b23e5cc964c921413b5e6742bb5ba7ef49f032e372f502babc0040f9c7cc2c9f4e27d18aefff0e764529ba70f6a7b22d525d0aaeb1d21432817b6b148b8143c80a6401a5c9adfecf0c033181bb076a2192a4866c5355c9e401fba78d5f22b9c1661c0065a1a28</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_5$ 的取值范围为[$2^{511},2^{512}$]，此外 $d_5$ 的最高256比特 MSBs（记为 $d_m$）及最低176位比特 LSBs（记为 $d_l$）取值均已知，但是中间80位比特（记为 $d_x$）取值未知，即满足如下关系：$d_5 &#x3D; d_l + d_x \cdot 2^{176} + d_m \cdot 2^{256}$</p><p>具体取值如下：<br>$$<br>\begin{cases}<br>d_l &#x3D; 0x2b26d177dc20ceea15de6e3c5a03207fb326a42d53a9 \\<br>d_m &#x3D; 0xacfad4bbb97a99b6bbc82c8b44a5260bcfe9c4a0acf437186ff4d5d1594cc5c1<br>\end{cases}<br>$$</p><p>私钥 $d$ 同时泄露MSBs和LSBs，<a href="https://link.springer.com/chapter/10.1007/11426639_22">参考论文</a>，赛题压缩包给的综述文献里面还提到了Takayasu-Kunihiro和STK格攻击这两种RSA的私钥泄露格攻击，缺少前置知识并且很复杂没有实现出来。（可能的优化点？）<br>不过这一道题使用<a href="https://link.springer.com/chapter/10.1007/11426639_22">参考论文</a>的fmsb1即可解出，还算是比较简单</p><blockquote><p>令 $d &#x3D; d_l + M_1(d_x + M_2d_m)$，其中 $d &#x3D; N^{\beta}，d_l &#x3D; N^{k}，d_x &#x3D; N^{\delta}，d_m &#x3D; N^{\beta - k - \delta}$<br>根据关系式 $ed &#x3D; k(N - (p + q - 1)) + 1$ 可知，$(x_0,y_0,z_0) :&#x3D; (d_x,k,p + q - 1)$ 是多项式 $f(x,y,z) :&#x3D; eM_1x - Ny + yz + R$ 的一组整数根，其中 $R &#x3D; ed_l + eM_1M_2d_m - 1$<br>根据 $Coppersmith$ 方法寻找满足 $f_e(x,y,z) \equiv 0 \pmod{e}，|x_0| &lt; X :&#x3D; N^{\delta}，|y_0| &lt; Y :&#x3D; N^{\beta}，|z_0| &lt; Z :&#x3D; 3N^{0.5}$ 的解 $(x_0,y_0,z_0) :&#x3D; (d_x,k,p + q - 1)$ 即可分解 $N$</p></blockquote><p>我们的程序在22s成功分解 $N$</p><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N6=<span class="hljs-number">0x94e4c83c67c6d6e33d83cc2953df899e8c4b33894f653d5bbc84d7dd9058e6949221897f6e5b7b8bd9013f495c906862e401436e77be585474066f6c220751dd9b2b8be66f07ad7f090547a6e759e482ba263b941b32c27c62c4b558d96dda168b28c52e550b7d7ff145a5996c0b398714cf5ee8f0ea1a3d5b17c592f1c15275</span><br>e6=<span class="hljs-number">0x949b2e72766be1e83ee278a56bc86a2d3268b719507068ac62c6d249a810284edaac39335e8d699630887c13864f4cdf1c0c423b2f7ae88ccc60a827332e6c410800c7c7a1677918c28aa51086991d1290fc64b8e1b0f14b482f35d86139bb3491a59e2ad99dcd35bd129a44c3b8e2667e405dc2d307a5bb5a1504d7ded3bda3</span><br>c6=<span class="hljs-number">0x6fd6fae8ab4e95e622e5dad2921c6f12e911df08768abf2d10d212ad9a26e4c5ec71640d7a6b3488064fd424224bc2c762b956af95a3212de37a57d74c0299936f48ae3d8b8803e644e8d1306ab735c94fd815fe8c77982b32d51e9b6f3b3d4f3753810b61fb528c3e9eb774dabd93a3c5c9919ae3fb90e8e998ed3e7f949738</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_6$ 的取值范围为 [$2^{559},2^{560}$]，此外 $d_6$ 的最高123比特MSBs（记为 $d_m$）取值未知，但其余437位比特（记为 $d_l$）取值已知，即满足以下关系：$d_6 &#x3D; d_l + 2^{437}d_m$，$d_l$ 的具体取值如下：$d_l&#x3D;0x6da211f0d34b$</p><p>$d_l$ 发现其实是没有437比特那么大的，也就是说 $d$ 的中间有相当一部分的位数全为0<br>在赛题压缩包中的<a href="http://www.jcr.cacrnet.org.cn/CN/10.13868/j.cnki.jcr.000088">参考文献三</a>有提到这一种情况</p><p><img src="/img/bg/cmsecc6.png"></p><blockquote><p>令 $r$ 为 $d_l$ 的bit位数，即 $d &#x3D; d_l + 2^rd_m$，有 $1 &#x3D; ed - k\phi(N) &#x3D; e(d_l + 2^rd_m) - k(N - (p + q - 1))$<br>假设 $e &#x3D; N^{\alpha}，d &#x3D; N^{\beta}，A &#x3D; ed_l - 1，W &#x3D; 2^re$，有 $A - kN + k(p + q -1) \equiv 0 \pmod{W}$<br>可证 $k &lt; X :&#x3D; 2N^{\alpha + \beta - 1}，p + q - 1 &lt; Y :&#x3D; 3N^{0.5}$<br>令 $x &#x3D; k，y &#x3D; p + q - 1$，易得 $u &#x3D; xy + A &lt; U :&#x3D; 7N^{\alpha + \beta - 0.5}$<br>令 $f(x,y,u) :&#x3D; u - Nx$，根据 $Coppersmith$ 方法寻找满足 $f_W(x,y,z) \equiv 0 \pmod{W}$的解 $(x_0,y_0,z_0) :&#x3D; (k,p + q - 1),x_0y_0 + A$ 即可成功分解 $N$</p></blockquote><p>我们的程序在19s成功分解 $N$</p><h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N7=<span class="hljs-number">0xaeb75bb97217271bf312a7897da81a544fe469ba0f1cf75304f2a5629717e1e3d0a9a28e71135443cc19f78c60dd3f7ea4ea28ae64657d5ac3b46e9755020de73cb5c4f89a682e0193916221bc8f4abb595f2c058bbb99e199a66144a9a9b258a74db847b2460107233280c94e854394595043f62bf77cd96c9ed3eca71b726d</span><br>e7=<span class="hljs-number">0x42b63e1113b4a84d0b037006a9bb729b52db495fa6b475bb64129a855a4ed6511792d0df946c5d7e22085d0db07bce5e408454a61c0cea51cf6d25e2455a2c6dc092e4b09bf4efb2157ffc1d1db3e969499479d721330ec4ac864e656318bc7bb9831a0dccf582406c87ae5d3ab9ffec351271dbb5481a0b6ed75a760b4f7e0d</span><br>c7=<span class="hljs-number">0xe1f90d9f115f9ba0b65ea8826ffec785bbe1b195fbb6f93c6ea28940f0d9b571930addb3e2714999ba5a19d17af22f1bc8da49f8b515ab03b6d276140b69fedf980d1aef78d0f3c0f6effdf2e92ce9195866f85672037537021178f8c65989b57f29de2c4c9306fe3e13aef29f962f86b8d5216907e85f28260b9f41cfe2651</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_7$ 与 $phi_7$ 很接近，据估计，$phi_7 - d_7$ 的取值范围为[$2^{267},2^{268}$]</p><p>令 $r &#x3D; \phi(N) - d$，其取值范围为[$2^{267},2^{268}$]，对于关系式 $ed \equiv 1 \pmod{\phi(N)}$，根据同余性质，有 $e(d - \phi(N)) \equiv er \equiv 1 \pmod{\phi(N)}$，把 $r$ 看作新的私钥，$r &#x3D; N^{0.262}&lt; N^{0.292}$，直接 $BD$ 即可</p><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">N8=<span class="hljs-number">0xf12eac2099c4190a6f586bea0b4fc3f9dff4f23f0cb8e42cbeff950aa1df8a373c49df7974fb33b4b6619eadb2d6c01f80da1b433295b199df11b323114c439884eb31fa568bd747ae37079e885e2490c3b5a56d61b9d10533983ff78fe85e07876fe2ae07ae7ea1c71f0f9c2d6beccdcd8baf046a58549aec19d45d48d7d92d</span><br>e8=<span class="hljs-number">0xb8906f5097658f27cc448d98974d9e7ccd4e8a8f25a80007826c341dcb2ac42420f899e5a89045fbefd9163bc94e6f98b4953546203be4bec249031587a27dbf</span><br>c8=<span class="hljs-number">0x162a6dee8bcbe24698b9249137c2a157890910fa74a56e7d2792b5b4f29112aba03448995ff32ed24bec5118f7433212196d3f99e1c794b61395d8183e4658c9dc05953a87c069c9390773c7f885907840ebd29676afac7bf3374d54c81c4e404f09716b9885d243c41dc48db561f8291b88826cae32bfd575a472e523f455c4</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_8$ 的最低900比特LSBs（记为 $d_l$）取值已知，剩余约124位比特（记为 $d_m$）取值未知，即满足如下关系：$d_8 &#x3D; d_l + d_m*2^{900}$，$d_l$ 取值具体如下：$d_l$ &#x3D; 0x4cbec287edc86c5b2a9e1975d64d2a24d3930075f0d445163c7b1ceec9ee0319fe1166af348b49004d2420b83bcb82d4879e93dba01ee76c5ca1b7141490465e824bdb5e91d04016c6bbbaa41c4470747ee8163f710b2d8adb8ab2168dcc996b5ab5f85a2269dc459379fb68848cec487</p><p>其实直接用<a href="https://github.com/MengceZheng/crypto-attacks">Github的库</a>就可以出了(__bm6__函数)，感觉不太严谨还是找到了对应的<a href="https://link.springer.com/chapter/10.1007/978-3-540-45146-4_2">参考论文</a>(第六节)</p><blockquote><p>令 $M$ 为满足 $d &#x3D; d_l \pmod{M}$ 的整数，如果 $\alpha &#x3D; \log{N}(e) \leq \frac{7}{8}$，并且 $M \geq N^{\frac{1}{6} + \frac{1}{3}\sqrt{1 + 6\alpha} + \epsilon}$，就可以在多项式时间内分解 $N$<br>由于 $ed &#x3D; k\phi(N) + 1$，则有 $e(d_l + Md_m) &#x3D; k(N - (p + q)) + 1$，设 $f_{eM}(y,z) &#x3D; y(N - z) - ed_l + 1$，易得 $(y_0,z_0) :&#x3D; (k,p + q - 1)$，为该多项式模 $eM$ 下的根<br>令 $Y :&#x3D; N^{\alpha}，Z :&#x3D; 3N^{0.5}$，易证 $|y_0| \leq Y$，$|z_0| \leq Z$，给定整数 $m$ 和 $t$，定义如下多项式：</p><div>$$\begin{cases}g_{i,j} = y^j(eM)^if^{m-i}_{eM},i = 0,\ldots,m;j = 0,\ldots,i \\\\h_{i,j} = z^j(eM)^if^{m-i}_{eM},i = 0,\ldots,m;j = 1,\ldots,t \end{cases}$$</div>使用 $Gröbner$ 基方法即可在多项式时间内解出 $g_{i,j}$ 和 $h_{i,j}$ 在模 $(eM)^m$ 下的根 $(y_0,z_0) := (k,p + q - 1)$</blockquote><p>我们的程序在16分钟成功分解 $N$</p><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e9=<span class="hljs-number">65537</span><br>N9=<span class="hljs-number">0xcc5b706f373a79c680cec9527aac573fd435129cf16c23334085bf97832e5a6c78b633c2f244b12a62f87ec5295dd89fcf3c808c39e45a9afdbda2f8d2d0b50d61b685c0fe9eb41a7018a40f98892f96d738e2a4e740d4e507bcbd07f68c1ecb2ca10bd780ce65265a7e4da00f1031a5db9d038878a29a5ffefcaf2119720005</span><br>c9=<span class="hljs-number">0x20bac8a7d73a74c9913377846c13c3d2bd9f47e6df118d1486a96ed184ca9910e0f250500065cfb44105a41dff655364cabc3067ef3cd3d7d983e75c9303b786ac97507cfe803b788b12e582232028ca9772d05004aef194076ec442e3ee55e17fbb4a57f332b4393ac056c024141cc2b82f9dbc6d3c77f6eff20cd0ecc9cbab</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_9$ 的最低530位比特LSBs（记为 $d_l$）取值已知，剩余高位比特（记为 $d_m$）取值未知，即满足如下关系：$d_9 &#x3D; d_l + d_m*2^{530}$，$d_l$ 取值具体如下：$d_l$ &#x3D; 0x20142ae2802b877eb4dfa8a462e7d017c4d348181c367fd1a661ec9b6bbcca9dcb6601ccb6c10416b7f3c20129527346bbc136ee60f9945125cba03a9bba3720f7411</p><p>这道题和第八题类似，虽然泄露的LSBs变少了，但是 $e$ 也变小了，所以仍然满足我们在题目八中的攻击条件，调下参数就好了<br>我们的程序在1s成功分解了 $N$</p><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e10=<span class="hljs-number">65537</span><br>N10=<span class="hljs-number">0x8d0df1ce526c39f9b057de462778a61ceda2049c7e32ee99d40baa4b22b7fd438e9ca1dfd7467684625add252095ee97c698199f4c5991279f6d3e74d4c14d01d137d42722df0d4565ff2a5275f9cac66dc4dfdf3304f85cbdc3d18eda1e32ac5d03675141a722ceefe0ea0533b53d7e50ed7eda1a1bbce47ed0ecb966f8678d</span><br>c10=<span class="hljs-number">0x3b42fa3dc9089a21e9dabfe18297df47272f7e0ff59bf9bf16bc55e7fa70504c03fed56ca5ae93ac028f60ce5da3c145c6d181c5bd3c267288ec4765a19ca6b957b4535a1a185bd1b87d2e39b30e2430ed648175c29fdc1fde3787c426783dd66ba17f98b42ba13a7b3532970d0aa31b5ffa5f3eae243337a1668bae456bfbfb</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_{10}$ 的取值范围为[$a,b$]，$a$ 和 $b$ 的具体取值如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">0x19ffe8024fcf0320b3107f380f2e7deff71d561c4266c0f439d1aca20cd43d2aa6aed8679a16b2e1d3ff4ba3fc4da69cf34e35ead6f7eb79923960b9c83d9923e591b07b65275bf67f0b3d424cd7e6e6dd88ea39a5cfa27ecee61caaacc93e751dbb2a4c196f0ce0c36d44c35d6658d71b6c48b7b29400ab9161a0000000000</span> \\<br>b = <span class="hljs-number">0x19ffe8024fcf0320b3107f380f2e7deff71d561c4266c0f439d1aca20cd43d2aa6aed8679a16b2e1d3ff4ba3fc4da69cf34e35ead6f7eb79923960b9c83d9923e591b07b65275bf67f0b3d424cd7e6e6dd88ea39a5cfa27ecee61caaacc93e751dbb2a4c196f0ce0c36d44c35d6658d71b6c48b7b29400ab9161affffffffff</span><br></code></pre></td></tr></table></figure><p>很明显 $a,b$ 的高位是相等的，所以这道题相当于是已知私钥 $d$ 的MSBs，赛题压缩包中的<a href="https://eprint.iacr.org/2020/1506">参考文献二</a>中给了一点思路</p><p><img src="/img/bg/cmsecc10.png"></p><p>注意到 $e$ 比较小，可以通过计算 $k &#x3D; \left\lceil \frac{ea - 1}{N} \right\rceil$ 的正确的 $k$</p><p>根据关系式 $ed - 1 &#x3D; k(N - (p + q -1))$，设定 $s :&#x3D; p + q$，通过计算 $N + 1 - \left\lceil \frac{ea - 1}{k} \right\rceil$ 可以得到 $s$ 的一个近似值 $\tilde{s}$，其值与 $s$ 的MSBs相等，并且相等位数取决于 $d$ 的未知LSBs比特位数</p><p>分别从高位开始遍历 $p,q$ 的MSBs，令 $\tilde{p}$ 和 $\tilde{q}$ 为遍历过程中 $p,q$ 的近似值，根据 $N &#x3D; p*q$，在遍历过程中确保：当 $\tilde{p}$ 和 $\tilde{q}$ 低位同时补0时，$\tilde{p} * \tilde{q} &lt; N$，当 $\tilde{p}$ 和 $\tilde{q}$ 低位同时补1时，$\tilde{p} * \tilde{q} &gt; N$，如果不满足则丢弃这一遍历分支，这样处理可以大幅提升遍历效率，得到 $p,q$ 的正确MSBs后就可以使用 $Coppersmith$ 方法计算出完整的 $p,q$</p><p>我们的程序在1s成功分解 $N$</p><h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e11=<span class="hljs-number">65537</span><br>N11=<span class="hljs-number">0xcb5645c59c402b0edcf96cbd6a7308b64aac2f37a3c6f96be7c421c4b7f0a4adbdecd88cbea1128352fb21baae583fe4ceb3fc93c4905803ad3e9214ada050d5c0ff785a13a5c9157c3154ad8d7015a2d239fe13ef836d3279c5cd5dc96013ac40f372a9c9226d2f5fe73f312c56e11d9cdfbf9fb0db627ac1a752f5f0bd2b29</span><br>c11=<span class="hljs-number">0x84e4aa0be481e9c4bbd4c71dba5235cccd8312759de35c326c7e4cdda494196d1c0cae298240942af3082fac215965999c908a79bf07e093ee0c402e727a09a1c1f13831875d66ebbc3f89507163de90339af055bcd7d778574775214accfbd8ae20001f27bc196b974cb3ac215fea3debb7b17a21a8ebb1a9880a671539ef21</span><br></code></pre></td></tr></table></figure><p>已知信息：私钥 $d_{11}$ 的取值范围为[$a,b$]，$a$ 和 $b$ 的具体取值如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">0x4f77b72b04e6fb2d02e5a43edef4784a2e22df0d42bfc7c9093a58ec35eb21a11962103be960b0088d0cc2e0dfb473bc2ba0a22cea1c73997442c8fab5e4bad22cd131055b0382eb9264ad40ec8257abaff11b33b173ffd0168039bf40dc203eb325d884d2845fd2b5a37f41a0f64183db0c256c244500000000000000000000</span><br>b=<span class="hljs-number">0x4f77b72b04e6fb2d02e5a43edef4784a2e22df0d42bfc7c9093a58ec35eb21a11962103be960b0088d0cc2e0dfb473bc2ba0a22cea1c73997442c8fab5e4bad22cd131055b0382eb9264ad40ec8257abaff11b33b173ffd0168039bf40dc203eb325d884d2845fd2b5a37f41a0f64183db0c256c2445ffffffffffffffffffff</span><br></code></pre></td></tr></table></figure><p>未知的私钥LSBs变为80bit，也满足题目十的攻击条件，一样的解法，1s</p><h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e12=<span class="hljs-number">65537</span><br>N12=<span class="hljs-number">0x9fac422a93f6e486e3ddae088bb5f5d06dec183ab81290042a9c98c53352961a00db3e9def7adff842381a395cedf1d06294f0b63457133e4e44cabb7633c562dcbfffdffe541d66c46ddf6a28b686c478300bcf31945f2a6495f140e64f78fa5cd47d1885233f175f28e38f1bfc422a6853ca19a7dd47a291a9e7de78a67bf1</span><br>c12=<span class="hljs-number">0x35476c9d0e5ad9d364ea31d8f6628b92a4f6307b1fef754e49286bc7f53ea8cd013a7ebf2a21b2327af44498d267e19526c2051a02f22cca9cab567f7ceefe5003137e396c23742370e14ec2c6a90943ca848908e87420f560d34eae4635475effa867722276710c6f4b6cb9b295777d62f3f03c57603ac815072864aadbf041</span><br></code></pre></td></tr></table></figure><p>已知信息：素因子 $q_{12}$ 是模数 $N_{12} &#x3D; p_{12} * q_{12}$ 与整数的部分近似公因子，即 $N &#x3D; k * q_{12} + r$ 其中 $2^{511} &lt; k &lt; 2^{512}$ 和 $2^{255} &lt; r &lt; 2^{256}$ 均为正整数且 $N$ 的具体取值如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">N=<span class="hljs-number">0x8199f8d487909988daf7d692ce8b1ffb4c37aa8010c8ca337ae4398c521383dc51007645cb6a1743c9b52ec5808e9e0e6f54d5fbb143cf81651240beab342dfb4622f073c4f8ab968dd5c8d4be3b7dd55c2cb9ef9c06294cd87e5fa29e38279c850f03687dc8c83c68104dca88e3a5c8559a01c040e7d5107e4a9f2385429f90</span><br></code></pre></td></tr></table></figure><p>ACD(Approximate GCD)问题，当时找了非常多的论文，基本上构造的格都是对角线上 $N$ ，并且至少需要三组元素的，这里只有两组，最后我们找到的<a href="https://dl.acm.org/doi/abs/10.1145/3576915.3616629">参考论文</a></p><blockquote><p>设 $A &#x3D; kq + r$，其中 $k \in [2^{511},2^{512}]，r \in [2^{255},2^{256}]$，由于 $q|(A - r)$ 且 $q|N_{12}$，该题可以转换成为PACDP，使用论文中 3.1 节的方法<br>通过 $Coppersmith$ 方法求解多项式 $A \equiv r \pmod{q}$，因为 $r \approx N_{12}^{0.25}$，刚好为 $Coppersmith$ 的理论边界，计算时间变得非常大<br>通过遍历 $r$ 的部分MSBs可以显著降低计算时间，但是爆破位数越多同样时间也会增长<br>我们最后选择爆破 $r$ 的11位MSBs</p></blockquote><p>我们的程序在13m成功分解 $N$</p><h2 id="附加题-随机数发生器"><a href="#附加题-随机数发生器" class="headerlink" title="附加题-随机数发生器"></a>附加题-随机数发生器</h2><p>纯脑洞题，不想写，可以看看<a href="https://tangcuxiaojikuai.xyz/post/4a67318c.html#more">糖醋小鸡块师傅的博客</a></p><h2 id="比赛感受"><a href="#比赛感受" class="headerlink" title="比赛感受"></a>比赛感受</h2><p>这一次比赛是和<a href="https://skatexu.github.io/">skateXu</a>，<a href="https://www.iamnahco3.cn/">IamNaHCO3</a>两位学长一起打的（其实整个学院本科就我们三个密码手）。四月底开始打，我因为期间还有区块链科研的任务和期末考试，整个比赛其实贡献很少，还好是初赛到决赛还有一个月给我赶上了进度。</p><p>老师不报销是最难受的，广州这边过去青岛飞机高铁都需要1000往上走了，还有住宿费用，怎么算都是亏本比赛了。最后选择了最便宜的绿皮火车出行，在硬卧上躺了32小时才到蓝村。第一次坐绿皮上的硬卧，原来是上中下三个铺子，空间很小，躺着头都抬不起来，人要弯着腰进去，网络还很卡。一天基本上吃一顿泡面就够了，醒着的时间基本上都在床上看小说或者和学长们玩数独，实际上大部分时间都在睡觉（听别人外放土味视频和哈基米）。</p><p>到了蓝村之后转了两次大巴，到了某40一晚的民宿旅馆（比赛协议酒店300多一晚太贵了），这民宿旅馆纯鬼屋。很老旧和门和床，一闪一闪的灯泡，整个旅馆就住一个人，厕所比我拳头大的虫子，关不上的厕所门，要素拉满了，和鬼片里面的山村旧客栈一样的。最后越想越红温，在周围问了一圈，找到一个家庭套房170一晚三个人住，这个的环境还是不错的。</p><p>比赛最后是拿了个三等奖，可惜是输在了创新点吧，优化也有差距。坐在下面听特等奖答辩时才发现大家都有CRT代数算法优化，第三题的优化还有很大空间，纯当CTF打了嘿嘿。虽然前面对于住行吐槽很多，但是总的来说其实体验还是可以的，这次比赛学到了不少RSA算法（以后又可以当脚本小子啦），赛后王小云院士还带领我们参观了一下山大的网安学院。</p><p>在这边出去吃了几顿烧烤，比广州便宜好多啊，广州5元一串的牛羊肉在青岛就要2元，味道也很不错。山大青岛校区非常大，爽骑电动车。食堂也很好吃，就是忘记签到了没拿餐券，偷偷摸摸的混进去吃饭的。周围的景点没怎么逛过，比完赛那天晚上到了海边走了一圈</p><p><img src="/img/bg/cmsecc_view1.jpg"></p><p><img src="/img/bg/cmsecc_view2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DLP学习</title>
    <link href="/2024/04/06/DLP%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/06/DLP%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="离散对数问题-DLP（Discrete-Logarithm-Problem）"><a href="#离散对数问题-DLP（Discrete-Logarithm-Problem）" class="headerlink" title="离散对数问题 DLP（Discrete Logarithm Problem）"></a>离散对数问题 DLP（Discrete Logarithm Problem）</h1><p><strong><del>做题时又被打爆了，记录一下</del></strong><br><strong>DLP就是离散对数问题，离散对数是基于群之上的概念，先简单说下群</strong></p><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>假设有一个非空集合 $ G $ ，以及一个二元运算 $ \times $ 所构成的集合 $ (G, \times) $ ，如果满足以下条件就是一个群：</strong></p><ul><li><strong>封闭性：$\forall a,b \in G , a \times b &#x3D; c \in G $</strong></li><li><strong>结合律：$\forall a,b,c \in G , a \times (b \times c) &#x3D; (a \times b) \times c$</strong></li><li><strong>单位元：$\exists e \in G,\forall a \in G , a \times e &#x3D; e \times a &#x3D; a$</strong></li><li><strong>逆元：$\forall a \in G,\exists b \in G , a \times b &#x3D; b \times a &#x3D; e$</strong></li></ul><p><strong>此外，如果一个群还满足</strong> $\forall a,b \in G,a \times b &#x3D; b \times a$ <strong>则称 $ G $ 为交换群或者阿贝尔群</strong></p><h3 id="有限群"><a href="#有限群" class="headerlink" title="有限群"></a>有限群</h3><p><strong>当一个群 $ G $ 中的元素只有有限个的时候，称其为有限群，其中群 $ G $ 的元素个数被称为群的阶或者基，记为 $|G|$</strong></p><p><strong>例如：$ (\mathbb{Z_n},+) $ 就是由集合 $ \mathbb{Z_n} &#x3D; {0,1,…,n-1} $ 与整数模 n 加法构成的群，它的阶为 n</strong></p><h3 id="元素的阶"><a href="#元素的阶" class="headerlink" title="元素的阶"></a>元素的阶</h3><p><strong>群 $ (G,\times) $ 内某个元素 $ a $ 的阶 ord(a) 是指满足以下条件的最小正整数 k</strong></p><p>$$<br>a^k &#x3D; a \times a \times a \ldots \times a &#x3D; e<br>$$</p><p><strong>e 是该群的单位元，值得注意的是 a^k 在群中不表示 a 的 k 次幂，而是将 a 进行 k 次群的二元运算</strong></p><h3 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h3><p><strong>对于群</strong> $ G ,a \in G $ <strong>则</strong> $ \langle a \rangle &#x3D; {a^z|z \in \mathbb{Z}} $ <strong>是由</strong> $ a $ <strong>生成的</strong> $ G $ <strong>的子群</strong><br><strong>若</strong> $ g \in G,G &#x3D; \langle g \rangle $ <strong>,则称</strong> $ G $ <strong>是循环群，</strong> $ g $ <strong>是生成元（</strong> $ G $ <strong>是阿贝尔群）</strong></p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ul><li><strong>对于每一个素数 $ p $ ，$(\mathbb{Z_p},*)$ 都是阿贝尔有限循环群</strong></li><li><strong>假设 $G$ 是一个有限循环群，则对于每一个 $a \in G$ 都有：</strong><ul><li><strong>$a^{|G|} &#x3D; e$</strong></li><li><strong>ord(a)是 $G$ 的因子</strong></li></ul></li><li><strong>拉格朗日定理：对于有限群 $G$ ，$H$ 是 $G$ 的任意子群，则 $|H|$ 是 $|G|$ 的因子</strong></li><li><strong>n阶有限循环群 &lt;g&gt;， $\forall k \in \mathbb{Z}$ ，有 $g^k$ 的阶是 $\frac{n}{\gcd(n,k)}$</strong></li></ul><h2 id="DLP"><a href="#DLP" class="headerlink" title="DLP"></a>DLP</h2><p><strong>简单来说就是给定大素数</strong> $p$ ，$g \in \mathbb{Z_p^*}$ <strong>求解以下问题</strong></p><p>$$y \equiv g^{x} \pmod{p}$$</p><h3 id="DHKE"><a href="#DHKE" class="headerlink" title="DHKE"></a>DHKE</h3><p><strong>Diffle-Hellman 密钥协商算法</strong></p><ol><li><strong>系统参数建立</strong><ol><li><strong>选择大素数 $p$ ，满足 $p-1$ 含有大素因子 $q$</strong></li><li><strong>选取整数 $g(1&lt;g&lt;p)$ ，满足 $g$ 模 $p$ 的阶为 $q$</strong></li></ol></li><li><strong>双方秘钥协商</strong><ol><li><strong>Alice 随机秘密选取 $a(0&lt;a&lt;p-1)$ ，并计算</strong><br> $$A \equiv g^{a} \pmod{p}$$</li><li><strong>Bob 随机秘密选取 $b(0&lt;b&lt;p-1)$ ，并计算</strong><br> $$B \equiv g^{b} \pmod{p}$$</li><li><strong>Alice 将 $A$ 传送给 Bob，Bob 将 $B$ 传送给 Alice</strong></li><li><strong>Alice 计算 $K \equiv B^{a} \pmod{p}$，Bob 计算 $K \equiv A^{b} \pmod{p}$</strong></li></ol></li></ol><p><strong>双方以 $K$ 为协商秘钥进行保密通信</strong><br><strong>事实上，有</strong><br>$$K \equiv A^{b} \equiv B^{a} \equiv g^{ab} \pmod{p}$$</p><h3 id="DDH（判定性离散对数问题）"><a href="#DDH（判定性离散对数问题）" class="headerlink" title="DDH（判定性离散对数问题）"></a>DDH（判定性离散对数问题）</h3><p><strong>假如说 Alice 和 Bob 执行如上所述的 Diffie-Hellman 密钥协议,那么</strong> $ G,g,g^a,g^b $ <strong>都是公共的,</strong> $ g^{ab} $ <strong>是密钥.直观上,DDH问题就是是否对手能够从随机的</strong> $ G $ <strong>中的元素区分出 Alice 和 Bob 的密钥</strong> $ g^{ab} $<br><strong>正式来说:给定</strong> $ G,g,g^a,g^b $ <strong>和</strong> $ T_x $ <strong>使得</strong> $ T_0 $ <strong>是</strong> $ G $ <strong>中随机的一个元素,</strong> $T_1 &#x3D; g^{ab} $ <strong>同时</strong> $ x $ <strong>被随机均匀的从{0,1}中选择,找出 $x$</strong></p><p><strong>贴道例题，<del>悄悄从别的平台上面修改过来的</del></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br>FLAG = <span class="hljs-string">&quot;flag&#123;this_is_a_test_flag&#125;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DDHgame</span>(<span class="hljs-params">m, p</span>):<br>    g = <span class="hljs-number">2</span><br>    a = random.randint(<span class="hljs-number">1</span>, p-<span class="hljs-number">1</span>)<br>    b = random.randint(<span class="hljs-number">1</span>, p-<span class="hljs-number">1</span>)<br>    c = a*b%(p-<span class="hljs-number">1</span>)<br>    ga = <span class="hljs-built_in">pow</span>(g, a, p)<br>    gb = <span class="hljs-built_in">pow</span>(g, b, p)<br>    gc = <span class="hljs-built_in">pow</span>(g, c, p)<br>    <span class="hljs-keyword">if</span> m:<br>        <span class="hljs-keyword">return</span> (ga, gb, gc)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> (ga, gb, random.randint(<span class="hljs-number">0</span>, p-<span class="hljs-number">1</span>))<br>    <br>p = getPrime(<span class="hljs-number">512</span>)<br>m = <span class="hljs-built_in">bin</span>(bytes_to_long(FLAG))[<span class="hljs-number">2</span>:]<br>challenge = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> m:<br>    challenge.append(DDHgame(<span class="hljs-built_in">int</span>(i), p))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;p = &#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;challenge = &#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>这道例题简单的实现了DDH加密，在这里就是需要辨别gc和一个大小(0,p-1)的随机数哪一个是属于群内的，从而推断出m的二进制位</strong></p><h3 id="Elgamal"><a href="#Elgamal" class="headerlink" title="Elgamal"></a>Elgamal</h3><p><strong>我们假设 A 发消息 m 给 B</strong></p><p><strong>加密过程</strong></p><ul><li><strong>随机选择一个满足要求的大素数</strong> $p$ <strong>，并生成有限域</strong> $\mathbb{Z_p}$ <strong>的一个生成元</strong> $g \in \mathbb{Z_p^*}$</li><li><strong>选择一个随机数</strong> $k(1&lt;k&lt;p-2)$ <strong>，计算</strong> $y \equiv g^{k} \pmod{p}$</li><li><strong>其中私钥为</strong> $k$ <strong>公钥为</strong> $p,g,y$</li><li>$A$ <strong>选取随机数</strong> $r \in \mathbb{Z_{p-1}}$ <strong>，对明文加密</strong> $E_k(m,r) &#x3D; (y_1,y_2)$ <strong>。其中</strong> $y_1 \equiv g^r \pmod{p}，y_2 \equiv my^r \pmod{p}$</li></ul><p><strong>解密过程</strong></p><p>$D_k(y_1,y_2) &#x3D; y_2 (y_1^k)^{-1} \pmod{p} \equiv m(g^k)^r(g^{rk})^{-1} \equiv m \mod{p}$ </p><p><strong>贴道题，<del>这个类型的题目好像经常出现（？）</del></strong><br><strong>2018 Code Blue lagalem（感谢CTF Wiki，每次例题都是上面扒下来的还有解析嘿嘿）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> key <span class="hljs-keyword">import</span> FLAG<br><br>size = <span class="hljs-number">2048</span><br>rand_state = getRandomInteger(size // <span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">keygen</span>(<span class="hljs-params">size</span>):<br>    q = getPrime(size)<br>    k = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = q * k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> isPrime(p):<br>            <span class="hljs-keyword">break</span><br>        k += <span class="hljs-number">1</span><br>    g = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(g, q, p) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        g += <span class="hljs-number">1</span><br>    A = getRandomInteger(size) % q<br>    B = getRandomInteger(size) % q<br>    x = getRandomInteger(size) % q<br>    h = <span class="hljs-built_in">pow</span>(g, x, p)<br>    <span class="hljs-keyword">return</span> (g, h, A, B, p, q), (x,)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand</span>(<span class="hljs-params">A, B, M</span>):<br>    <span class="hljs-keyword">global</span> rand_state<br>    rand_state, ret = (A * rand_state + B) % M, rand_state<br>    <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">pubkey, m</span>):<br>    g, h, A, B, p, q = pubkey<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt; m &lt;= p<br>    r = rand(A, B, q)<br>    c1 = <span class="hljs-built_in">pow</span>(g, r, p)<br>    c2 = (m * <span class="hljs-built_in">pow</span>(h, r, p)) % p<br>    <span class="hljs-keyword">return</span> (c1, c2)<br><br><span class="hljs-comment"># pubkey, privkey = keygen(size)</span><br><br>m = bytes_to_long(FLAG)<br>c1, c2 = encrypt(pubkey, m)<br>c1_, c2_ = encrypt(pubkey, m)<br><br><span class="hljs-built_in">print</span> pubkey<br><span class="hljs-built_in">print</span>(c1, c2)<br><span class="hljs-built_in">print</span>(c1_, c2_)<br></code></pre></td></tr></table></figure><p><strong>可以看出，该算法就是一个 ElGamal 加密，给了同一个明文两组加密后的结果，其特点在于使用的随机数 r 是通过线性同余生成器生成的，则我们知道</strong></p><p>$$<br>c_2 \equiv (m \cdot h^r) \mod p \<br>c_{2’} \equiv m \cdot h^{(Ar + B) \mod q} \equiv m \cdot h^{(Ar + B)} \pmod{p}<br>$$</p><p><strong>则</strong></p><p>$$<br>\frac{c_2^A*h^B}{c_{2’}} \equiv m^{A-1} \pmod{p}<br>$$</p><p><strong>其中</strong> $c_2,c_{2’},A,B,h$ <strong>都知道，则我们知道</strong></p><p>$$<br>m^{A-1} \equiv t \pmod{p}<br>$$</p><p><strong>我们假设已知 p 的一个原根 g，则我们可以假设</strong></p><p>$$<br>g^x \equiv t \<br>g^y \equiv m<br>$$</p><p><strong>则</strong></p><p>$$<br>g^{y(A-1)} \equiv g^x \pmod{p}<br>$$</p><p><strong>则</strong></p><p>$$<br>y(A-1) \equiv x \pmod{p-1} \<br>y(A-1) - k(p-1) &#x3D; x<br>$$</p><p><strong>这里我们知道 A，p，x，则我们可以利用扩展欧几里得定理求得</strong></p><p>$$<br>s(A−1)+w(p−1)&#x3D;gcd(A−1,p−1)<br>$$</p><p><strong>如果 gcd(A-1,p-1)&#x3D;d，则我们直接计算</strong></p><p>$$<br>t^s \equiv m^{s(A-1)} \equiv m^d \pmod{p}<br>$$</p><p><strong>如果 d &#x3D; 1 ，就可以直接计算 m ，不为1计算就有点困难，在这里恰好为1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br>data = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./transcript.txt&#x27;</span>).read().split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>g, h, A, B, p, q = <span class="hljs-built_in">eval</span>(data[<span class="hljs-number">0</span>])<br><br>c1, c2 = <span class="hljs-built_in">eval</span>(data[<span class="hljs-number">1</span>])<br>c1_, c2_ = <span class="hljs-built_in">eval</span>(data[<span class="hljs-number">2</span>])<br><br>tmp = gmpy2.powmod(c2, A, p) * gmpy2.powmod(h, B, p) * gmpy2.invert(c2_, p)<br>tmp = tmp % p<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;t=&#x27;</span>, tmp<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;A=&#x27;</span>, A<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;p=&#x27;</span>, p<br>gg, x, y = gmpy2.gcdext(A - <span class="hljs-number">1</span>, p - <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span> gg<br><br>m = gmpy2.powmod(tmp, x, p)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(m)[<span class="hljs-number">2</span>:].decode(<span class="hljs-string">&#x27;hex&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="Schnorr"><a href="#Schnorr" class="headerlink" title="Schnorr"></a>Schnorr</h3><ol><li><strong>密钥生成</strong><ul><li>选择一个大的素数 $p$ 和 $p-1$ 的一个大素数因子 $q$</li><li>选择一个模 $p$ 的阶为 $q$ 的元素 $g$</li><li>选择一个私钥 $x$ ，它是比 $q$ 小的随机数</li><li>计算 $y &#x3D; g^x \mod p$ ， $y$ 就是对应的公钥</li></ul></li><li><strong>签名生成</strong><ul><li>选择一个随机数 $k &lt; q$ ，然后计算 $r &#x3D; g^k \mod p$ 和 $e &#x3D; H(r || M)$</li><li>计算 $s &#x3D; k - xe \mod q$</li><li>签名结果就是 $(s, e)$</li></ul></li><li><strong>签名验证</strong><ul><li>对于收到的签名 $(s, e)$ ，验证者执行以下过程</li><li>计算 $r_v &#x3D; g^sy^e \mod p$</li><li>计算 $e_v &#x3D; H(r_v || M)$</li><li>如果 $e_v &#x3D;&#x3D; e$ ，那么验证通过，否则失败</li><li>验证过程正确性：$r_v &#x3D; g^sy^e &#x3D; g^{s+xe} &#x3D; g^k &#x3D; r$</li><li>所以 $e_v &#x3D; H(r_v||M) &#x3D; H(r||M) &#x3D; e$</li></ul></li><li><strong>Schnorr群</strong><ul><li>上述计算过程要求在一个有限群上进行，这个群的阶是 $q$, $q$ 如何得来？这就是Schnorr群的算法。 </li><li>构造Schnorr群首先选择两个大素数：$p,q$ 满足：$p &#x3D; q*r + 1$</li><li>$r$ 是大于1的整数，明显 $q$ 是 $p-1$ 的大素因子</li><li>然后在 $(0,q)$ 之间找到一个 $h$ ，使得 $h^r \neq 1 \mod p$</li><li>那么 $g &#x3D; h^r \neq 1 \mod p$ 是 $q$ 阶子群的生成元</li><li>为什么以 $g$ 为生成元的群会有 $q$ 的阶呢？看下式：</li><li>$g^q \equiv h^{rq} \equiv h^{p-1} \equiv 1 \mod p$</li><li>这里用了费马小定理，表明了 $g$ 的阶只能是 $q$ 或者 $q$ 的因数，但因为 $h^r \neq 1 \mod p$ 并且 $q$ 是素数，所以 $g$ 的阶必定是 $q$</li><li>这样生成的群就叫做Schnorr群，特点是 $q$ 素数阶，可以避免小子群攻击，且素数阶群必为循环群</li></ul></li></ol><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><ol><li><strong>密钥生成</strong><ul><li>选择一个合适的哈希函数，目前一般选择SHA1，也可以选择强度更高的其他哈希函数</li><li>选择秘钥的长度 $L$ 和 $N$ ，这两个值决定了签名的安全程度</li><li>选择 $N$ 比特的素数 $q$ 和 $L$ 比特的素数 $p$ ，使得 $q$ 为 $p-1$ 的大素因子</li><li>选择满足 $g^k &#x3D; 1 \mod p$ 的最小正整数 $k$ 为 $q$ 的 $g$ ，即在模 $p$ 下，$ord(g) &#x3D; q$ 的 $g$ 。即 $g$ 在模 $p$ 下，其指数次幂可以生成具有 $q$ 个元素的子群。这里可以计算 $g \equiv h^{\frac{p-1}{q}} \mod p$ 来得到 $g$ ，其中 $h \in (1,p-1)$</li><li>选择私钥 $x \in (0,q)$ ，计算 $y \equiv g^x \pmod{p}$</li><li>公钥为 $(p,q,g,y)$ ，私钥为 $(x)$</li></ul></li><li><strong>签名生成</strong><ul><li>随机选择整数 $k \in (0,q)$ </li><li>计算 $r \equiv g^k \pmod{p} \pmod{q}$</li><li>计算 $s \equiv (H(m) + xr)k^{-1} \pmod{q}$</li><li>签名结果为 $(r,s)$</li></ul></li><li><strong>签名验证</strong><ul><li>计算辅助值 $w \equiv s^{-1} \pmod{q}$</li><li>计算辅助值 $u_1 \equiv H(m) \cdot w \pmod{q} $</li><li>计算辅助值 $u_2 \equiv r \cdot w \pmod{q} $</li><li>计算 $v &#x3D; g^{u_1}y^{u_2} \pmod{q} \pmod{q}$</li><li>如果 $v &#x3D;&#x3D; r$ 那么验证通过</li></ul></li><li><strong>攻击</strong><ul><li><strong>$k$ 复用</strong> </li><li>如果在两次签名的过程中共享了 $k$ ，就可以进行攻击</li><li>假设两次签名的消息为 $m_1$ 和 $m_2$ ，显然两个的 $r$ 一样，此外</li><li>$s_1 &#x3D; (H(m_1) + xr)k^{-1} \pmod{q}$</li><li>$s_2 &#x3D; (H(m_2) + xr)k^{-1} \pmod{q}$</li><li>这里除了 $x$ 和 $k$ 不知道剩下的都知道，联立有 $k(s_1 - s_2) \equiv (H(m_1) - H(m_2)) \pmod{q}$</li><li>此时可以解出 $k$ ，可以进一步解出 $x$</li></ul></li></ol><h2 id="离散对数求解方法"><a href="#离散对数求解方法" class="headerlink" title="离散对数求解方法"></a>离散对数求解方法</h2><h3 id="常规sage函数"><a href="#常规sage函数" class="headerlink" title="常规sage函数"></a>常规sage函数</h3><p><strong>参数说明：求解以<code>base</code>为底，<code>a</code>的对数；<code>ord</code>为<code>base</code>的阶，可以缺省，<code>operation</code>可以是<code>+</code>与<code>*</code>，默认为<code>*</code>；<code>bounds</code>是一个区间<code>(ld,ud)</code>，需要保证所计算的对数在此区间内</strong></p><ul><li><code>discrete_log(a,base,ord,operation)</code> <strong>通用的</strong></li><li><code>discrete_log_rho(a,base,ord,operation)</code> <strong>Pollard-Rho算法</strong></li><li><code>discrete_log_lambda(a,base,bounds,operation)</code> <strong>Pollard-kangaroo算法（也称为lambda算法）</strong></li><li><code>sage.groups.generic.bsgs(a, b, bounds, operation=&#39;*&#39;)</code> <strong>小步大步法</strong></li></ul><h3 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h3><p><strong>这一方法通常被称为小步大步法，这一方法使用了中间相遇攻击的思想</strong></p><p><strong>我们可以令</strong> $x &#x3D; im + j$ <strong>,其中</strong> $m &#x3D; \lceil \sqrt{n} \rceil$ <strong>那么整数</strong> $i$ <strong>和</strong> $j$ <strong>都在</strong> $0$ <strong>到</strong> $m$ <strong>的范围内，因此</strong></p><p>$$<br>y &#x3D; g^x &#x3D; g^{im + j}<br>$$</p><p><strong>也就是</strong></p><p>$$<br>y(g^{-m})^i &#x3D; g^j<br>$$</p><p><strong>那么我们就可以枚举所有的</strong> $j$ <strong>进行计算，并将其存储到一个集合</strong> $S$ <strong>中，然后我们再次枚举</strong> $i$ <strong>计算</strong> $y(g^{-m})^i$ <strong>，一旦我们发现计算的结果在集合</strong> $S$ <strong>中，则说明我们得到了一个碰撞，进而得到了</strong> $i$ <strong>和</strong> $j$</p><p><strong>其中</strong></p><ul><li>每一次 $j$ 的增加表示”baby-step” ，一次乘上 $g$</li><li>每一次 $i$ 的增加表示”giant-step” ，一次乘上 $g^{-m}$<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bsgs</span>(<span class="hljs-params">g, y, p</span>):<br>    m = <span class="hljs-built_in">int</span>(ceil(sqrt(p - <span class="hljs-number">1</span>)))<br>    S = &#123;<span class="hljs-built_in">pow</span>(g, j, p): j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)&#125;<br>    gs = <span class="hljs-built_in">pow</span>(g, p - <span class="hljs-number">1</span> - m, p)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">in</span> S:<br>            <span class="hljs-keyword">return</span> i * m + S[y]<br>        y = y * gs % p<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="拓展BSGS算法"><a href="#拓展BSGS算法" class="headerlink" title="拓展BSGS算法"></a>拓展BSGS算法</h3><p><strong>还是同样的问题，求解</strong> $a^x \equiv b \mod p$ <strong>,但是</strong> $p$ <strong>非质数怎么办呢，也就是说可能</strong> $a,p$ <strong>可能不互质，那么我们就需要想办法转换成为互质的，然后使用普通BSGS求解</strong></p><p><strong>将同余式转换：</strong> $sa^x + tp &#x3D; b$</p><p><strong>令</strong> $d_1 &#x3D; gcd(a,p)$ <strong>，即</strong> $d_1(sa^{x-1}\frac{a}{d_1} + t\frac{p}{d_1}) &#x3D; b$</p><p><strong>此时，若</strong> $d_1 \nmid b$ <strong>那么无整数解</strong></p><p><strong>我们在能够整除的情况下继续研究，即</strong></p><p>$$<br>sa^{x-1}\frac{a}{d_1} + t\frac{p}{d_1} &#x3D; \frac{b}{d_1} \<br>a^{x-1}\frac{a}{d_1} \equiv \frac{b}{d_1} \pmod{\frac{p}{d_1}}<br>$$</p><p><strong>此时若</strong> $a$ <strong>与</strong> $\frac{p}{d_1}$ <strong>仍不互质，那么继续上述的转换，令</strong> $d_2 &#x3D; gcd(a,\frac{p}{d_1})$</p><p>$$<br>\frac{a}{d_1d_2}\cdot a^{x-2} \equiv \frac{b}{d_1d_2} \pmod{\frac{p}{d_1d_2}}<br>$$</p><p><strong>同理不断处理，直到</strong> $gcd(a,\frac{p}{d_1d_2\dots d_k}) &#x3D; 1$</p><p><strong>记</strong> $D &#x3D;  \prod_{i&#x3D;1}^{k} d_i $</p><p>$$<br>\frac{a}{D^k}\cdot a^{x-k} \equiv \frac{b}{D} \pmod{\frac{p}{D}}<br>$$</p><p><strong>这样，把</strong> $\frac{a^k}{D}$ <strong>通过逆元丢到方程右边就可以用普通BSGS求解了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-type">int</span> i=a%b)&#123;<br>            a=b;<br>            b=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(ll a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-comment">//这个快速幂保证p不是1，少模一次是一次</span><br>    ll s=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)<br>            s=s*a%m;<br>        a=a*a%m;<br>        n&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br> <br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; M;<br><span class="hljs-comment">//要求a,n互质 a^x=b mod n .k,t是留给exbsgs调用的</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsgs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    M.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-type">int</span> m=<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(n));<br>    ll s=b;<span class="hljs-comment">//BS</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++,s=s*a%n)<br>        M[s]=i;<br> <br>    s=k;<span class="hljs-comment">//GS</span><br>    k=<span class="hljs-built_in">qpow</span>(a,m,n);<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        s=s*k%n;<br>        <span class="hljs-keyword">if</span>(M.<span class="hljs-built_in">count</span>(s))<br>            <span class="hljs-keyword">return</span> i*m-M[s]+t;  <span class="hljs-comment">//这样就保证找到的是最小解了</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-comment">//a^x=b mod n</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exbsgs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> d=<span class="hljs-built_in">gcd</span>(a,n),k=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(d^<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span>(b%d) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ++t;<br>        b/=d;<br>        n/=d;<br>        k=(ll)k*(a/d)%n;<br>        <span class="hljs-keyword">if</span>(b==k) &#123;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>        d=<span class="hljs-built_in">gcd</span>(a,n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bsgs</span>(a,b,n,k,t);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a,b,n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;n,&amp;b);<br>        <span class="hljs-keyword">if</span>(!a&amp;&amp;!n&amp;&amp;!b)<br>            <span class="hljs-keyword">break</span>;<br>        a%=n;<br>        b%=n;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-built_in">exbsgs</span>(a,b,n);<br>        <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No Solution&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pollard-Rho算法"><a href="#Pollard-Rho算法" class="headerlink" title="Pollard Rho算法"></a>Pollard Rho算法</h3><p><strong>原理和RSA里面的那个素数分解的Pollard Rho算法差不多，也是一个概率型的算法，适用于生成元的阶的素因子都是大数的情形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pollard_rho</span>(<span class="hljs-params">g, y, p</span>):<br>    q = (p-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_xab</span>(<span class="hljs-params">x, a, b,  g, y, p, q</span>):<br>        subset = x % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> subset == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ((x*x) % p, (a*<span class="hljs-number">2</span>) % q, (b*<span class="hljs-number">2</span>) % q)<br>        <span class="hljs-keyword">if</span> subset == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> ((x*g) % p, (a+<span class="hljs-number">1</span>) % q, b        )<br>        <span class="hljs-keyword">if</span> subset == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> ((x*y) % p, a        , (b+<span class="hljs-number">1</span>) % q)<br>    x, a, b = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    X, A, B = x, a, b<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, p):<br>        x, a, b = new_xab(x, a, b,  g, y, p, q)<br>        X, A, B = new_xab(X, A, B,  g, y, p, q)<br>        X, A, B = new_xab(X, A, B,  g, y, p, q)<br>        <span class="hljs-keyword">if</span> x == X:<br>            <span class="hljs-keyword">break</span><br>    res = ((a - A) * <span class="hljs-built_in">pow</span>(B - b, -<span class="hljs-number">1</span>, q)) % q<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(g, res, p) == y:<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(g, res + q, p) == y:<br>        <span class="hljs-keyword">return</span> res + q<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>g = <br>y = <br>p = <br>x = pollard_rho(g, y, p)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(g, x, p) == y)<br></code></pre></td></tr></table></figure><h3 id="Pollard’s-kangaroo-algorithm算法"><a href="#Pollard’s-kangaroo-algorithm算法" class="headerlink" title="Pollard’s kangaroo algorithm算法"></a>Pollard’s kangaroo algorithm算法</h3><p><strong>如果我们知道</strong> $x$ <strong>的范围为</strong> $a \leq x \leq b$ <strong>那么我们可以以</strong> $O(\sqrt{b-a})$ <strong>的时间复杂度解决问题</strong></p><ul><li><code>discrete_log_lambda(a,base,bounds,operation)</code> <strong>sage里调用</strong></li></ul><h3 id="Pohlig-Hellman算法"><a href="#Pohlig-Hellman算法" class="headerlink" title="Pohlig-Hellman算法"></a>Pohlig-Hellman算法</h3><p><strong>只能用于求解光滑阶（即可以因子分解成较小的数的乘积）循环群上的离散对数</strong></p><p><strong>对于DLP问题</strong> $a^x \equiv b \pmod{p}$ <strong>，因为</strong> $p$ <strong>是大素数，模</strong> $p$ <strong>的循环群的阶是</strong> $p-1$ <strong>，假设模</strong> $p$ <strong>的最小的本原元是</strong> $g$ <strong>，那么有</strong></p><p>$$<br>a \equiv g^{a’} \pmod{p} \<br>b \equiv g^{b’} \pmod{p}<br>$$</p><p><strong>就有</strong> $a’x \equiv b’ \pmod{p-1}$ <strong>，如果求出了</strong> $a’$ <strong>和</strong> $b’$ <strong>就可以通过拓展gcd来求出 x ，现在问题就变成了怎么求解</strong></p><p>$$<br>a \equiv g^{a’} \pmod{p} \<br>b \equiv g^{b’} \pmod{p}<br>$$</p><p><strong>以求解</strong> $a’$ <strong>为例，解DLP问题：</strong> $g^x \equiv a \pmod{p}$</p><p><strong>将</strong> $p-1$ <strong>分解为素因子</strong> $p-1 &#x3D; \prod_{i&#x3D;1}^{m} p_i^{k_i} &#x3D; p_1^{k_1}p_2^{k_2} \dots p_m^{k_m}$</p><p><strong>对于每一个素因子</strong> $p_i$ <strong>将</strong> $x$ <strong>表示成</strong> $p_i$ <strong>进制，有</strong></p><p>$$<br>x &#x3D; a_0 + a_1p_1 + a_2p^2_2 + a_3p^3_3 + \dots + a_{k_i-1}p_i^{k_i-1} \pmod{p_i^{k_i}}<br>$$</p><p><strong>这样的</strong> $p_i$ <strong>进制表示，系数</strong> $a_i$ <strong>自然是小于</strong> $p_i$ </p><p><strong>令</strong> $r &#x3D; 1$ <strong>有</strong> $(g^x)^{\frac{p-1}{p_i^r}} \equiv a^{\frac{p-1}{p_i^r}} \pmod{p}$ <strong>，展开</strong> $x$ <strong>有</strong><br>$$<br>(g^{a_0 + a_1p_1 + a_2p^2_2 + a_3p^3_3 + \dots + a_{k_i-1}p_i^{k_i-1}})^{\frac{p-1}{p_i^r}} \equiv a^{\frac{p-1}{p_i^r}} \pmod{p}<br>$$</p><p>$$<br>g^{a_0\frac{p-1}{p_i}} \cdot g^{a_1(p-1)} \cdot g^{a_2(p-1)p_i} \cdots g^{a_{k_i-1}(p-1)p_i^{k_i-2}} \equiv a^{\frac{p-1}{p_i^r}} \pmod{p}<br>$$</p><p><strong>注意到从第二项开始，每一项都含有</strong> $p-1$ <strong>，费马小定理得</strong> $g^{p-1} \equiv 1 \pmod{p}$ <strong>原式变成：</strong></p><p>$$<br>g^{a_0\frac{p-1}{p_i}} \equiv a^{\frac{p-1}{p_i^r}} \pmod{p}<br>$$</p><p><strong>这个式子中只有</strong> $a_0$ <strong>是未知的，因为</strong> $a_o \in [0,p_i-1]$ <strong>所以可以枚举出</strong> $a_0$ <strong>的值</strong></p><p><strong>再令</strong> $r &#x3D; 2,3,4, \cdots ,k_i$ <strong>重复上面的方法，枚举求出</strong> $a_1,a_2,\cdots,a_{k_i-1}$ <strong>可以得到</strong></p><p>$$<br>x &#x3D; a_0 + a_1p_1 + a_2p^2_2 + a_3p^3_3 + \dots + a_{k_i-1}p_i^{k_i-1} \pmod{p_i^{k_i}}<br>$$</p><p><strong>对于每一个素因子都有上述过程，最后可以得到 m 个关于</strong> $x$ <strong>的式子，用CRT就可以计算出</strong> $x$ <strong>的值，利用这个方法就可以求出</strong> $a’$ <strong>和</strong> $b’$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Baby-step Giant-step法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">babystep_giantstep</span>(<span class="hljs-params">g, y, p, q=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        q = p - <span class="hljs-number">1</span><br>    m = <span class="hljs-built_in">int</span>(q**<span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>)<br>    <span class="hljs-comment"># Baby step</span><br>    table = &#123;&#125;<br>    gr = <span class="hljs-number">1</span>  <span class="hljs-comment"># g^r</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        table[gr] = r<br>        gr = (gr * g) % p<br>    <span class="hljs-comment"># Giant step</span><br>    <span class="hljs-keyword">try</span>:<br>        gm = <span class="hljs-built_in">pow</span>(g, -m, p)  <span class="hljs-comment"># gm = g^&#123;-m&#125;</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    ygqm = y                <span class="hljs-comment"># ygqm = y * g^&#123;-qm&#125;</span><br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-keyword">if</span> ygqm <span class="hljs-keyword">in</span> table:<br>            <span class="hljs-keyword">return</span> q * m + table[ygqm]<br>        ygqm = (ygqm * gm) % p<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># Pohlig–Hellman法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pohlig_hellman_DLP</span>(<span class="hljs-params">g, y, p</span>):<br>    crt_moduli = []<br>    crt_remain = []<br>    <span class="hljs-keyword">for</span> q, _ <span class="hljs-keyword">in</span> factor(p-<span class="hljs-number">1</span>):<br>        x = babystep_giantstep(<span class="hljs-built_in">pow</span>(g,(p-<span class="hljs-number">1</span>)//q,p), <span class="hljs-built_in">pow</span>(y,(p-<span class="hljs-number">1</span>)//q,p), p, q)<br>        <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>) <span class="hljs-keyword">or</span> (x &lt;= <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">continue</span><br>        crt_moduli.append(q)<br>        crt_remain.append(x)<br>    x = crt(crt_remain, crt_moduli)<br>    <span class="hljs-keyword">return</span> x<br><br>g = <br>y = <br>p = <br>x = pohlig_hellman_DLP(g, y, p)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(g, x, p) == y)<br></code></pre></td></tr></table></figure><hr><p><strong>参考:</strong><br><strong><a href="https://learnblockchain.cn/article/1527">区块链中的数学-Schnorr 离散对数签名及素数阶群构造（Schnorr 群）</a></strong><br><strong><a href="https://www.cnblogs.com/mumuhhh/p/17799384.html">crypto常用算法</a></strong><br><strong><a href="https://lazzzaro.github.io/2020/05/07/crypto-%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/">离散对数(by Lazzaro)</a></strong><br><strong><a href="https://ctf-wiki.org/crypto/asymmetric/discrete-log/discrete-log/#_1">离散对数(by CTF-Wiki)</a></strong><br><strong><a href="https://www.cnblogs.com/jeefy/p/17055264.html">算法学习笔记(10): BSGS算法及其扩展算法</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>DLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Babai算法</title>
    <link href="/2024/03/30/Babai%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/30/Babai%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Babai-算法"><a href="#Babai-算法" class="headerlink" title="Babai 算法"></a>Babai 算法</h1><h2 id="Babai’s-nearest-plane-algorithm"><a href="#Babai’s-nearest-plane-algorithm" class="headerlink" title="Babai’s nearest plane algorithm"></a>Babai’s nearest plane algorithm</h2><p><strong>Babai 算法常用来解决CVP问题，近似因子 $\gamma &#x3D; 2^{n&#x2F;2}$</strong></p><p><strong>在密码学中，CVP（Closest Vector Problem）是一个基于格的问题，其中要求找到给定格中离目标点最近的点。然而，在实际应用中，我们通常关心的是近似 CVP 问题，也就是找到一个距离目标点不超过最近格点距离的某个因子（通常记作 $\gamma$）的格点</strong></p><p><strong>这个因子 $\gamma$ 被称为近似因子。当 $\gamma &#x3D; 1$ 时，我们就得到了原始的 CVP 问题。当 $\gamma &gt; 1$ 时，我们就允许找到的点与目标点的距离超过最近格点的距离，但不能超过这个距离的 $\gamma$ 倍</strong></p><p><strong>近似因子 $\gamma$ 的大小影响了近似 CVP 问题的难度。当 $\gamma$ 越大时，问题就越容易解决，因为允许的解的范围越大。当 $\gamma$ 越小（但大于 1）时，问题就越难解决，因为允许的解的范围越小</strong></p><p><strong>（其实CVP问题还有几个不同版本，但就CTF来说，一般是上面那个，<del>其它的看不懂</del>）</strong></p><p><strong>举个例子解释一下这个算法</strong></p><p><strong>设格 $L \subset R^2$，向量 $v_1 &#x3D; (137,312),v_2 &#x3D; (215,-187)$ 是格的基，需要寻找一个 $L$ 中的向量 $v$ ，满足 $||w-v||$ 最小，其中 $w &#x3D; (53172,81743)$</strong></p><p><strong>我们要找的一个最近的向量，即 $w &#x3D; t_1v_1 + t_2v_2$ ，所以有以下方程</strong></p><p>$$<br>\begin{pmatrix}<br>53712 &amp; 81743<br>\end{pmatrix} &#x3D;<br>\begin{pmatrix}<br>t_1 &amp; t_2<br>\end{pmatrix}<br>\begin{bmatrix}<br>137 &amp; 312 \\<br>215 &amp; -187<br>\end{bmatrix}<br>$$</p><p><strong>可以解得，$t_1 \approx 296.85,t_2 \approx 58.15$ ,所以接近的向量 $v &#x3D; 287 (137,312) + 58(215,-187) &#x3D; (53159,81818)$</strong></p><p><strong>计算一下误差 $||v-w|| \approx 76.12$ ，还是比较接近 $w$</strong></p><p><strong>但是对于另一组基 $v_1 &#x3D; (1975,438),v_2 &#x3D; (7548,1627)$ 也用这种算法，我们得到的 $v’ &#x3D; (56405,82444)$，计算误差 $||v’-w|| \approx 3308.12$ ，误差较大</strong></p><p><strong>对于两组基为什么会得到不太一样的效果呢？这里给大家介绍一下哈达马比例（Hadamard ratio）</strong></p><p>$$<br>H(v_1,v_2) &#x3D; \left(\frac{\det(L)}{||v_1||||v_2||}\right)^\frac{1}{2}<br>$$</p><p><strong>对于 n 维的情况下，有</strong></p><p>$$<br>H(v_1,v_2,\ldots,v_n) &#x3D; \left(\frac{\det(L)}{||v_1||||v_2||\ldots||v_n||}\right)^\frac{1}{n}<br>$$</p><p><strong>我们分别计算上面两组基的哈达马比例</strong></p><p><strong>对于第一组基</strong></p><p>$$<br>H(v_1,v_2) &#x3D; \left(\frac{\det(L)}{||v_1||||v_2||}\right)^\frac{1}{2} \approx \left(\frac{92699}{(340.75)(284.95)}\right)^\frac{1}{2} \approx 0.997<br>$$</p><p><strong>非常接近于1</strong></p><p><strong>对于第二组基</strong></p><p>$$<br>H(v_1,v_2) &#x3D; \left(\frac{\det(L)}{||v_1||||v_2||}\right)^\frac{1}{2} \approx \left(\frac{92699}{(2022.99)(7721.36)}\right)^\frac{1}{2} \approx 0.077<br>$$</p><p><strong>非常接近于0</strong></p><p><strong>我们把接近于1的基称为好基（Good Basis），接近于0的基称为坏基（Bad Basis）。这里需要提的一点是，哈达马系数的范围是(0,1)的</strong></p><p><strong>该题的解题想法，就是Babai算法的思想，找到一个好基，这样我们就可以近似的求出最接近的向量了</strong></p><p><strong>具体算法</strong></p><p><img src="/img/bg/babai_1.jpg"></p><p><strong>其中</strong> $c_j$ <strong>为 Gram-schmidt 正交化中的系数取整，也即</strong> $proj_{b_j}(b)$ ( $b$ 在$b_j$ 上的投影) <strong>的取整</strong></p><p><strong>对于该算法第二步的个人理解(来自于CTF Wiki)：在格基规约和正交化(LLL)过后的基 $B$ 中找到一个最靠近 $t$ 的线性组合</strong></p><h2 id="Babai’s-Rounding-Technique"><a href="#Babai’s-Rounding-Technique" class="headerlink" title="Babai’s Rounding Technique"></a>Babai’s Rounding Technique</h2><p><strong>该算法是Babai’s nearest plane algorithm的一个变种</strong></p><p><strong>步骤可以表示为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">N = rank(B), w = target<br>- <span class="hljs-string">B&#x27; = LLL(B)</span><br><span class="hljs-string">- Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b&#x27;</span>_i).<br>* (<span class="hljs-string">b&#x27;_i is the i-th vector in the LLL-reduced basis B&#x27;</span>)<br>- Round each l_i to it<span class="hljs-string">&#x27;s closest integer l&#x27;</span>_i.<br>- Result v = <span class="hljs-built_in">sum</span>(l<span class="hljs-string">&#x27;_i * b&#x27;</span>_i)<br></code></pre></td></tr></table></figure><h2 id="HNP"><a href="#HNP" class="headerlink" title="HNP"></a>HNP</h2><p><strong>Hidden number problem</strong></p><p><strong>给的质数 $p$ ，许多 $t \in F_p$ 以及每一个的 $MSB_{l,p}(at)$，找出对应的 $a$</strong></p><ul><li>$MSB_{l,p}(x)$ <strong>表示任一满足 $|(x \mod p) - u| \leq \frac{p}{2^{l+1}}$ 的整数 $u$ ，近似为取 $x \mod p$ 的 $l$ 个最高有效位</strong></li></ul><p><strong>根据参考三的描述，当 $l \approx \log^{1&#x2F;2}p$ 时，有如下算法可以解决HNP</strong></p><p><strong>我们可以将此问题转化为一个由该矩阵生成的格上的 CVP 问题：</strong></p><p>$$<br>\begin{bmatrix}<br>p &amp; 0 &amp;\ldots&amp; 0 &amp; 0 \\<br>0 &amp; p &amp;\ddots&amp; \vdots &amp; \vdots \\<br>\vdots &amp; \ddots &amp; \ddots &amp; 0 &amp; \vdots \\<br>0 &amp; 0 &amp; \ldots &amp; p &amp; 0 \\<br>t_1 &amp; t_2 &amp; \ldots &amp; t_n &amp; \frac{1}{2^{l+1}}<br>\end{bmatrix}<br>$$</p><p><strong>我们需要在格上找到离 $u &#x3D; (u_1,u_2,\ldots,u_n,0)$ 最近的向量，所以在这里，我们可以采用 Babai’s nearest plane algorithm 最终我们可以得到一组向量</strong><br><strong>$v &#x3D; (a \cdot t_1 \mod p,a \cdot t_2 \mod p,\ldots,\frac{a}{2^{l+1}})$ ，从而算出 $a$</strong></p><h3 id="BCTF-2018-guess-number"><a href="#BCTF-2018-guess-number" class="headerlink" title="BCTF 2018 - guess_number"></a>BCTF 2018 - guess_number</h3><p><strong>服务器端代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random, sys<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> FLAG<br><span class="hljs-keyword">import</span> gmpy2<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">msb</span>(<span class="hljs-params">k, x, p</span>):<br>    delta = p &gt;&gt; (k + <span class="hljs-number">1</span>)<br>    ui = random.randint(x - delta, x + delta)<br>    <span class="hljs-keyword">return</span> ui<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    p = gmpy2.next_prime(<span class="hljs-number">2</span>**<span class="hljs-number">160</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        alpha = random.randint(<span class="hljs-number">1</span>, p - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(alpha)</span><br>        t = []<br>        u = []<br>        k = <span class="hljs-number">10</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">22</span>):<br>            t.append(random.randint(<span class="hljs-number">1</span>, p - <span class="hljs-number">1</span>))<br>            u.append(msb(k, alpha * t[i] % p, p))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(t))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(u))<br>        guess = raw_input(<span class="hljs-string">&#x27;Input your guess number: &#x27;</span>)<br>        guess = <span class="hljs-built_in">int</span>(guess)<br>        <span class="hljs-keyword">if</span> guess != alpha:<br>            exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br>    <span class="hljs-built_in">print</span>(FLAG)<br></code></pre></td></tr></table></figure><p><strong>可以看到，程序一共执行 5 轮，在每一轮，随机的</strong> $α$ <strong>和 22 个随机的</strong> $t_i$，<strong>对于每一个</strong> $t_i$，<strong>程序会取</strong> $u_i &#x3D; MSB_{10,p}(a \cdot t_i \mod p)$ ，<strong>随后发送给客户端，我们需要根据提供的</strong> $t_i$ <strong>和</strong> $u_i$ <strong>计算出对应的</strong> $a$，<strong>可以看到，该问题是一个典型的 HNP 问题，可以使用上述方法解决</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ast<br><span class="hljs-keyword">import</span> telnetlib<br><br><span class="hljs-comment">#HOST, PORT = &#x27;localhost&#x27;, 9999</span><br>HOST, PORT = <span class="hljs-string">&#x27;60.205.223.220&#x27;</span>, <span class="hljs-number">9999</span><br><br>s = socket.socket()<br>s.connect((HOST, PORT))<br>f = s.makefile(<span class="hljs-string">&#x27;rw&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_until</span>(<span class="hljs-params">f, delim=<span class="hljs-string">&#x27;\n&#x27;</span></span>):<br>    buf = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> buf.endswith(delim):<br>        buf += f.read(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> buf<br><br>p = <span class="hljs-number">1461501637330902918203684832716283019655932542983</span><br>k = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_hnp</span>(<span class="hljs-params">t, u</span>):<br>    <span class="hljs-comment"># http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf</span><br>    M = Matrix(RationalField(), <span class="hljs-number">23</span>, <span class="hljs-number">23</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">22</span>):<br>        M[i, i] = p<br>        M[<span class="hljs-number">22</span>, i] = t[i]<br><br>    M[<span class="hljs-number">22</span>, <span class="hljs-number">22</span>] = <span class="hljs-number">1</span> / (<span class="hljs-number">2</span> ** (k + <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">babai</span>(<span class="hljs-params">A, w</span>):<br>        A = A.LLL(delta=<span class="hljs-number">0.75</span>)<br>        G = A.gram_schmidt()[<span class="hljs-number">0</span>]<br>        t = w<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(A.nrows())):<br>            c = ((t * G[i]) / (G[i] * G[i])).<span class="hljs-built_in">round</span>()<br>            t -= A[i] * c<br>        <span class="hljs-keyword">return</span> w - t<br><br>    closest = babai(M, vector(u + [<span class="hljs-number">0</span>]))<br>    <span class="hljs-keyword">return</span> (closest[-<span class="hljs-number">1</span>] * (<span class="hljs-number">2</span> ** (k + <span class="hljs-number">1</span>))) % p<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">5</span>):<br>    t = ast.literal_eval(f.readline().strip())<br>    u = ast.literal_eval(f.readline().strip())<br>    alpha = solve_hnp(t, u)<br>    recv_until(f, <span class="hljs-string">&#x27;number: &#x27;</span>)<br>    s.send(<span class="hljs-built_in">str</span>(alpha) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>t = telnetlib.Telnet()<br>t.sock = s<br>t.interact()<br></code></pre></td></tr></table></figure><h2 id="LWE"><a href="#LWE" class="headerlink" title="LWE"></a>LWE</h2><p><strong>Learning with error</strong></p><p><strong>主要关注这样一个式子</strong></p><p>$$<br>A_{m \times n} \cdot x_{n \times 1} + e_{m \times 1} &#x3D; b_{m \times 1} \mod q<br>$$</p><p><strong>其中</strong> $A$ <strong>是一个</strong> $m \times n$ <strong>的矩阵（公开）<del>（好像m会比n大？如果n比m大的话就是一个长的x映射到一个短的b，就能有多个x映射到b导致不能解密了）</del>；</strong> $x$ <strong>是</strong> $n \times 1$ <strong>的向量（明文）；</strong> $e$ <strong>是误差，可以看成是每个元素都很小的</strong> $m \times 1$ <strong>的向量（密钥）；</strong> $b$ <strong>是</strong> $m \times 1$ <strong>向量（密文）。运算都是在mod q下进行的，q是素数</strong></p><p><strong>在知道 $e$ 的情况下，通过上式简单的高斯消元就可以解出密文，即有私钥是容易解的</strong><br><strong>在不知道私钥 $e$ 的情况下，高斯消元法会放大误差 $e$ ，即只知道公钥和密文是难解的</strong></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p><strong>首先现在问题是</strong></p><p>$$<br>A_{m \times n} \cdot x_{n \times 1} + e_{m \times 1} &#x3D; b_{m \times 1} \mod q<br>$$</p><p><strong>知道A、b和q，e很小，求x，因为加了e，所以b大概率不会在格A中，但考虑到e很小，如果找到b在格A中最近的向量b`，则有（其实b`是等于b-e ？）：</strong></p><p>$$<br>A \cdot x &#x3D; b’ \mod q<br>$$</p><p><strong>由于Babai算法不能在模运算之下计算，需要消除 mod q</strong></p><p>$$<br>A \cdot x + kqI_m &#x3D; b’ - e<br>$$</p><p><strong>$I_m$ 在这里表示一个 $m$ 维的单位矩阵， $k$ 是 $m*1$ 的向量，就是把每一条 $a_ix_i + k_iq &#x3D; b_i - e_i$ 写成向量和矩阵的形式，就可以构造格（sage有时运行不了就前后交换或者转置）</strong></p><p>$$<br>\begin{bmatrix}<br>A &amp; qI_m<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \\<br>k<br>\end{bmatrix} &#x3D;<br>b - e<br>$$</p><h3 id="2020祥云杯-easy-matrix"><a href="#2020祥云杯-easy-matrix" class="headerlink" title="2020祥云杯 easy matrix"></a><a href="https://github.com/fghcvjk/2020xiangyuncup/tree/master/crypto/easy%20matrix">2020祥云杯 easy matrix</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_offset</span>(<span class="hljs-params">size</span>):<br>    x = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">4.7873</span>, size)<br>    <span class="hljs-keyword">return</span> np.rint(x)<br><br>secret = np.array(<span class="hljs-built_in">list</span>(flag))<br><br>column = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(secret))<br>row = <span class="hljs-number">128</span><br>prime = <span class="hljs-number">2129</span><br><br>matrix = np.random.randint(<span class="hljs-number">512</span>, size=(row, column))<br>product = matrix.dot(secret) % prime<br>offset = random_offset(size=row).astype(np.int64)<br>result = (product + offset) % prime<br><br>np.save(<span class="hljs-string">&quot;matrix.npy&quot;</span>, matrix)<br>np.save(<span class="hljs-string">&quot;result.npy&quot;</span>, result)<br></code></pre></td></tr></table></figure><p><strong>题目就是个LWE的加密，matrix是A、secret是x、offset 是e、result是b、prime是q</strong></p><p><strong>按照上面的思路可以写出Sage脚本如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env sage</span><br><span class="hljs-keyword">from</span> sage.modules.free_module_integer <span class="hljs-keyword">import</span> IntegerLattice<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Babai</span>(<span class="hljs-params">B, t</span>):<br>    <span class="hljs-comment"># not square when using .LLL(), so use IntegerLattice ...</span><br>    B = IntegerLattice(B, lll_reduce=<span class="hljs-literal">True</span>).reduced_basis<br>    G = B.gram_schmidt()[<span class="hljs-number">0</span>]<br>    b = t<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(B.ncols())):<br>        b -=  B[i] * ((b * G[i]) / (G[i] * G[i])).<span class="hljs-built_in">round</span>()<br>    <span class="hljs-keyword">return</span> t - b<br><br>mx = <span class="hljs-built_in">list</span>(np.load(<span class="hljs-string">&#x27;./matrix.npy&#x27;</span>))<br>rt = <span class="hljs-built_in">list</span>(np.load(<span class="hljs-string">&#x27;./result.npy&#x27;</span>))<br><br>A = matrix(ZZ, mx)<br>b = vector(ZZ, rt)<br>p = <span class="hljs-number">2129</span><br>r = A.nrows()<br>c = A.ncols()<br><br>pIr = p*identity_matrix(r)<br><span class="hljs-comment">#M = block_matrix([[A.transpose()], [pIr]])  # [x, k]*[[A.t], [pIr]] = (b-e).t  (but not work ...</span><br>M = block_matrix([[pIr], [A.transpose()]])  <span class="hljs-comment"># [k, x]*[[pIr], [A.t]] = (b-e).t   (this works ...</span><br>br = Babai(M, b)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;e = %s&#x27;</span> % (b-br))<br>R = IntegerModRing(p)<br>Ar = matrix(R, mx)<br>secret = Ar.solve_right(br)<br><br>m = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> secret)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;m = %s&#x27;</span> % m)<br></code></pre></td></tr></table></figure><hr><h2 id="总结-（2020-Aero-CTF-Magic-ll）"><a href="#总结-（2020-Aero-CTF-Magic-ll）" class="headerlink" title="总结 （2020 Aero CTF Magic ll）"></a>总结 （2020 Aero CTF Magic ll）</h2><p><strong><a href="https://hackmd.io/@hakatashi/B1OM7HFVI#challenge-details">WP</a></strong><br><strong>也是 LWE 问题，但是找不到题目源代码，WP里面对于题目只有关键代码的截取，在这里分析一下WP对于Babai算法的实现（加了亿点GPT的注释）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.modules.free_module_integer <span class="hljs-keyword">import</span> IntegerLattice  <br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint  <br><span class="hljs-keyword">import</span> sys <br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> starmap <br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul  <br><br><span class="hljs-comment"># Babai&#x27;s Nearest Plane algorithm</span><br><span class="hljs-comment"># from: http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Babai_closest_vector</span>(<span class="hljs-params">M, G, target</span>):  <span class="hljs-comment"># 定义Babai的最近平面算法</span><br>  small = target  <span class="hljs-comment"># 初始化small为目标向量</span><br>  <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>):  <span class="hljs-comment"># 进行一次循环</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(M.nrows())):  <span class="hljs-comment"># 从后向前遍历M的每一行</span><br>      c = ((small * G[i]) / (G[i] * G[i])).<span class="hljs-built_in">round</span>()  <span class="hljs-comment"># 计算c，它是small和G[i]的点积除以G[i]的长度的平方，然后四舍五入</span><br>      small -= M[i] * c  <span class="hljs-comment"># 更新small，它是small减去M[i]和c的乘积</span><br>  <span class="hljs-keyword">return</span> target - small  <span class="hljs-comment"># 返回目标向量减去small，这就是最近的向量</span><br><br>m = <span class="hljs-number">100</span>  <br>n = <span class="hljs-number">12</span> <br>q = <span class="hljs-number">1046961993706256953070441</span>  <br><br><br>A_values = [[<span class="hljs-number">432963764937</span>, <span class="hljs-number">1734018663110</span>, <span class="hljs-number">341889949567</span>, <span class="hljs-number">1898982667391</span>, <span class="hljs-number">2077151719276</span>, <span class="hljs-number">1407002783602</span>, <span class="hljs-number">1284167537027</span>, <span class="hljs-number">1834426568578</span>, <span class="hljs-number">285492081118</span>, <span class="hljs-number">2058066808411</span>, <span class="hljs-number">682725745551</span>, <span class="hljs-number">212794466530</span>], ...]<br>b_values = [<span class="hljs-number">675829748828112222653599</span>, <span class="hljs-number">19282755083699178123269</span>, <span class="hljs-number">678436649010458903205058</span>, ...]<br><br>A = matrix(ZZ, m + n, m)  <span class="hljs-comment"># 创建一个(m+n) x m的整数矩阵A</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):  <span class="hljs-comment"># 对于每一个i从0到m-1</span><br>  A[i, i] = q  <span class="hljs-comment"># 设置A的对角线元素为q</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):  <span class="hljs-comment"># 对于每一个x从0到m-1</span><br>  <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># 对于每一个y从0到n-1</span><br>    A[m + y, x] = A_values[x][y]  <span class="hljs-comment"># 设置A的元素</span><br>lattice = IntegerLattice(A, lll_reduce=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 创建一个整数格，并进行LLL减少</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LLL done&quot;</span>)  <span class="hljs-comment"># 打印&quot;LLL done&quot;表示LLL减少已经完成</span><br>gram = lattice.reduced_basis.gram_schmidt()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 计算格的Gram-Schmidt正交化</span><br>target = vector(ZZ, b_values)  <span class="hljs-comment"># 创建一个目标向量，它是b_values的整数向量</span><br>res = Babai_closest_vector(lattice.reduced_basis, gram, target)  <span class="hljs-comment"># 使用Babai的最近平面算法找到最近的向量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Closest Vector: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res))  <span class="hljs-comment"># 打印最近的向量</span><br><br>R = IntegerModRing(q)  <span class="hljs-comment"># 创建一个模q的整数环</span><br>M = Matrix(R, A_values)  <span class="hljs-comment"># 创建一个在模q的整数环上的矩阵，它是A_values</span><br>ingredients = M.solve_right(res)  <span class="hljs-comment"># 解线性方程Mx=res</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ingredients: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ingredients))  <span class="hljs-comment"># 打印解</span><br><br><span class="hljs-keyword">for</span> row, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(A_values, b_values):  <span class="hljs-comment"># 对于A_values和b_values中的每一对元素</span><br>  effect = <span class="hljs-built_in">sum</span>(starmap(mul, <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, ingredients), row))) % q  <span class="hljs-comment"># 计算乘积的和，然后模q</span><br>  <span class="hljs-keyword">assert</span>(<span class="hljs-built_in">abs</span>(b - effect) &lt; <span class="hljs-number">2</span> ** <span class="hljs-number">37</span>)  <span class="hljs-comment"># 检查这个值是否接近b</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)  <br></code></pre></td></tr></table></figure><p><strong>最前面两个算法脚本里对于Babai的代码实现大体都是相同的（HNP那里因为求解的问题不一样，返回值不一样），在Babai()函数里面实现格基规约和正交化，然后寻找最接近向量，这个脚本和前面的不同点也就是传入Babai()函数前已经完成了格基规约和正交化，具体细节看看GPT给的注释也可以明白</strong></p><p><strong>总的来说，Babai算法用来解决维度较小的CVP问题，但是在使用这个算法之前要先使得格基正交化或者准正交化（人话：LLL之后计算格的Gram-Schmidt正交化）</strong></p><p><strong>(这里对于 HNP 和 LWE 都只是简单的介绍，后面有时间还会再写，不过题目脚本都是参考的大佬博客，感觉自己上还是不会写，<del>写完博客就刷点题</del>)</strong></p><p><strong>参考：</strong><br><strong><a href="https://blog.csdn.net/u010536377/article/details/42142075">[密码学]格密码学（3）-Babai算法以及GGH公钥密码体制介绍</a></strong><br><strong><a href="https://ctf-wiki.org/crypto/asymmetric/lattice/cvp/#algorithms">CTF Wiki</a></strong><br><strong><a href="http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf">Playing “Hide-and-Seek” in Finite Fields: Hidden Number Problem and Its Applications</a></strong><br><strong><a href="https://tover.xyz/p/lattices-LWE/">用格解LWE——笔记</a></strong><br><strong><a href="https://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/">格密码</a></strong><br><strong><a href="https://hackmd.io/@hakatashi/B1OM7HFVI#challenge-details">Aero CTF 2020 - Magic II (Crypto, 496pts)</a></strong><br><strong><a href="https://cims.nyu.edu/~regev/teaching/lattices_fall_2004/ln/cvp.pdf">Lecture 3 - CVP algorithm</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>格密码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格密码学习 LLL算法</title>
    <link href="/2024/03/26/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0-LLL%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/26/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0-LLL%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Lattice-Learning"><a href="#Lattice-Learning" class="headerlink" title="Lattice Learning"></a>Lattice Learning</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>格是几何空间中按照一定规则排列的无穷点的集合</strong></p><p><strong>定义：设 $b_1,b_2,…,b_m$ 是 $m$ 个线性无关的 $n$ 维向量（$n \geq m$），我们取 $c_i \in \mathbb{Z}$，则称以 $c_i$ 为组合系数的 $b_i$ 的线性组合所构成的集合称为 $n$ 维格，即：</strong></p><p>$$<br>A &#x3D; L(b_1, b_2, \ldots, b_m) &#x3D; {y | y &#x3D; \sum c_i b_i, c_i \in \mathbb{Z}}<br>$$</p><p><strong>其中 $B &#x3D; (b_1, b_2, \ldots, b_m) \in \mathbb{Z}^{n \times m}$ 称为格 $A$ 的一个基，$m$ 称为格 $A$ 的秩，$n$ 称为格 $A$ 的维数。特别的当 $n&#x3D;m$ 时，称 $A$ 为 $n$ 维满秩格</strong></p><p><strong>格 $A$ 的行列式可表示为 $\det(A)$，它是 $n$ 维空间中由格 $A$ 的基向量所生成的平行多面体 $P$ 的体积</strong></p><p><strong>对于 $n$ 维满秩格，有 $\det(A) &#x3D; \sqrt{\det(B^T B)}$ ，我们一般研究的都是满秩格</strong></p><h2 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h2><p><strong>主要有两个类，SVP及CVP</strong></p><p><strong>SVP：寻找格L中最短的非零向量，即找到 v<sup>*</sup>∈L,对 ∀v∈L ，都有 ||v<sup>*</sup>|| &lt;&#x3D; ||v||</strong></p><p><strong>CVP：对于一个非格L的向量Ω,在格中找向量v使得||Ω-v||最小</strong></p><p><strong>还有一系列的基于这两个问题的近似问题，其中SVP及CVP问题被证明是NP-hard问题</strong></p><h2 id="格攻击理论"><a href="#格攻击理论" class="headerlink" title="格攻击理论"></a>格攻击理论</h2><p><strong>（这篇文章主要讲的是LLL算法，主要用来解决SVP问题）</strong></p><p><strong>这里的格攻击其实是一个启发式算法，所谓启发式可以大概理解为，你不能证明它是对的，但实际用起来有很好的效果的一些算法</strong></p><p><strong>其中用到的最重要的一个东西是高斯启发式</strong></p><p><img src="/img/bg/lattice2.jpg"></p><p><strong>先介绍几个工具再用这个式子</strong></p><p><strong>基本域：设 B &#x3D; [b<sub>1</sub>，b<sub>2</sub>,…,b<sub>n-1</sub>] 为一组格基，则这组格基的基本域为</strong></p><p><strong><center>F(b<sub>1</sub>，b<sub>2</sub> ,…, b<sub>n-1</sub>) &#x3D; {t<sub>0</sub>b<sub>0</sub> + … + t<sub>n-1</sub>b<sub>n-1</sub> (0&lt;&#x3D;t<sub>i</sub>&lt;1)}</center></strong></p><p><strong>从图像上看，F 就是这个格里原点最近的其中“一格”，看图，比如二维中的栗子</strong></p><p><img src="/img/bg/lattice3.jpg"></p><p><strong>后面会用到的是基本域的容积，从结果上看，基本域的容积等于格基的行列式（的绝对值），证明略，可以参考[HPS14]</strong></p><p><strong><center>Vol(F) &#x3D; det(L(B))</center></strong></p><p><strong>超球体：其实就是高维空间的球体，同样也需要用到它的容积</strong></p><p><strong>设 B<sub>R</sub>(a) 为一个以点 a 为圆心，半径为 R 的 n 维球体，那么 B<sub>R</sub>(a) 的容积（或者说体积）为</strong></p><p><img src="/img/bg/lattice4.jpg"></p><p><strong>这个式子有点复杂，所以一般除了维度较小的情况，不大会用这个式子，而是用它的估算值，在维度 n 足够大时，可以作以下估算</strong></p><p><img src="/img/bg/lattice5.jpg"></p><p><strong>高斯说，一个以零点为圆心的超球体中格点的数量可以用格的基本域的容积估算</strong></p><p><img src="/img/bg/lattice6.jpg"></p><p><strong>把上面式子中向量数量定为1，即可估算只含一个格点的超球半径，即上面高斯启发式的图中的σ(L)</strong><br><strong>PS：“只含一个格点”其实只是一个估算，实际上因为||v|| &#x3D; ||-v||，所以随便圈一个球里面应该都有偶数个非零格点</strong></p><p><img src="/img/bg/lattice7.jpg"></p><p><strong>逆向思维一下就是说，长度短于σ(L)的格向量（约）只有一个，所以如果我们通过计算得到一个向量长度（约）小于σ(L)，那么大概率可以确定它是一个最短向量，在维度不高的情况下，可以用LLL把他求出来</strong></p><p><strong>最后需要注意的是，这个方法只是一个启发式方法，在实际操作中能不能求到这个最短向量还需要考虑几个东西</strong></p><ul><li><strong>格的维度不能太高，不然LLL的准确度不能保证，而且LLL会用很长时间，然后是上面的容积估算也不能保证</strong></li><li><strong>格需要“足够随机”，上面图也说了，这只是一个概率估算，所以需要足够随机，后面会说到一些不太随机的格基，比如背包的格和NTRU的格，在实际操作中，这两个问题的格基维度其实都不能太大</strong></li></ul><h2 id="格攻击应用"><a href="#格攻击应用" class="headerlink" title="格攻击应用"></a>格攻击应用</h2><p><strong>先用一个很简单的问题引入</strong></p><p><strong>加密开始，Alice先选择一个大的正整数 q（不一定是素数）为一个公共参数作为公钥，并选择两个秘密的正整数 f,g 作为私钥，其中 f &lt; <sup>q</sup>&frasl;<sub>2</sub><sup>1&#x2F;2</sup>,<sup>q</sup>&frasl;<sub>4</sub><sup>1&#x2F;2</sup> &lt; g &lt; <sup>q</sup>&frasl;<sub>2</sub><sup>1&#x2F;2</sup> 且 gcd(f,q)&#x3D;1。</strong></p><p><strong>然后，Alice可以计算 h ≡ f<sup>-1</sup>g (mod q) ，我们可以注意到 f , g 都小于 q<sup>1&#x2F;2</sup> ,也就是说 f , g 的数量级是O(q<sup>1&#x2F;2</sup>)的级别。而 h 的范围则是O(q)，在 q 很大的时候（比如 q &gt; 2256）时，h 可以说是远大于 f , g 的。这个 h 也将作为公钥。随后，Alice将公钥 q , h 公开。</strong></p><p><strong>消息发送方Bob，对信息加密的时候，也需要用到2个参数：明文 m 和一个随机数 r ，其中 m &lt; <sup>q</sup>&frasl;<sub>4</sub><sup>1&#x2F;2</sup> , r &lt; <sup>q</sup>&frasl;<sub>2</sub><sup>1&#x2F;2</sup> ，然后他就可以计算密文 c ≡ rh + m (mod q)</strong></p><p><strong>而收到密文后，Alice的解密过程如下：首先，他计算 a ≡ fc (mod q) 和 b ≡ ad (mod g)，其中 d 是 f 在模 g 意义下的逆元。而神奇的是，对于 a &#x3D; fc &#x3D; frh + fm &#x3D; frf<sup>-1</sup>g + fm &#x3D; rg + fm。然后，我们可以得到 b &#x3D; ad &#x3D; drg + dfm ≡ dfm (mod g)。又因为 df ≡ 1 (mod g)，所以我们最后算出来的 b &#x3D; m 就成立了。</strong></p><p><strong>我们从攻击者角度来尝试破解密文</strong></p><p><strong>有条件： f，g &lt; <sup>q</sup>&frasl;<sub>2</sub><sup>1&#x2F;2</sup>，gcd（f，qg）&#x3D; 1 和 h ≡ f<sup>-1</sup>g (mod q)，已知 (q,h)，求 (f,g)</strong></p><p><strong>直接使用同余式构造格基好像有点困难，因为LLL规约使用的格基里面的元素都需要在 Z 上，所以不妨先把他展开，展开前先整理一下，因为现在我只知道 f 是小未知数，不能保证 f<sup>-1</sup> 也是小未知数，所以先消去逆，两边乘一下 f 即可，得到</strong></p><p><strong><center>fh ≡ g (mod q)</center></strong></p><p><strong>然后可以插入一个未知的 k，把同余式展开，习惯上我会把一个小的未知数放一边（如这里的 g ），方便后续构造格基</strong></p><p><strong><center>hf - qk &#x3D; g</center></strong></p><p><strong>构造格基的方法其实就是构造出线性方程组，如果你是像我这样把小未知数放等号右边的话，那么一般是等号左边有多少未知数就需要构造多少组方程。现在等号左边有 (f , k) 两个未知数，所以还需要多一个方程，在没有更多的条件可用的情况下，可以插入一些恒等式，比如 f &#x3D; f ，然后就可以得到</strong></p><p><strong><center>1 · f - 0 · k &#x3D; f</strong><br><strong>h · f - q · k &#x3D; g</center></strong></p><p><strong>把这组线性方程用矩阵-向量的形式表达出来</strong></p><p>$$<br>\begin{pmatrix}<br>f &amp; -k<br>\end{pmatrix}<br>\begin{bmatrix}<br>1 &amp; h \\<br>0 &amp; q<br>\end{bmatrix}&#x3D;<br>\begin{pmatrix}<br>f &amp; g<br>\end{pmatrix}<br>$$</p><p><strong>把上面的方程对应简写为 vB &#x3D; w</strong></p><p><strong>首先很明显，v 中的 f 和 -k 都是整数，根据格的定义，w 是格基 B 中向量的整数线性组合，所以 w 是以 B 为格基的格 L(B) 中的一个格点</strong></p><p><strong>接下来我会期望 w 是 L(B) 的最短向量，这就要用到上面说的估算方法，首先计算一下 w 的长度 ||w|| 和高斯的期望值 σ(L(B))</strong></p><p><strong><center>||w|| &#x3D; (f<sup>2</sup> + g<sup>2</sup>)<sup>1&#x2F;2</sup> &lt; q<sup>1&#x2F;2</sup></strong><br><strong>σ(L(B)) ≈ det(L(B))<sup>1&#x2F;2</sup> &#x3D; q<sup>1&#x2F;2</sup></center></strong></p><p><strong>于是就有 ||w|| &lt;&#x3D; σ(L(B))，根据前面分析，w 大概率为 L(B) 的最短向量，LLL即可解</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/img/bg/lattice1.jpg"></p><p><strong>很明显，在这里的一组基是 &lt; i<sub>1</sub> ，i<sub>2</sub> &gt; ，最短向量是 i<sub>2</sub> ，Ω 的最近向量是 v</strong></p><p><strong>来道简单的题目试一下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><br>m = bytes_to_long(flag)<br>bits = m.bit_length()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;bits = &#125;</span>&#x27;</span>)<br><br>p = getPrime(bits)<br>q = getPrime(bits)<br><br>P = getPrime(bits * <span class="hljs-number">2</span>)<br>G = (m + p * P) % q<br>K = (G - m - p * P) // q<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;P = &#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;G = &#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;K = &#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># bits = 335</span><br><span class="hljs-comment"># P = 3394270545570971690577979575406583864946510681585266672410991229280804004453396280771163168409087272659457277569002891388790000326756442550228492597287297623683499025514027403588117117896119108715160651</span><br><span class="hljs-comment"># G = 60963100282597524831359979973410096860944371822738298396641072874281201661416406035690627807291616264</span><br><span class="hljs-comment"># K = -1726680592929123430695060700728307617796590011101261305934490117807063551645884305573930787050237014785811531685576831658332832043539071312665804505405023375751155325879443489750916518257143502275697762</span><br></code></pre></td></tr></table></figure><p><strong>分析G,K关系得到 G - m - pP &#x3D; qK</strong></p><p><strong>构造格</strong></p><p>$$<br>\begin{pmatrix}<br>q &amp; p<br>\end{pmatrix}<br>\begin{bmatrix}<br>K &amp; 0 \\<br>P &amp; 1<br>\end{bmatrix}&#x3D;<br>\begin{pmatrix}<br>G-m &amp; p<br>\end{pmatrix}<br>$$</p><p><strong>如果(G - m, p)刚好是这个格的最短向量，我们就能通过LLL算法在已知K,P下求出(G - m, p)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br>P = <span class="hljs-number">3394270545570971690577979575406583864946510681585266672410991229280804004453396280771163168409087272659457277569002891388790000326756442550228492597287297623683499025514027403588117117896119108715160651</span><br>G = <span class="hljs-number">60963100282597524831359979973410096860944371822738298396641072874281201661416406035690627807291616264</span><br>K = -<span class="hljs-number">1726680592929123430695060700728307617796590011101261305934490117807063551645884305573930787050237014785811531685576831658332832043539071312665804505405023375751155325879443489750916518257143502275697762</span><br><br>B = Matrix(ZZ,[[K,<span class="hljs-number">0</span>],[P,<span class="hljs-number">1</span>]])<br><br>B = B.LLL()<br><br>m = G - B[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>背包问题基于数学的子集和问题，是 Merkle 和 Hellman 在上世纪 70 年代做出的</strong></p><p><strong>子集和问题：给定一个正整数集合 M &#x3D; （m<sub>1</sub>，m<sub>2</sub>，… ，m<sub>n</sub>），及整数S，求出（x<sub>1</sub>，x<sub>2</sub>，… ，x<sub>n</sub>），使得 ∑m<sub>i</sub>x<sub>i</sub> &#x3D; S</strong></p><p><strong>举个例子：M &#x3D;（2,3,4,9,14,23），S &#x3D; （3,4,14），其和等于 21。显然，子集和问题可能有唯一解，可能无解，可能多解。我们只考虑至少有一个解的情况</strong></p><p><strong>接下来，我们尝试利用子集和问题的困难性，构建一个公钥密码体系，取</strong></p><p><strong><center>M &#x3D;（m<sub>1</sub>，m<sub>2</sub>，… ，m<sub>n</sub>）</center></strong></p><p><strong>为公钥，Bob 想发送一条消息，于是将其编码为二进制向量 x &#x3D;（x<sub>1</sub>，x<sub>2</sub>，… ，x<sub>n</sub>），Bob计算</strong></p><p><strong><center>S &#x3D; ∑m<sub>i</sub>x<sub>i</sub></center></strong></p><p><strong>然后将 S 发送给 Alice，而 Alice 想要解密，必须找到一个合法的 x ，这等价于找到 M 的子集，使之和等于 S</strong></p><p><strong>如果 Alice 能快速找到合法的 x 而敌手 Eve 找不到，那么这个密码体系就是有效的，可惜 Alice 并没有这种手段。这个密码体系中没有引入陷门信息，所以 Alice 解密与 Eve 解密的难度是一样的</strong></p><p><strong>来考虑如何较快地解决子集和问题（尽管仍然是指数级的），这也是敌手能用上的最好的手段之一。Eve 把 M 划分成两半，然后对于左边那一半，枚举其所有子集 I ，记录子集和 A<sub>I</sub> ；对于右边，也同样操作，得到 B<sub>J</sub> ，如果存在一对 A<sub>I<sub>0</sub></sub> B<sub>J<sub>0</sub></sub>使得它们的和等于 S ，那我们就解决了问题。</strong></p><p><strong>之前提到过，Alice 必须有陷门信息，才能快速完成解密，这个公钥密码方案才能有效。接下来我们讨论一种非常简单的子集和问题——超级递增序列上的子集和：</strong></p><p><strong>超级递增序列：称一个序列 r &#x3D; （r<sub>1</sub>，r<sub>2</sub>，… ，r<sub>n</sub>）是超级递增序列，当且仅当满足</strong></p><p><strong><center>∀ 1 &lt;&#x3D; i &lt;&#x3D; n-1 ，r<sub>i+1</sub> &#x3D;&gt; 2r<sub>i</sub></center></strong></p><p><strong>也就是说，超级递增序列是指“后一个数比前一个数至少大一倍”的序列。显然就有性质</strong></p><p><strong><center>r<sub>k</sub> &gt; ∑<sup>k-1</sup>r<sub>i</sub></center></strong></p><p><strong>举个例子：有 $M &#x3D; (3,11,24,50,115)$ 是超级递增序列，$S &#x3D; 142$，那么首先检查 $142&gt;155$，故输出 $115$，$S$ 改为 $142-115&#x3D;27$。接下来 $50$ 被忽略，输出 $24$，$S$ 变为 $3$ 。共输出 $\text{115、24、3}$ ，生成 $x &#x3D; (1,0,1,0,1)$ ，完成解密。</strong></p><p><strong>采用超级递增序列，Alice 是可以快速解密了；但敌手也可以。仍然没有起到添加陷门信息的作用。Merkle 和 Hellman 提出了下面的方案：</strong></p><ol><li><p><strong>Alice 生成一个超级递增序列 $r$，还选择两个保密的整数 $A,B$ 满足</strong></p><p> $$<br> B &gt; 2r_n，gcd(A,B) &#x3D; 1<br> $$</p></li><li><p><strong>Alice 计算一个公钥序列</strong></p><p> $$<br> M \equiv A \cdot r_i \pmod{B}<br> $$</p><p> <strong>显然它不是超级递增序列。乘以 $A$ 起到了混淆的作用</strong></p></li><li><p><strong>Bob 要加密 $x$ ，他发送</strong></p></li></ol><p>$$<br>S &#x3D; x \cdot M &#x3D; \sum_{i&#x3D;1}^{n} x_iM_i<br>$$</p><ol start="4"><li><p><strong>Alice 要解密 $S$ ，首先计算出</strong></p><p>$$<br>S’ &#x3D; A^{-1}S \pmod{B}<br>$$</p><p><strong>然后 Alice 求子集和问题 $(r,S’)$ 的解，即可解密</strong><br><strong>要说明为什么新问题的解就是原问题的解。我们注意到</strong></p><p>$$<br>S’ \equiv A^{-1} \sum_{i&#x3D;1}^{n} x_iM_i \equiv A^{-1} \sum_{i&#x3D;1}^{n} x_iAr_i \equiv  \sum_{i&#x3D;1}^{n} x_ir_i \pmod{B}<br>$$</p><p><strong>而 $B$ 是一个非常大的数，故 $S$ 就是 $x \cdot r$ 的确切值</strong></p></li></ol><p><strong>这套公钥加密体系，被称为子集和密码系统，或称背包密码。其核心思想是生成一个超级递增序列，然后用模线性运算进行混淆，将混淆之后的序列作为公钥</strong></p><p><strong>接下来，我们看敌手 Eve 如何通过构造格来攻击背包密码。首先，她拿到公钥 $M &#x3D; (m_1,…,m_n)$ ，然后构造下面的格基</strong></p><p>$$<br>\begin{pmatrix}<br>x_0,x_1,\ldots,x_{n-1},-1<br>\end{pmatrix}<br>\begin{bmatrix}<br>2 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; m_1 \\<br>0 &amp; 2 &amp; 0 &amp; \ldots &amp; 0 &amp; m_2 \\<br>0 &amp; 0 &amp; 2 &amp; \ldots &amp; 0 &amp; m_3 \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\<br>0 &amp; 0 &amp; 0 &amp; \ldots &amp; 2 &amp; m_n \\<br>1 &amp; 1 &amp; 1 &amp; \ldots &amp; 1 &amp; S<br>\end{bmatrix} &#x3D;<br>\begin{pmatrix}<br>2x_0-1,2x_1-1,\ldots,2x_{n-1}-1,0<br>\end{pmatrix}<br>$$</p><p><strong>现在我们使用LLL算法来尝试攻击背包密码，考虑下面问题：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">M = [<span class="hljs-number">816358673</span>, <span class="hljs-number">214551389</span>, <span class="hljs-number">683509053</span>, <span class="hljs-number">377954927</span>, <span class="hljs-number">461648693</span>, <span class="hljs-number">819009687</span>, <span class="hljs-number">833612683</span>, <span class="hljs-number">246393449</span>, <span class="hljs-number">258952137</span>, <span class="hljs-number">592274653</span>, <span class="hljs-number">439857687</span>, <span class="hljs-number">164289531</span>, <span class="hljs-number">138621939</span>, <span class="hljs-number">626982035</span>, <span class="hljs-number">733582939</span>, <span class="hljs-number">561376076</span>, <span class="hljs-number">206910526</span>, <span class="hljs-number">470721180</span>, <span class="hljs-number">1105393379</span>, <span class="hljs-number">848577580</span>]<br>msg = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>S = <span class="hljs-number">6545130222</span><br></code></pre></td></tr></table></figure><p><strong>构建出格如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">len</span>(M)<br>L = matrix.zero(n + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> row, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(M):<br>    L[row, row] = <span class="hljs-number">2</span><br>    L[row, -<span class="hljs-number">1</span>] = x<br><br>L[-<span class="hljs-number">1</span>, :] = <span class="hljs-number">1</span><br>L[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>] = S<br></code></pre></td></tr></table></figure><p><strong>运行LLL算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">res = L.LLL()<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[-1  1 -1 -1  1 -1  1 -1 -1  1 -1  1 -1 -1  1 -1  1 -1 -1  1  0]</span><br><span class="hljs-string">[ 2  2  0  2 -2 -2  2 -2  0  0 -4  2  0  0  0  0  0  0  0  0  0]</span><br><span class="hljs-string">[ 0  2  0  0  2 -4  0  2  0  0  4 -2  0  0  0  0  0  0  0  0  0]</span><br><span class="hljs-string">[-1 -1  1  1  1 -3 -1 -1  1 -1  3 -1 -1  1  3  1 -1  3  1 -1  3]</span><br><span class="hljs-string">[ 2  0  0  0  2  2  0 -2  2  0 -4  2  2 -2 -4  2  0  0  0  0  0]</span><br><span class="hljs-string">[-1 -1 -1  1  1  1  1 -1 -1  3 -3  1 -1 -1 -1  1 -1  3 -1 -3  2]</span><br><span class="hljs-string">[-4  2  0 -2  0  0  2  0  2  2  2 -2 -2  0  0 -2  0  0 -2 -2 -1]</span><br><span class="hljs-string">[-1  1  1  1  3 -1 -1 -1  3  1  1 -3 -1  1  1 -3  1 -1  1  1 -1]</span><br><span class="hljs-string">[ 1 -3  1  1 -1 -1  1 -1 -3  1 -1 -1 -5  1  1 -1  1  1  1  1  2]</span><br><span class="hljs-string">[ 3 -3 -1 -1  1  1 -3 -1 -1  5 -1 -1  1  1 -1  1 -1  1  1 -1  0]</span><br><span class="hljs-string">[ 0  2  0  2  4  0 -2  0 -4  0  0  0 -2  0  0 -2  0  0 -2 -2 -1]</span><br><span class="hljs-string">[ 2 -2  0  0  2  0 -2  0  0 -2 -4  4  0  0  0  0  0 -2 -2  0 -2]</span><br><span class="hljs-string">[ 1  1  1  1 -3 -3  3  1  3  1  1  1 -3 -3  1  1 -1  1  1 -1  0]</span><br><span class="hljs-string">[ 1 -1 -1 -1  1 -1 -3 -1 -1  1  1  1  1  3  3 -5  1  1 -1 -1  1]</span><br><span class="hljs-string">[-3  1 -3 -1  3  3  3 -1  1 -1  1 -1  1  1 -1  1 -1  1  1 -1  0]</span><br><span class="hljs-string">[ 0  0  2  0  0  0  0  2 -2 -2  2 -6  0  0  0 -2  0  0 -2 -2 -1]</span><br><span class="hljs-string">[ 0 -2  0 -4  2  0  2  2  0  2 -2  4 -2  0  0  0  0  2  2  0  2]</span><br><span class="hljs-string">[-2 -2 -2 -2  2  0 -2 -2  2  0  0  0  2  0  0 -2 -2  0 -2  4  2]</span><br><span class="hljs-string">[ 2 -2  0 -2 -4  0  2  0  0  0 -2  0 -2  2  0 -2 -4  0  0 -4  3]</span><br><span class="hljs-string">[-2  0  0 -2  0  0  0  0  0 -2 -4  0 -2 -2 -4  2  2  0  0 -2 -1]</span><br><span class="hljs-string">[ 1  1 -1  1  1 -1 -1 -1  1 -3 -1 -3 -3 -1  1  1  1  1 -1  1  3]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>可以发现第一行的相反向量就是解</strong></p><h2 id="拓展维纳攻击"><a href="#拓展维纳攻击" class="headerlink" title="拓展维纳攻击"></a>拓展维纳攻击</h2><p><strong>扩展维纳攻击来自<a href="https://www.sci-hub.ren/https://link.springer.com/chapter/10.1007/3-540-46701-7_14">《Extending Wiener’s Attack in the Presence of Many Decrypting Exponents》</a>，相关题目在 CTF 中已经出现了，例如 2020 羊城杯的 Simple，但都是一些模板题，在这里记录一下拓展维纳攻击的原理</strong></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="维纳的方法"><a href="#维纳的方法" class="headerlink" title="维纳的方法"></a>维纳的方法</h4><p><strong>维纳<code>Wiener</code>提出了一种关于私钥过小时对 $N$ 进行分解的一种方式。并给出了证明当</strong><br>$$<br>d &lt; \frac{1}{3}N^\frac{1}{4}<br>$$<br><strong>满足时 (还应满足 $q&lt;p&lt;2q$ ，因这里及后文主要是对私钥进行探讨，故忽略这类条件) 一定能够分解$N$</strong></p><p><strong>以下为原论文中对于<code>Wiener&#39;s Approach</code>的部分描述，部分内容有删减，其实这里也就是维纳攻击的证明，所以要想更详细了解请再看维纳攻击的原理，这里我们主要后面要用到这里的<code>式1</code>，方法如下</strong></p><p><strong>已知</strong><br>$$<br>e \cdot d - k \cdot \lambda(N) &#x3D; 1<br>$$</p><p><strong>这里 $\lambda(N) &#x3D; \text{lcm}(p-1, q-1) &#x3D; \frac{\varphi(N)}{g} $, 令 $s&#x3D; 1 - p - q$ ，则有</strong></p><p>$$<br>\begin{align*}<br>edg - kN &#x3D; g + ks &amp; (1)<br>\end{align*}<br>$$</p><p><strong>将两边同时除以 $dgN$ 则有</strong></p><p>$$<br>\frac{e}{N} - \frac{k}{dg} &#x3D; \frac{g + ks}{dgN} &#x3D; (\frac{k}{dg})(\frac{s}{N}) + \frac{1}{dN}<br>$$</p><p><strong>我们知道在这里有 $e \approx N$，$s \approx N^{1&#x2F;2}$，所以有 $\frac{k}{dg} \approx 1$，则我们可以知道等式右边约等于 $N^{-1&#x2F;2}$，我们都知道当</strong></p><p>$$<br>| x - \frac{a}{b} | &lt; \frac{1}{2b^2}<br>$$</p><p><strong>时则 $\frac{a}{b}$ 是一个连分数近似（连分数定理），即能通过连分数展开覆盖</strong></p><p><strong>所以当</strong></p><p>$$<br>d &lt; \frac{\sqrt{2}}{2g}N^{\frac{1}{4}}<br>$$</p><p><strong>时有 $\frac{k}{dg}$ 是 $\frac{e}{N}$ 的连分数近似，即能通过连分数展开覆盖</strong></p><h4 id="Guo的方法"><a href="#Guo的方法" class="headerlink" title="Guo的方法"></a>Guo的方法</h4><p><strong>郭针对不止一个 $e$ 的情况进行研究，但是郭只研究了两个以及三个 $e$ 的情况</strong></p><p><strong>对于两个 $e$ 的情况，我们可以考虑</strong></p><p>$$<br>\begin{align*}<br>e_1d_1g - k_1(p-1)(q-1) &#x3D; g \\<br>e_2d_2g - k_2(p-1)(q-1) &#x3D; g<br>\end{align*}<br>$$</p><p><strong>简单化简得到以下式子</strong></p><p>$$<br>\begin{align*}<br>k_2d_1e_1 − k_1d_2e_2 &#x3D; k_2−k_1 &amp; (2)<br>\end{align*}<br>$$</p><p><strong>两边同时除以 $k_2d_1e_2$</strong></p><p>$$<br>\frac{e_1}{e_2} - \frac{k_1d_2}{k_2d_1} &#x3D; \frac{k_2 - k_1}{k_2d_1e_2}<br>$$</p><p><strong>设 $d_i &lt; N^a$，则等式右边约等于 $N^{-1+a}$</strong><br><strong>则当</strong></p><p>$$<br>2(k_2d_1)^2 &lt; N^{1+a}<br>$$</p><p><strong>时 $\frac{k_1d_2}{k_2d_1}$ 是 $\frac{e_1}{e_2}$ 的连分数近似，当 $k_2$ 和 $d_1$ 最多为 $N^a$ ，而且 $g$ 很小时，得到</strong></p><p>$$<br>\alpha &lt; \frac{1}{3} - \epsilon （\epsilon &gt; 0）<br>$$</p><p><strong>然而即使我们得到了 $\frac{k_1d_2}{k_2d_1}$ ，还是无法分解 $N$ ，原文后面还讨论了 Guo 的提议，尝试对 $k_1d_2$ 进行分解，这里不再讲解</strong></p><h4 id="拓展维纳攻击-1"><a href="#拓展维纳攻击-1" class="headerlink" title="拓展维纳攻击"></a>拓展维纳攻击</h4><p><strong>为了将分析扩展到 $n$ 个加密指数 $e_i$（解密指数 $d_i$ 很小），我们同时使用维纳和 Guo 的方法，我们将关系</strong></p><p>$$<br>d_ige_i − k_iN &#x3D; g + k_is<br>$$</p><p><strong>记为维纳等式 $W_i$ ，同样我们可以得到关系</strong></p><p>$$<br>k_id_je_j − k_jd_ie_i &#x3D; k_i − k_j<br>$$</p><p><strong>记为 Guo 等式</strong> $G_{i,j}$</p><p><strong>我们假设 $d_i$ 和 $k_i$ 都小于 $N^{a_n}$ ，且 $g$ 很小，$s \approx N^{1&#x2F;2}$ ，可以注意到 $W_i$ 和 $G_i$ 的右侧非常小，实际上分别最多为 $N^{1&#x2F;2+a}$ 和 $N^a$</strong></p><p><strong>原文中这里是定义了两个关系式以及指出了他们的大小范围，这个范围很重要也容容易分析处理，之后我们所做的其实就是使用这两个式子的不同复合关系去构造一个格，然后通过求其基向量得到 $\frac{d_1g}{k_1}$，从而可以算得 $\varphi(N)$ 并可以进一步的对 $N$ 进行分解</strong></p><p><strong>其实到这里原理分析已经结束，关于格的构造其实也并不复杂，但是核心是这里的复合关系的选取，以及对于最后 $\alpha$ 大小的分析。</strong></p><h3 id="两个小解密指数的情况"><a href="#两个小解密指数的情况" class="headerlink" title="两个小解密指数的情况"></a>两个小解密指数的情况</h3><p><strong>我们选取关系</strong> $W_1 , G_{1,2} , W_1W_2$<strong>，这样便有</strong></p><p>$$<br>d_1ge_1 − k_1N &#x3D; g + k_1s \\<br>k_1d_2e_2 − k_2d_1e_1 &#x3D; k_1 − k_2 \\<br>d_1d_2g^2e_1e_2 − d_1gk_2e_1N − d_2gk_1e_2N + k_1k_2N^2 &#x3D; (g+k_1s)(g+k_2s)<br>$$</p><p><strong>我们对第一个关系式乘上 $k_2$，这样左边便全是由 $d_1d_2g^2,d_1gk_2,d_2gk_1$ 和 $k_1k_2$ 构成，这样我们便可以用已知内容构造格将上述式子转化为矩阵运算</strong></p><p>$$<br>\begin{pmatrix}<br>k_1k_2 &amp; d_1gk_2 &amp; d_2gk_1 &amp; d_1d_2g^2<br>\end{pmatrix}<br>\begin{bmatrix}<br>1 &amp; -N &amp; 0 &amp; N^2 \\<br>&amp; e_1 &amp; -e_1 &amp; -e_1N \\<br>&amp; &amp; e_2 &amp; -e_2N \\<br>&amp; &amp; &amp; e_1e_2<br>\end{bmatrix}&#x3D;<br>\begin{pmatrix}<br>k_1k_2 &amp; k_2(g+k_1s) &amp; g(k_1−k_2) &amp; (g+k_1s)(g+k_2s)<br>\end{pmatrix}<br>$$</p><p><strong>等式右边向量的大小为 $N^{2α_2},N^{1&#x2F;2+2α_2},N^{α_2},N^{1+2α_2}$ , 为了让大小相等，我们可以考虑构造一个 $D$ 矩阵。</strong></p><p>$$<br>D &#x3D;<br>\begin{bmatrix}<br>N &amp; &amp; &amp; \\<br>&amp; N^{1&#x2F;2} &amp; &amp; \\<br>&amp; &amp; N^{1+a_2} &amp; \\<br>&amp; &amp; &amp; 1<br>\end{bmatrix}<br>$$</p><p><strong>最终我们构造的矩阵为</strong></p><p>$$<br>L_2 &#x3D;<br>\begin{bmatrix}<br>1 &amp; -N &amp; 0 &amp; N^2 \\<br>&amp; e_1 &amp; -e_1 &amp; -e_1N \\<br>&amp; &amp; e_2 &amp; -e_2N \\<br>&amp; &amp; &amp; e_1e_2<br>\end{bmatrix} * D<br>$$</p><p><strong>这样向量 $b &#x3D; \begin{pmatrix}k_1k_2 &amp; d_1gk_2 &amp; d_2gk_1 &amp;d_1d_2g^2\end{pmatrix}$ 便有</strong></p><p>$$<br>|| bL_2 || &lt; 2N^{1 + 2\alpha_2}<br>$$</p><p><strong>这也就是为什么前面需要构造 $D$ 矩阵的原因，给定 $D$ 矩阵后，我们可以得到一个上界，这样问题可以转化为类 SVP 问题</strong></p><p><strong>那么这里的 $b$ 向量其实我们使用格基规约算法例如LLL便可以得到基向量 $b$，然后我们求解 $\frac{b_2}{b_1}$ 即得到 $\frac{d_1g}{k_1}$</strong></p><p><strong>之后我们就可以得到</strong></p><p>$$<br>\varphi(N) &#x3D; \frac{edg}{k} - \frac{g}{k} &#x3D; \left\lfloor \frac{edg}{k} \right\rfloor<br>$$</p><p><strong>我们假设这些格中最短向量长度为 $\Delta^{1&#x2F;4-\epsilon}$，其中 $\Delta &#x3D; \det(L_2) &#x3D; N^{13&#x2F;2 + a_2}$，如果这些格是随机的，我们甚至几乎可以肯定没有格点比闵可夫斯基界（Minkowski’s bound）大，所以 $bL_2$ 是最短向量当</strong></p><p>$$<br>N^{1+2a_2} &lt; \frac{1}{c_2}(N^{13&#x2F;2+a_2})^{1&#x2F;4}<br>$$</p><p><strong>对于一些小的 $c_2$，如果有</strong></p><p>$$<br>a_2 &lt; \frac{5}{14} - \epsilon’<br>$$</p><p><strong>则我们可以通过格基规约找到向量b</strong></p><h3 id="三个小解密指数的情况"><a href="#三个小解密指数的情况" class="headerlink" title="三个小解密指数的情况"></a>三个小解密指数的情况</h3><p><strong>对于三个指数的情况我们额外选取</strong>$G_{1,3} , W_1G_{2,3} , W_2G_{1,3}$</p><p><strong>这样我们的向量 $b$ 为</strong></p><p>$$<br>B &#x3D; \begin{pmatrix}<br>k_1k_2k_3 &amp; d_1gk_2k_3 &amp; k_1d_2gk_3 &amp; d_1d_2g^2k_3 &amp; k_1k_2d_3g &amp; k_1d_3g &amp; k_2d_3g &amp; d_1d_2d_3g^3<br>\end{pmatrix}<br>$$</p><p><strong>然后我们便可以构造格</strong></p><p>$$<br>L &#x3D;<br>\begin{bmatrix}<br>1 &amp; -N &amp; 0 &amp; N^2 &amp; 0 &amp; 0 &amp; 0 &amp; -N^3 \\<br>0 &amp; e_1 &amp; −e_1 &amp; −Ne_1 &amp; −e_1 &amp; 0 &amp; Ne_1 &amp; N^2e_1 \\<br>0 &amp; 0 &amp; e_2 &amp; −Ne_2 &amp; 0 &amp; Ne_2 &amp; 0 &amp; N^2e_2 \\<br>0 &amp; 0 &amp; 0 &amp; e_1e_2 &amp; 0 &amp; −e_1e_2 &amp; −e_1e_2 &amp; −Ne_1e_2 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; e_3 &amp; −Ne_3 &amp; −Ne_3 &amp; N^2e_3 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_3 &amp; 0 &amp; −Ne_1e_3 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_2e_3 &amp; −Ne_2e_3 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_2e_3<br>\end{bmatrix}<br>$$</p><p><strong>其中</strong></p><p>$$<br>D &#x3D; \text{diag}\left(N^{\frac{3}{2}},N, N^{a + \frac{3}{2}},\sqrt{N}, N^{a + \frac{3}{2}}, N^{a + 1}, N^{a + 1}, 1\right)<br>$$</p><p><strong>同样我们可以得到</strong></p><p>$$<br>|| bL_2 || &lt; 2\sqrt{2}N^{\frac{3}{2} + 2\alpha_3}<br>$$</p><p><strong>则当</strong></p><p>$$<br>a_3 &lt; \frac{2}{5} - \epsilon’<br>$$</p><p><strong>时可以通过格基规约求出向量b</strong></p><p><strong>更多解密指数的情况可以看 <a href="(https://www.sci-hub.ren/https://link.springer.com/chapter/10.1007/3-540-46701-7_14)">论文</a> 或者 <a href="https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener/">CTF Wiki</a> (Xenny大佬编写的)了解</strong></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p><strong>n &#x3D; 2 的时候的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">e1 = ...<br>e2 = ...<br>N = ...<br>a = <span class="hljs-number">5</span>/<span class="hljs-number">14</span><br>D = diagonal_matrix(ZZ, [N, <span class="hljs-built_in">int</span>(N^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)), <span class="hljs-built_in">int</span>(N^(<span class="hljs-number">1</span>+a)), <span class="hljs-number">1</span>])<br>M = matrix(ZZ, [[<span class="hljs-number">1</span>, -N, <span class="hljs-number">0</span>, N^<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, e1, -e1, -e1*N], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, e2, -e2*N], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, e1*e2]])*D<br>L = M.LLL()<br>t = vector(ZZ, L[<span class="hljs-number">0</span>])<br>x = t * M^(-<span class="hljs-number">1</span>)<br>phi = <span class="hljs-built_in">int</span>(x[<span class="hljs-number">1</span>]/x[<span class="hljs-number">0</span>]*e1)<br></code></pre></td></tr></table></figure><p><strong>n &#x3D; 3 的时候的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">懒得敲，看上面的例子根据<span class="hljs-number">2</span>的改就好了<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong><code>2020羊城杯 Simple.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> DES<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">import</span> random<br><br>key = <span class="hljs-string">&quot;abcdefgh&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_encrypt</span>(<span class="hljs-params">m</span>):<br>    des = DES.new(key, DES.MODE_ECB)<br>    res = des.encrypt(m)<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_key</span>():<br>    p = getPrime(<span class="hljs-number">2048</span>)<br>    q = getPrime(<span class="hljs-number">2048</span>)<br>    n = p * q<br>    bit = n.bit_length()<br>    phi_n = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>    num = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        u = getPrime(bit / <span class="hljs-number">4</span> - num)<br>        <span class="hljs-keyword">if</span> gmpy2.gcd(u, phi_n) != <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br>        t = gmpy2.invert(u, phi_n)<br>        e = bytes_to_long(des_encrypt(long_to_bytes(t)))<br>        <span class="hljs-keyword">if</span> gmpy2.gcd(e, phi_n) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> (n, e)<br><br>P = getPrime(<span class="hljs-number">1024</span>)<br>Q = getPrime(<span class="hljs-number">1024</span>)<br>N = P * Q<br>E = <span class="hljs-number">65537</span><br>lcm = gmpy2.lcm(P-<span class="hljs-number">1</span>, Q-<span class="hljs-number">1</span>)<br>e1 = gmpy2.invert(getPrime(<span class="hljs-number">730</span>), lcm)<br>e2 = gmpy2.invert(getPrime(<span class="hljs-number">730</span>), lcm)<br>m = bytes_to_long(flag)<br>c = <span class="hljs-built_in">pow</span>(m, E, N)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;N = &quot;</span> + <span class="hljs-built_in">str</span>(N)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;e2 = &quot;</span> + <span class="hljs-built_in">str</span>(e2)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;c = &quot;</span> + <span class="hljs-built_in">str</span>(c)<br>_n, _e = gen_key()<br>_c = <span class="hljs-built_in">pow</span>(e1, _e, _n)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;_n = &quot;</span> + <span class="hljs-built_in">str</span>(_n)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;_e = &quot;</span> + <span class="hljs-built_in">str</span>(_e)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;_c = &quot;</span> + <span class="hljs-built_in">str</span>(_c)<br><br><span class="hljs-comment"># N = 14922959775784066499316528935316325825140011208871830627653191549546959775167708525042423039865322548420928571524120743831693550123563493981797950912895893476200447083386549353336086899064921878582074346791320104106139965010480614879592357793053342577850761108944086318475849882440272688246818022209356852924215237481460229377544297224983887026669222885987323082324044645883070916243439521809702674295469253723616677245762242494478587807402688474176102093482019417118703747411862420536240611089529331148684440513934609412884941091651594861530606086982174862461739604705354416587503836130151492937714365614194583664241</span><br><span class="hljs-comment"># e2 = 27188825731727584656624712988703151030126350536157477591935558508817722580343689565924329442151239649607993377452763119541243174650065563589438911911135278704499670302489754540301886312489410648471922645773506837251600244109619850141762795901696503387880058658061490595034281884089265487336373011424883404499124002441860870291233875045675212355287622948427109362925199018383535259913549859747158348931847041907910313465531703810313472674435425886505383646969400166213185676876969805238803587967334447878968225219769481841748776108219650785975942208190380614555719233460250841332020054797811415069533137170950762289</span><br><span class="hljs-comment"># c = 6472367338832635906896423990323542537663849304314171581554107495210830026660211696089062916158894195561723047864604633460433867838687338370676287160274165915800235253640690510046066541445140501917731026596427080558567366267665887665459901724487706983166070740324307268574128474775026837827907818762764766069631267853742422247229582756256253175941899099898884656334598790711379305490419932664114615010382094572854799421891622789614614720442708271653376485660139560819668239118588069312179293488684403404385715780406937817124588773689921642802703005341324008483201528345805611493251791950304129082313093168732415486813</span><br><span class="hljs-comment"># _n = 440489238264900860776949063845200558734341182253911040104689726634414488997095518284964514078079911856352824174173937251558842251349762631716798307360995414545464514355957499460396352456341058329671470384493547042182238690727766731554287411757022792467324815342497916894285866240516524768645049867582541899123632009100512965460004548382054578461249990158442675234477122521189649316341623637146867589119951831385717513964941787562068891523060843170463600255518728070958509224053460041184869943038887434435024428311063533345514827827485121055022245800823723487812635502090530820946638405345755666124356919178290008475459419571761406117827422883820901663916276191422633940699113760516149002609672230610575442643822241126824287790055264162725209120192661985259423924307785452001927701323647247782658775780117642900694831475681037634691806232211286493187121464506122012889644137364079403183353774265910554863733455161820449073656744610495110838881353269890437984975607744603113572453211439334880155671730821755361054781243639407912133971530394031933785051770725331242932929244719594830548310768937037042243794551163891451545574837838357398072638709907958216067999891842395376953596940377457308329336524488962532620850237570279134567668379</span><br><span class="hljs-comment"># _e = 861605654852236668414010386016782729745549477722901970933220380452652052018502113737968204529790495739233258572209422774257139256367928649554562561889013164344608269555777150446651170697255381344437283003508476336814132594917061838422072660017477530465048729471603537912401826065081663165440462979219418291010867656746870617893935758241591032350010782861988742885918015532494020406350897048575155800941991107973433915573030255070411073793489218782862225921465295055907689734413881263179029741870520797816282420230090879687287575328294171448819803530205292587159921154471289747571107461754730577787617451127061265552788125691266357724955508391085485034126227212788895416902189479587194999818764639403752596165043883295506465916277734482380252399557395621566461322664559344483889187037851178431011220134914560438657522787409632677020269086895142488669203469256629173438313487046130238010206678820035631793666627274457756812810094004185303422637897314225624079032617334487815628021058997628511963565055629435278956251869329025544623291223984190562109149316159243565323565271491356378189561005084676592786453581431393651385181326525455441155960432946682976515756161038293313433862078763004704003356983371787414787104076401121444383911561</span><br><span class="hljs-comment"># _c = 305937839546594439230463861584604201077374759167468410827830943528403007941779658881672477705113617614828611332427199124217887937391378281943856159571057598203709366891547401974326016980711130197275312149966105151573748299654404630150641461765232935912266448303266990247145252052886920248198006212876273661195636104435277145396636985516064154534488750879453474211852461463041960835745695368577903786702607508492658563272121038693371752289017330781719235752018697635304458321008407930986565779826278048082764754367267460637798512780153281325733348999426407049795270044819657399403071013496169060640127279409914638535996355848933378734045908205536540619564723586905257569498716707820544351092379516465943537383422680357333849248129118148543389733395686399565999586899123087310025442994131218237679518267106194962305629529210402269726736072967966518381350920965727690274018080619332676536005722214955949897632990356174168234408837737546230730400434240785496100281815168806724358191550743656843853383646410487436540166360406982096949178466861150173527305369007546917550634679211293496458282787881244581230558011582720632502886494712233308474151958909251857281750741736910202763888790654287328846201724930302778996046434656839999091303411</span><br></code></pre></td></tr></table></figure><p><strong>首先这题分为两部分。第一部分是 gen_key() 以及后面的输出求出 e1，第二部分就是利用 e1,e2 求出 c</strong></p><p><strong>第一部分的 t 可以直接DES解密求出来，然后又因为 u 满足 $u&lt;N^{0.25}$ 的条件，所以可以直接用wiener atttack分解出_n，从而求出e1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> DES<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>key = <span class="hljs-string">&quot;abcdefgh&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_decrypt</span>(<span class="hljs-params">m</span>):<br>    des = DES.new(key.encode(), DES.MODE_ECB)  <span class="hljs-comment"># Encode the key to bytes</span><br>    res = des.decrypt(m)<br>    <span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">x, y</span>):  <span class="hljs-comment"># 使用辗转相处将分数 x/y 转为连分数的形式</span><br>    res = []<br>    <span class="hljs-keyword">while</span> y:<br>        res.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continued_fraction</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 从sublist的后面往前循环</span><br>        denominator, numerator = numerator, i * numerator + denominator<br>    <span class="hljs-keyword">return</span> denominator, numerator  <span class="hljs-comment"># 得到渐进分数的分母和分子，并返回</span><br><br><br><span class="hljs-comment"># 求解每个渐进分数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub_fraction</span>(<span class="hljs-params">x, y</span>):<br>    res = transform(x, y)<br>    res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(continued_fraction, (res[<span class="hljs-number">0</span>:i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(res)))))  <span class="hljs-comment"># 将连分数的结果逐一截取以求渐进分数</span><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pq</span>(<span class="hljs-params">a, b, c</span>):  <span class="hljs-comment"># 由p+q和pq的值通过维达定理来求解p和q</span><br>    par = gmpy2.isqrt(b * b - <span class="hljs-number">4</span> * a * c)  <span class="hljs-comment"># 由上述可得，开根号一定是整数，因为有解</span><br>    x1, x2 = (-b + par) // (<span class="hljs-number">2</span> * a), (-b - par) // (<span class="hljs-number">2</span> * a)<br>    <span class="hljs-keyword">return</span> x1, x2<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wienerAttack</span>(<span class="hljs-params">e, n</span>):<br>    <span class="hljs-keyword">for</span> (d, k) <span class="hljs-keyword">in</span> sub_fraction(e, n):  <span class="hljs-comment"># 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 可能会出现连分数的第一个为0的情况，排除</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (e * d - <span class="hljs-number">1</span>) % k != <span class="hljs-number">0</span>:  <span class="hljs-comment"># ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)</span><br>            <span class="hljs-keyword">continue</span><br><br>        phi = (e * d - <span class="hljs-number">1</span>) // k  <span class="hljs-comment"># 这个结果就是 φ(n)</span><br>        px, qy = get_pq(<span class="hljs-number">1</span>, n - phi + <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span> px * qy == n:<br>            p, q = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(px)), <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(qy))  <span class="hljs-comment"># 可能会得到两个负数，负负得正未尝不会出现</span><br>            <span class="hljs-keyword">return</span> p<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;该方法不适用&quot;</span>)<br><br>_n = <span class="hljs-number">440489238264900860776949063845200558734341182253911040104689726634414488997095518284964514078079911856352824174173937251558842251349762631716798307360995414545464514355957499460396352456341058329671470384493547042182238690727766731554287411757022792467324815342497916894285866240516524768645049867582541899123632009100512965460004548382054578461249990158442675234477122521189649316341623637146867589119951831385717513964941787562068891523060843170463600255518728070958509224053460041184869943038887434435024428311063533345514827827485121055022245800823723487812635502090530820946638405345755666124356919178290008475459419571761406117827422883820901663916276191422633940699113760516149002609672230610575442643822241126824287790055264162725209120192661985259423924307785452001927701323647247782658775780117642900694831475681037634691806232211286493187121464506122012889644137364079403183353774265910554863733455161820449073656744610495110838881353269890437984975607744603113572453211439334880155671730821755361054781243639407912133971530394031933785051770725331242932929244719594830548310768937037042243794551163891451545574837838357398072638709907958216067999891842395376953596940377457308329336524488962532620850237570279134567668379</span><br>_e = <span class="hljs-number">861605654852236668414010386016782729745549477722901970933220380452652052018502113737968204529790495739233258572209422774257139256367928649554562561889013164344608269555777150446651170697255381344437283003508476336814132594917061838422072660017477530465048729471603537912401826065081663165440462979219418291010867656746870617893935758241591032350010782861988742885918015532494020406350897048575155800941991107973433915573030255070411073793489218782862225921465295055907689734413881263179029741870520797816282420230090879687287575328294171448819803530205292587159921154471289747571107461754730577787617451127061265552788125691266357724955508391085485034126227212788895416902189479587194999818764639403752596165043883295506465916277734482380252399557395621566461322664559344483889187037851178431011220134914560438657522787409632677020269086895142488669203469256629173438313487046130238010206678820035631793666627274457756812810094004185303422637897314225624079032617334487815628021058997628511963565055629435278956251869329025544623291223984190562109149316159243565323565271491356378189561005084676592786453581431393651385181326525455441155960432946682976515756161038293313433862078763004704003356983371787414787104076401121444383911561</span><br>_c = <span class="hljs-number">305937839546594439230463861584604201077374759167468410827830943528403007941779658881672477705113617614828611332427199124217887937391378281943856159571057598203709366891547401974326016980711130197275312149966105151573748299654404630150641461765232935912266448303266990247145252052886920248198006212876273661195636104435277145396636985516064154534488750879453474211852461463041960835745695368577903786702607508492658563272121038693371752289017330781719235752018697635304458321008407930986565779826278048082764754367267460637798512780153281325733348999426407049795270044819657399403071013496169060640127279409914638535996355848933378734045908205536540619564723586905257569498716707820544351092379516465943537383422680357333849248129118148543389733395686399565999586899123087310025442994131218237679518267106194962305629529210402269726736072967966518381350920965727690274018080619332676536005722214955949897632990356174168234408837737546230730400434240785496100281815168806724358191550743656843853383646410487436540166360406982096949178466861150173527305369007546917550634679211293496458282787881244581230558011582720632502886494712233308474151958909251857281750741736910202763888790654287328846201724930302778996046434656839999091303411</span><br>_t = bytes_to_long((des_decrypt(long_to_bytes(_e))))<br>_p = wienerAttack(_t,_n)<br>_q = _n//_p<br>_d = gmpy2.invert(_e,(_p-<span class="hljs-number">1</span>)*(_q-<span class="hljs-number">1</span>))<br>e1 = <span class="hljs-built_in">pow</span>(_c,_d,_n)<br><span class="hljs-built_in">print</span> (e1)<br></code></pre></td></tr></table></figure><p><strong>e1求出来后就按照拓展维纳攻击来做</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> invert<br>c  = <span class="hljs-number">6472367338832635906896423990323542537663849304314171581554107495210830026660211696089062916158894195561723047864604633460433867838687338370676287160274165915800235253640690510046066541445140501917731026596427080558567366267665887665459901724487706983166070740324307268574128474775026837827907818762764766069631267853742422247229582756256253175941899099898884656334598790711379305490419932664114615010382094572854799421891622789614614720442708271653376485660139560819668239118588069312179293488684403404385715780406937817124588773689921642802703005341324008483201528345805611493251791950304129082313093168732415486813</span><br>e2 = <span class="hljs-number">27188825731727584656624712988703151030126350536157477591935558508817722580343689565924329442151239649607993377452763119541243174650065563589438911911135278704499670302489754540301886312489410648471922645773506837251600244109619850141762795901696503387880058658061490595034281884089265487336373011424883404499124002441860870291233875045675212355287622948427109362925199018383535259913549859747158348931847041907910313465531703810313472674435425886505383646969400166213185676876969805238803587967334447878968225219769481841748776108219650785975942208190380614555719233460250841332020054797811415069533137170950762289</span><br>e1 = <span class="hljs-number">114552459553730357961013268333698879659007919035942930313432809776799669181481660306531243618160127922304264986001501784564575128319884991774542682853466808329973362019677284072646678280051091964555611220961719302320547405880386113519147076299481594997799884384012548506240748042365643212774215730304047871679706035596550898944580314923260982768858133395187777029914150064371998328788068888440803565964567662563652062845388379897799506439389461619422933318625765603423604615137217375612091221578339493263160670355032898186792479034771118678394464854413824347305505135625135428816394053078365603937337271798774138959</span><br>N  = <span class="hljs-number">14922959775784066499316528935316325825140011208871830627653191549546959775167708525042423039865322548420928571524120743831693550123563493981797950912895893476200447083386549353336086899064921878582074346791320104106139965010480614879592357793053342577850761108944086318475849882440272688246818022209356852924215237481460229377544297224983887026669222885987323082324044645883070916243439521809702674295469253723616677245762242494478587807402688474176102093482019417118703747411862420536240611089529331148684440513934609412884941091651594861530606086982174862461739604705354416587503836130151492937714365614194583664241</span><br>a  = <span class="hljs-number">0.356</span><span class="hljs-comment">#731./2049</span><br>M1=N**<span class="hljs-number">0.5</span><br>M2=N**(a+<span class="hljs-number">1</span>)<br>D = diagonal_matrix(ZZ,[N,M1,M2,<span class="hljs-number">1</span>])<br>M=matrix(ZZ,[[<span class="hljs-number">1</span>,-N,<span class="hljs-number">0</span>,N**<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,e1,-e1,-e1*N],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,e2,-e2*N],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,e1*e2]])*D<br>L=M.LLL()<br>t=vector(ZZ,L[<span class="hljs-number">0</span>])<br>x=t*M**(-<span class="hljs-number">1</span>)<br>phi = <span class="hljs-built_in">int</span>(x[<span class="hljs-number">1</span>]/x[<span class="hljs-number">0</span>]*e1)<br>d = invert(<span class="hljs-number">0x10001</span>,phi)<br>m=<span class="hljs-built_in">pow</span>(c,d,N)<br><span class="hljs-built_in">print</span> long_to_bytes(m) <br></code></pre></td></tr></table></figure><hr><p><strong>参考：</strong><br><strong>[HPS14] Hoffstein J, Pipher J, Silverman J H, et al. An Introduction to Cryptography[M]. Springer New York, 2014.</strong><br><strong><a href="https://www.cnblogs.com/oyrd/p/15835527.html">Lattice Learning1</a></strong><br><strong><a href="https://tover.xyz/p/LLL-attack-equation/">格攻击之小未知数方程求解入门——原理与例子</a></strong><br><strong><a href="https://huangx607087.online/2021/02/01/LatticeNotes1/#toc-heading-2">LatticeNotes1</a></strong><br><strong><a href="https://www.ruanx.net/lattice-2/">格密码笔记（二）</a></strong><br><strong><a href="https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener/">CTF Wiki</a></strong><br><strong><a href="https://www.sci-hub.ren/https://link.springer.com/chapter/10.1007/3-540-46701-7_14">《Extending Wiener’s Attack in the Presence of Many Decrypting Exponents》</a></strong><br><strong><a href="https://blog.csdn.net/jcbx_/article/details/109306542">密码学硬核笔记——扩展维纳攻击</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>格密码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES Padding Oracle Attack</title>
    <link href="/2024/03/02/AES%20Padding%20Oracle%20Attack/"/>
    <url>/2024/03/02/AES%20Padding%20Oracle%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="AES-Padding-Oracle-Attack"><a href="#AES-Padding-Oracle-Attack" class="headerlink" title="AES Padding Oracle Attack"></a>AES Padding Oracle Attack</h1><p><strong>先回顾一下AES的CBC模式</strong></p><p><strong>加密：</strong><br><strong><center>C<sub>i</sub> &#x3D; E<sub>k</sub>(P<sub>i</sub> ⊕ C<sub>i-1</sub>)<br>C<sub>0</sub> &#x3D; IV</center></strong><br><strong>解密：</strong><br><strong><center>P<sub>i</sub> &#x3D; D<sub>k</sub>(C<sub>i</sub> ⊕ C<sub>i-1</sub>)<br>C<sub>0</sub> &#x3D; IV</center></strong></p><h2 id="CBC字节翻转攻击"><a href="#CBC字节翻转攻击" class="headerlink" title="CBC字节翻转攻击"></a>CBC字节翻转攻击</h2><p><strong>对于CBC模式的解密算法，每一组明文进行分组算法解密之后，需要和前一组的密文异或才能得到明文。第一组则是和初始向量IV进行异或。</strong></p><p><strong>CBC字节翻转攻击的核心原理是通过破坏一个比特的密文来篡改一个比特的明文。</strong></p><p><strong>假设现在我们有第 N-1 组密文某一位的值 A ，以及第 N 组密文相同位置经过分组解密后的值 B ，于是我们能够很容易得到第 N 组该位置上的明文 C 。</strong><br><strong><center>A ⊕ B &#x3D; C</center></strong><br><strong>如果我们破坏第 N-1 组的密文 A ，将其与明文 C 进行异或运算，由异或的性质可以得到下式：</strong></p><p><strong><center>A ⊕ C ⊕ B &#x3D; C ⊕ C &#x3D; 0</center></strong><br><strong>可以看见，现在计算出的明文变成0了，现在我们可以将明文随意更改成我们想要的字符。只需要在上一组的密文异或我们想要的字符即可，假设我们想将明文 C 更改为 X ，可以由下式得出：</strong></p><p><strong><center>A ⊕ C ⊕ X ⊕ B &#x3D; C ⊕ C ⊕ X &#x3D; X</center></strong><br><strong>此时我们已经通过破坏密文将明文更改成我们想要的字符，具体攻击流程可以参考下图</strong></p><p><img src="/img/bg/CBC.jpg" alt="CBC字节翻转攻击流程"></p><p><strong>用Python模拟一下攻击流程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> binascii<br> <br> <br>BS=AES.block_size  <span class="hljs-comment">#分组长度</span><br>key=<span class="hljs-string">b&#x27;test&#x27;</span>  <span class="hljs-comment">#密钥</span><br>iv=uuid.uuid4().<span class="hljs-built_in">bytes</span>  <span class="hljs-comment">#随机初始向量</span><br>pad=<span class="hljs-keyword">lambda</span> s: s+((BS-<span class="hljs-built_in">len</span>(s)%BS)*<span class="hljs-built_in">chr</span>(BS-<span class="hljs-built_in">len</span>(s)%BS)).encode()  <span class="hljs-comment">#Pkcs5Padding</span><br>data=<span class="hljs-string">b&#x27;1234567890abcdefabcdef1234567890&#x27;</span>  <span class="hljs-comment">#明文M</span><br> <br><span class="hljs-comment">#加密</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params">data</span>):<br>    aes=AES.new(pad(key),AES.MODE_CBC,iv)<br>    ciphertext=aes.encrypt(pad(data))<br>    ciphertext=binascii.b2a_hex(ciphertext)<br>    <span class="hljs-keyword">return</span> ciphertext<br> <br><span class="hljs-comment">#解密</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dec</span>(<span class="hljs-params">c</span>):<br>    c=binascii.a2b_hex(c)<br>    aes=AES.new(pad(key),AES.MODE_CBC,iv)<br>    data=aes.decrypt(c)<br>    <span class="hljs-keyword">return</span> data<br> <br><span class="hljs-comment">#测试CBC翻转</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CBC_test</span>(<span class="hljs-params">c</span>):<br>    c=<span class="hljs-built_in">bytearray</span>(binascii.a2b_hex(c))<br>    c[<span class="hljs-number">0</span>]=c[<span class="hljs-number">0</span>]^<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)^<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment">#c[0]为第一组的密文字符，a为第二组相应位置的明文字符，A是我们想要的明文字符</span><br>    c=binascii.b2a_hex(c)<br>    <span class="hljs-keyword">return</span> c<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ciphertext:&quot;</span>,enc(data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data:&quot;</span>,dec(enc(data)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CBC Attack:&quot;</span>,dec(CBC_test(enc(data))))<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ciphertext: <span class="hljs-string">b&#x27;ffa645d1b5e40afbbae47de053a66f978fa0a824e99864a7e8baf38ceccda613c304883f11fc0857c1bb7603f859798e&#x27;</span><br>data: <span class="hljs-string">b&#x27;1234567890abcdefabcdef1234567890\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10&#x27;</span><br>CBC Attack: <span class="hljs-string">b&#x27;:8O&lt;\xe7\x04\xd8v\xe8Q\xfe\xa5I\xc9c]Abcdef1234567890\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>可以看到第二组密文解密之后已经被我们更改成了A，而由于我们更改了第一组的密文，所以第一组解密的明文变成了乱码。如果我们想要更改第一组的明文，则需要修改初始向量IV的值。</strong></p><p><strong>通过CBC字节翻转攻击，假如我们能够触发加解密过程，并且能够获得每次加密后的密文。那么我们就能够在不知道key的情况下，通过修改密文或IV，来控制输出明文为自己想要的内容，而且只能从最后一组开始修改，并且每改完一组，都需要重新获取一次解密后的数据，要根据解密后的数据来修改前一组密文的值。</strong></p><p><strong>通过修改明文修改IV（不会改变对应密文）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">flipplain</span>(<span class="hljs-params">oldplain, newplain, iv</span>):  <span class="hljs-comment"># 定义一个函数用于进行CBC字节翻转攻击</span><br>    <span class="hljs-string">&quot;&quot;&quot;flip oldplain to new plain, return proper iv&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> strxor(strxor(oldplain, newplain), iv)<br></code></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Padding Oracle Attack 攻击一般需要满足以下几个条件：</strong></p><ul><li><strong>加密算法：</strong><ul><li><strong>采用 PKCS5或者PKCS7 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。</strong></li><li><strong>分组模式为 CBC 模式。</strong></li></ul></li><li><strong>攻击者能力：</strong><ul><li><strong>攻击者可以拦截上述加密算法加密的消息。</strong></li><li><strong>攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。</strong></li></ul></li></ul><p><strong>此时Padding Oracle Attack就可以在不清楚 key 和 IV 的前提下解密任意给定的密文。</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>假设现在有一个真实场景：</strong></p><p><strong>某程序使用Cookie来加密传递用户的加密用户名、公司 ID 和角色 ID。该Cookie使用CBC Mode加密，每个Cookie使用一个唯一的初始化向量iv，该向量位于密文之前。</strong></p><p><strong>当应用程序收到一个加密Cookie时，它有以下三种响应方式：</strong></p><ul><li><strong>当收到一个有效的密文（一个被正确填充并包含有效数据的密文）时，应用程序正常响应（200 OK）</strong></li><li><strong>当收到无效的密文时（解密时填充错误的密文），应用程序会抛出加密异常（500 内部服务器错误）</strong></li><li><strong>当收到一个有效密文（解密时正确填充的密文）但解密为无效值时，应用程序会显示自定义错误消息 (200 OK)</strong></li></ul><p><strong>上面描述的场景是一个经典的Padding Oracle，因为我们可以使用程序的行为来确定提供的加密值是否被正确填充。</strong></p><p><strong>假设有一个员工，其信息分别为：用户名：BRIAN、公司ID：12、角色ID：1。各信息之间用分号分隔，于是可以表示成以下形式：<code>BRAIN;12;1</code></strong></p><p><strong>假设我们使用PKCS5填充，可以转换为以下形式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">BRIAN;<span class="hljs-number">12</span>;<span class="hljs-number">1</span>;0x050x050x050x050x05<br><span class="hljs-comment">#16字节，符合Pkcs5分组长度，可以将以上字符串分为两组，每组8字节</span><br></code></pre></td></tr></table></figure><p><strong>下面是CBC的加密过程</strong></p><p><img src="/img/bg/CBC1.jpg" alt="CBC加密"></p><p><strong>这里设置的初始向量iv为<code>0x7B 0x21 0x6A 0x63 0x49 0x51 0x17 0x0F</code>，这时服务器发送的Cookie应该为<code>7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6</code>，初始向量iv被填充在加密密文之前。</strong></p><p><strong>CBC解密过程如下</strong></p><p><img src="/img/bg/CBC2.jpg" alt="CBC解密"></p><p><strong>密文进行分组解密之后会产生中间值Intermediary Value，这些中间值再和前一组密文异或便会得到本组明文。解密出的明文后面会有正确的填充块。当然在客户端，我们无法得知这些中间值是什么。</strong></p><h3 id="攻击原理一"><a href="#攻击原理一" class="headerlink" title="攻击原理一"></a>攻击原理一</h3><p><strong>首先我们可以更改Cookie 中的初始向量iv，将iv的值改为全零，并且只发送第一个加密块。此时Cookie变为</strong><br><strong><code>Cookie：0000000000000000F851D6CC68FC9537</code></strong></p><p><strong>服务器端的解密过程如下</strong></p><p><img src="/img/bg/CBC3.jpg" alt="攻击原理一"></p><p><strong>可以看到，如果按照我们发送的错误数据来解密的话，最后一位数据是<code>0x3D</code>。而正常的解密数据最后是包含填充数据的。对于分组长度为8字节来说，这些填充数据的值位于<code>0x01-0x08</code>，而<code>0x3D</code>并不在其中。所以服务器会检测到填充块错误，返回500异常。</strong></p><h3 id="攻击原理二"><a href="#攻击原理二" class="headerlink" title="攻击原理二"></a>攻击原理二</h3><p><strong>我们再次更改Cookie中的初始向量iv，和上次不同的是，我们将iv最后一位的值改为<code>0x01</code>，此时Cookie的值如下</strong><br><strong><code>Cookie：0000000000000001F851D6CC68FC9537</code></strong></p><p><strong>我们再次将Cookie发送给服务器端解密</strong></p><p><img src="/img/bg/CBC4.jpg" alt="攻击原理二"></p><p><strong>可以看见，此时明文最后一位变成了<code>0x3C</code>，这仍然不是正确的填充数据，服务器同样会返回500异常。但是与上次不一样的是，明文最后一位的值从<code>0x3D</code>变为了<code>0x3C</code>。也就是说，我们可以通过控制初始向量iv的值来控制明文输出。</strong></p><p><strong>如果我们重复发出相同的请求并每次只更改iv中同一个字节的值（最多至0xFF），我们肯定能够碰到一个值，使明文符合填充规律。</strong></p><h3 id="攻击原理三"><a href="#攻击原理三" class="headerlink" title="攻击原理三"></a>攻击原理三</h3><p><strong>假设我们通过不断发送类似的Cookie给服务器端解密，找到了一个使明文符合填充规律的Cookie，此时服务器端的解密过程如下</strong></p><p><img src="/img/bg/CBC5.jpg" alt="攻击原理三"></p><p><strong>解密后的明文最后一位为<code>0x01</code>，符合填充规律，但是明文结果并不正确。此时服务器会返回200OK自定义页面。由于填充规律是固定的，我们只更改了一位iv的值，所以解密明文肯定是一位填充数据，值为<code>0x01</code>。此时我们可以根据以下公式得到一位加密的中间值<code>0x3D</code></strong><br><strong><center>0x3D &#x3D; 0x3C ⊕ 0x01</center></strong></p><h3 id="攻击原理四"><a href="#攻击原理四" class="headerlink" title="攻击原理四"></a>攻击原理四</h3><p><strong>类似地，我们可以爆破iv值的每一位，直到解密出来的每一位明文数据都变成全部符合填充规律的<code>0x08</code>，解密过程如下</strong></p><p><img src="/img/bg/CBC6.jpg" alt="攻击原理四"></p><p><strong>至此，我们可以利用Padding Oracle Attack来爆破出每一组加密中间值。然后再使用第一组的中间值和服务器端初始的iv异或，便可以得到第一组明文。继续使用CBC Mode解密，可以依次得到所有明文分组。</strong></p><p><strong>对于每一组，至多需要尝试256*8次也就是2048次，便可爆破出加密中间值。这样我们就可以绕过加密，从而直接获得密文的明文。</strong></p><h3 id="攻击原理五"><a href="#攻击原理五" class="headerlink" title="攻击原理五"></a>攻击原理五</h3><p><strong>在利用测试四中，我们已经能够利用Padding Oracle Attack爆破出所有中间值和明文了，那么我们该怎么构造出任意明文的合法密文呢？</strong></p><p><strong>首先我们先看单一分组的情况</strong></p><p><img src="/img/bg/CBC6.jpg" alt="单一分组"></p><p><strong>由于我们已经爆破出了intermediary，所以我们可以很容易地构造出iv来生成任意明文。</strong></p><p><strong>那么对于多组明文，情况又是怎样的呢？</strong></p><p><img src="/img/bg/CBC7.jpg" alt="多组情况"></p><p><strong>先从最后一组开始，爆破最后一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文，以此类推。由此我们可以得到构造密文的步骤</strong></p><ol><li><strong>从最后一组开始，爆破出该组的intermediary并构造出iv，然后将本组的iv当作前一组的密文</strong></li><li><strong>爆破前一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文</strong></li><li><strong>…</strong></li><li><strong>最后会得到第一组的iv，至此我们已经构造出了所有合法密文以及iv</strong></li></ol><h3 id="基础脚本"><a href="#基础脚本" class="headerlink" title="基础脚本"></a>基础脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AES_CBC_enc</span>(<span class="hljs-params">m, key, iv</span>):<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    <span class="hljs-keyword">return</span> aes.encrypt(m)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AES_CBC_dec</span>(<span class="hljs-params">c, key, iv</span>):<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    <span class="hljs-keyword">return</span> aes.decrypt(c)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding_to_16</span>(<span class="hljs-params">msg</span>):<br>    padding = <span class="hljs-number">16</span> - (<span class="hljs-built_in">len</span>(msg) % <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">return</span> msg + <span class="hljs-built_in">bytes</span>([padding]) * padding<br><br><br><span class="hljs-comment"># unpadding and check padding characters</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpadding</span>(<span class="hljs-params">msg</span>):<br>    padding = msg[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> padding == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(padding):<br>        <span class="hljs-keyword">if</span> (msg[-i-<span class="hljs-number">1</span>] != padding):<br>            <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> msg[:-padding], <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding_oracle_attack</span>(<span class="hljs-params">msg_enc, key, iv</span>):<br>    middle = [<span class="hljs-number">0</span>] * <span class="hljs-number">16</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trange(<span class="hljs-number">16</span>):<br>        my_iv = deepcopy(middle)<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:<br>            my_iv[-i:] = xor(my_iv[-i:], [i+<span class="hljs-number">1</span>]*i)<br>        <span class="hljs-built_in">print</span>(my_iv)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>            my_iv[-i-<span class="hljs-number">1</span>] = j<br><br>            msg_after_padding = AES_CBC_dec(msg_enc, key, <span class="hljs-built_in">bytes</span>(my_iv))<br>            flag = unpadding(msg_after_padding)[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span>:<br>                middle[-i-<span class="hljs-number">1</span>] = j ^ (i+<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span><br><br>    msg_after_padding = xor(middle, <span class="hljs-built_in">bytearray</span>(iv))<br>    <span class="hljs-built_in">print</span>(msg_after_padding)<br>    msg, flag = unpadding(<span class="hljs-built_in">bytes</span>(msg_after_padding))<br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">False</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> msg<br><br><br>msg = os.urandom(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">15</span>))<br>key = os.urandom(<span class="hljs-number">16</span>)<br>iv = os.urandom(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(msg)<br><br><span class="hljs-comment"># padding msg </span><br>msg_after_padding = padding_to_16(msg)<br>msg_enc = AES_CBC_enc(msg_after_padding, key, iv)<br><br><span class="hljs-comment"># padding_oracle_attack recover msg</span><br>msg = padding_oracle_attack(msg_enc, key, iv)<br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2023-第六届安洵杯-Cry2"><a href="#2023-第六届安洵杯-Cry2" class="headerlink" title="2023 第六届安洵杯 Cry2"></a>2023 第六届安洵杯 Cry2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> isPrime, long_to_bytes, getStrongPrime, bytes_to_long<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> socketserver<br><br>FLAG = <span class="hljs-string">&#x27;**********&#x27;</span><br>KEY = <span class="hljs-string">b&#x27;****************&#x27;</span><br>IV = <span class="hljs-string">b&#x27;****************&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cbc_decrypt</span>(<span class="hljs-params">c, iv</span>):<br>    aes = AES.new(KEY, AES.MODE_CBC, iv=iv)<br>    <span class="hljs-keyword">return</span> aes.decrypt(c)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>():<br>    plain_text = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]) + FLAG<br>    aes = AES.new(KEY, AES.MODE_CBC, iv=IV)<br>    plain_text = pad(plain_text.encode(), AES.block_size)<br>    cipher = aes.encrypt(plain_text)<br>    <span class="hljs-keyword">return</span> IV.<span class="hljs-built_in">hex</span>() + cipher.<span class="hljs-built_in">hex</span>()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">asserts</span>(<span class="hljs-params">pt: <span class="hljs-built_in">bytes</span></span>):<br>    num = pt[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pt) == <span class="hljs-number">16</span>:<br>        result = pt[::-<span class="hljs-number">1</span>]<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>            <span class="hljs-keyword">if</span> i == num:<br>                count += <span class="hljs-number">1</span> <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> count == num:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">c</span>):<br>    iv = c[:<span class="hljs-number">32</span>]<br>    cipher = c[<span class="hljs-number">32</span>:]<br>    plain_text = cbc_decrypt(binascii.unhexlify(cipher), binascii.unhexlify(iv))<br>    <span class="hljs-keyword">if</span> asserts(plain_text):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span>(socketserver.BaseRequestHandler):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">proof</span>(<span class="hljs-params">self</span>):<br>        random.seed(os.urandom(<span class="hljs-number">8</span>))<br>        random_str = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters + string.digits) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>)])<br>        str_sha256 = hashlib.sha256(random_str.encode()).hexdigest()<br>        <span class="hljs-variable language_">self</span>.request.sendall((<span class="hljs-string">&#x27;SHA256(XXXX + %s):%s\n&#x27;</span> % (random_str[<span class="hljs-number">4</span>:], str_sha256)).encode())<br>        <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;Give Me XXXX:\n&#x27;</span>.encode())<br>        XXXX = <span class="hljs-variable language_">self</span>.request.recv(<span class="hljs-number">2048</span>).strip()<br><br>        <span class="hljs-keyword">if</span> hashlib.sha256((XXXX + random_str[<span class="hljs-number">4</span>:].encode())).hexdigest() != str_sha256:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.proof():<br>            <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">b&#x27;Error Hash!&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>        cipher = encrypt()<br>        <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;Welcome to AES System, please choose the following options:\n1. encrypt the flag\n2. decrypt the flag\n&#x27;</span>.encode())<br>        n = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">65536</span>:<br>            options = <span class="hljs-variable language_">self</span>.request.recv(<span class="hljs-number">512</span>).strip().decode()<br>            <span class="hljs-keyword">if</span> options == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-variable language_">self</span>.request.sendall((<span class="hljs-string">&#x27;This is your flag: %s\n&#x27;</span> % cipher).encode())<br>            <span class="hljs-keyword">elif</span> options == <span class="hljs-string">&#x27;2&#x27;</span>:<br>                <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;Please enter ciphertext:\n&#x27;</span>.encode())<br>                recv_cipher = <span class="hljs-variable language_">self</span>.request.recv(<span class="hljs-number">512</span>).strip().decode()<br>                <span class="hljs-keyword">if</span> decrypt(recv_cipher):<br>                    <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;True\n&#x27;</span>.encode())<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;False\n&#x27;</span>.encode())<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;Input wrong! Please re-enter\n&#x27;</span>.encode())<br>            n += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTCPServer</span>(socketserver.ThreadingMixIn, socketserver.TCPServer):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sever = socketserver.ThreadingTCPServer((<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-number">10010</span>), MyServer)<br>    ThreadedTCPServer.allow_reuse_address = <span class="hljs-literal">True</span><br>    ThreadedTCPServer.allow_reuse_port = <span class="hljs-literal">True</span><br>    sever.serve_forever()<br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p><strong>这一题的核心思路就是利用Padding Oracle Attack爆破出middle，但是这个攻击是有条件的，我们先分析一下题目的关键代码</strong></p><p><strong>flag通过PKCS7的方式padding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<br><br>plain_text = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]) + FLAG<br>plain_text = pad(plain_text.encode(), AES.block_size)<br></code></pre></td></tr></table></figure><p><strong>已知iv和ciphertext</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> options == <span class="hljs-string">&#x27;1&#x27;</span>:<br>    <span class="hljs-variable language_">self</span>.request.sendall((<span class="hljs-string">&#x27;This is your flag: %s\n&#x27;</span> % cipher).encode())<br></code></pre></td></tr></table></figure><p><strong>服务端会用key以及我们发过去的iv和ciphertext解密得到一个plaintext，然后用asserts函数检查该plaintext的padding字符，如果符合pkcs7会输出”True”，不符合则输出”False”</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> options == <span class="hljs-string">&#x27;2&#x27;</span>:<br>    <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;Please enter ciphertext:\n&#x27;</span>.encode())<br>    recv_cipher = <span class="hljs-variable language_">self</span>.request.recv(<span class="hljs-number">512</span>).strip().decode()<br>    <span class="hljs-keyword">if</span> decrypt(recv_cipher):<br>        <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;True\n&#x27;</span>.encode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-variable language_">self</span>.request.sendall(<span class="hljs-string">&#x27;False\n&#x27;</span>.encode())<br></code></pre></td></tr></table></figure><p><strong>总结一下，我们现在已知</strong></p><ol><li><strong>plaintext经过pad</strong></li><li><strong>已知iv和ciphertext（其实只要有iv就足够了）</strong></li><li><strong>解密的iv和ciphertext可控，解密得到plaintext，检查其padding是否正确并输出检查结果</strong></li></ol><p><strong>符合这些条件就可以实现Padding Oracle Attack来恢复plaintext了</strong></p><h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> ascii_letters, digits<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> binascii<br><br><br><span class="hljs-comment"># context.log_level = &quot;debug&quot;</span><br>p = remote(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">10010</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proof</span>():<br>    p.recvuntil(<span class="hljs-string">b&quot;SHA256(XXXX + &quot;</span>)<br>    last = p.recvuntil(<span class="hljs-string">b&quot;):&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>    shav = p.recvline()[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;last = <span class="hljs-subst">&#123;last&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;shav = <span class="hljs-subst">&#123;shav&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> cont <span class="hljs-keyword">in</span> itertools.product(ascii_letters + digits, repeat=<span class="hljs-number">4</span>):<br>        cont = <span class="hljs-string">&#x27;&#x27;</span>.join(cont).encode()<br>        <span class="hljs-keyword">if</span> hashlib.new(<span class="hljs-string">&quot;sha256&quot;</span>, cont + last).hexdigest() == shav.decode():<br>            <span class="hljs-built_in">print</span>(cont)<br>            <span class="hljs-keyword">break</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Give Me XXXX:\n&quot;</span>, cont)<br><br><br><span class="hljs-comment"># unpadding and check padding characters</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpadding</span>(<span class="hljs-params">msg</span>):<br>    padding = msg[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> padding == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(padding):<br>        <span class="hljs-keyword">if</span> (msg[-i-<span class="hljs-number">1</span>] != padding):<br>            <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> msg[:-padding], <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding_oracle_attack</span>(<span class="hljs-params">iv, c</span>):<br>    solved_dec = [<span class="hljs-number">0</span>] * <span class="hljs-number">16</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trange(<span class="hljs-number">16</span>):<br>        new_iv = deepcopy(solved_dec)<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:<br>            new_iv[-i:] = xor(new_iv[-i:], [i+<span class="hljs-number">1</span>]*i)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>            new_iv[-i-<span class="hljs-number">1</span>] = j<br><br>            p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>            p.sendlineafter(<span class="hljs-string">b&quot;Please enter ciphertext:\n&quot;</span>, (<span class="hljs-built_in">bytes</span>(new_iv).<span class="hljs-built_in">hex</span>() + c.<span class="hljs-built_in">hex</span>()).encode())<br>            <span class="hljs-keyword">if</span> p.recvline() != <span class="hljs-string">b&quot;False\n&quot;</span>:<br>                solved_dec[-i-<span class="hljs-number">1</span>] = j ^ (i+<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span><br><br>    msg_after_padding = xor(solved_dec, <span class="hljs-built_in">bytearray</span>(iv))<br>    <span class="hljs-built_in">print</span>(msg_after_padding)<br>    msg, flag = unpadding(<span class="hljs-built_in">bytes</span>(msg_after_padding))<br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">False</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> msg<br><br><br>get_proof()<br><br>p.sendlineafter(<span class="hljs-string">b&quot;1. encrypt the flag\n2. decrypt the flag\n&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>iv_and_c = binascii.unhexlify(p.recvline().decode()[<span class="hljs-number">19</span>:-<span class="hljs-number">1</span>])<br>iv, c = iv_and_c[:<span class="hljs-number">16</span>], iv_and_c[<span class="hljs-number">16</span>:]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;iv = <span class="hljs-subst">&#123;iv&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c = <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br><br>msg = padding_oracle_attack(iv, c)<br><span class="hljs-built_in">print</span>(msg)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">last = b&#x27;OfBypjLi4BizYvHW&#x27;</span><br><span class="hljs-string">shav = b&#x27;c0786d83da7177ab64ac113343ad157e4a7784998fb2be1ff84ab1e378499375&#x27;</span><br><span class="hljs-string">b&#x27;OTnk&#x27;</span><br><span class="hljs-string">iv = b&#x27;`\xb9\x9c\xa7K&gt;SfC|\xabz\x8b*\x00`&#x27;</span><br><span class="hljs-string">c = b&#x27;#\xad\xfd\x84m\x16F\x17\xc3\xc9s\xce\x02\x86\x04\x88&#x27;</span><br><span class="hljs-string">100%|██████████| 16/16 [00:00&lt;00:00, 51.35it/s]</span><br><span class="hljs-string">b&#x27;Obflag&#123;test&#125;\x04\x04\x04\x04&#x27;</span><br><span class="hljs-string">b&#x27;Obflag&#123;test&#125;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2017-HITCON-Secret-Server"><a href="#2017-HITCON-Secret-Server" class="headerlink" title="2017 HITCON Secret Server"></a>2017 HITCON Secret Server</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os, base64, time, random, string <br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES <br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> * <br><br>key = os.urandom(<span class="hljs-number">16</span>)  <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">msg</span>):<br>    pad_length = <span class="hljs-number">16</span>-<span class="hljs-built_in">len</span>(msg)%<span class="hljs-number">16</span>  <br>    <span class="hljs-keyword">return</span> msg+<span class="hljs-built_in">chr</span>(pad_length)*pad_length  <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpad</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">return</span> msg[:-<span class="hljs-built_in">ord</span>(msg[-<span class="hljs-number">1</span>])]  <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">iv,msg</span>):<br>    msg = pad(msg)  <br>    cipher = AES.new(key,AES.MODE_CBC,iv)  <br>    encrypted = cipher.encrypt(msg)  <br>    <span class="hljs-keyword">return</span> encrypted  <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">iv,msg</span>):<br>    cipher = AES.new(key,AES.MODE_CBC,iv)  <br>    decrypted = cipher.decrypt(msg)  <br>    decrypted = unpad(decrypted)  <br>    <span class="hljs-keyword">return</span> decrypted  <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_msg</span>(<span class="hljs-params">msg</span>):<br>    iv = <span class="hljs-string">&#x27;2jpmLoSsOlQrqyqE&#x27;</span>  <br>    encrypted = encrypt(iv,msg)  <br>    msg = iv+encrypted  <br>    msg = base64.b64encode(msg)  <br>    <span class="hljs-built_in">print</span> msg  <br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># 定义一个函数，用于接收消息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_msg</span>():<br>    msg = raw_input() <br>    <span class="hljs-keyword">try</span>:<br>        msg = base64.b64decode(msg)  <span class="hljs-comment"># 对接收到的消息进行Base64解码</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(msg)&lt;<span class="hljs-number">500</span>  <br>        decrypted = decrypt(msg[:<span class="hljs-number">16</span>],msg[<span class="hljs-number">16</span>:])  <br>        <span class="hljs-keyword">return</span> decrypted  <br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Error&#x27;</span>  <span class="hljs-comment"># 如果在解码或解密过程中出现错误，打印错误信息并退出程序</span><br>        exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义一个函数，用于进行工作量证明（Proof of Work）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proof_of_work</span>():<br>    proof = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters+string.digits) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">20</span>)])  <span class="hljs-comment"># 生成一个随机的20字符的字符串</span><br>    digest = SHA256.new(proof).hexdigest()  <span class="hljs-comment"># 对生成的字符串进行SHA256哈希</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;SHA256(XXXX+%s) == %s&quot;</span> % (proof[<span class="hljs-number">4</span>:],digest)  <span class="hljs-comment"># 打印哈希值</span><br>    x = raw_input(<span class="hljs-string">&#x27;Give me XXXX:&#x27;</span>)  <span class="hljs-comment"># 接收用户输入的前4个字符</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x)!=<span class="hljs-number">4</span> <span class="hljs-keyword">or</span> SHA256.new(x+proof[<span class="hljs-number">4</span>:]).hexdigest() != digest:  <span class="hljs-comment"># 验证用户输入的前4个字符是否正确</span><br>        exit(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 如果验证失败，退出程序</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Done!&quot;</span>  <span class="hljs-comment"># 如果验证成功，打印成功信息</span><br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    proof_of_work()  <span class="hljs-comment"># 执行工作量证明</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>        flag = f.read().strip()  <br>    <span class="hljs-keyword">assert</span> flag.startswith(<span class="hljs-string">&#x27;hitcon&#123;&#x27;</span>) <span class="hljs-keyword">and</span> flag.endswith(<span class="hljs-string">&#x27;&#125;&#x27;</span>)  <br>    send_msg(<span class="hljs-string">&#x27;Welcome!!&#x27;</span>)  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <br>        <span class="hljs-keyword">try</span>:<br>            msg = recv_msg().strip()  <span class="hljs-comment"># 接收并去除消息两端的空白字符</span><br>            <span class="hljs-keyword">if</span> msg.startswith(<span class="hljs-string">&#x27;exit-here&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;exit-here&#x27;开头，退出程序</span><br>                exit(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-flag&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-flag&#x27;开头，发送flag</span><br>                send_msg(flag)<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-md5&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-md5&#x27;开头，发送消息的MD5哈希值</span><br>                send_msg(MD5.new(msg[<span class="hljs-number">7</span>:]).digest())<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-time&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-time&#x27;开头，发送当前时间</span><br>                send_msg(<span class="hljs-built_in">str</span>(time.time()))<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-sha1&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-sha1&#x27;开头，发送消息的SHA1哈希值</span><br>                send_msg(SHA.new(msg[<span class="hljs-number">8</span>:]).digest())<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-sha256&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-sha256&#x27;开头，发送消息的SHA256哈希值</span><br>                send_msg(SHA256.new(msg[<span class="hljs-number">10</span>:]).digest())<br>            <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-hmac&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-hmac&#x27;开头，发送消息的HMAC哈希值</span><br>                send_msg(HMAC.new(msg[<span class="hljs-number">8</span>:]).digest())<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果消息不符合以上任何一种格式，发送&#x27;command not found&#x27;</span><br>                send_msg(<span class="hljs-string">&#x27;command not found&#x27;</span>)<br>        <span class="hljs-keyword">except</span>:<br>            exit(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 如果在接收消息或处理消息过程中出现错误，退出程序</span><br></code></pre></td></tr></table></figure><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p><strong>程序中采用的加密是 AES CBC，其中采用的 padding 与 PKCS5 类似</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">msg</span>):<br>    pad_length = <span class="hljs-number">16</span>-<span class="hljs-built_in">len</span>(msg)%<span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> msg+<span class="hljs-built_in">chr</span>(pad_length)*pad_length<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpad</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">return</span> msg[:-<span class="hljs-built_in">ord</span>(msg[-<span class="hljs-number">1</span>])]<br></code></pre></td></tr></table></figure><p><strong>但是，在每次 unpad 时并没有进行检测，而是直接进行 unpad。</strong></p><p><strong>其中，需要注意的是，每次和用户交互的函数是</strong></p><ul><li><strong><code>send_msg</code> ，接受用户的明文，使用固定的 <code>2jpmLoSsOlQrqyqE</code> 作为 IV，进行加密，并将加密结果输出。</strong></li><li><strong><code>recv_msg</code> ，接受用户的 IV 和密文，对密文进行解密，并返回。根据返回的结果会有不同的操作</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">    msg = recv_msg().strip()  <span class="hljs-comment"># 接收并去除消息两端的空白字符</span><br>    <span class="hljs-keyword">if</span> msg.startswith(<span class="hljs-string">&#x27;exit-here&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;exit-here&#x27;开头，退出程序</span><br>        exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-flag&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-flag&#x27;开头，发送flag</span><br>        send_msg(flag)<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-md5&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-md5&#x27;开头，发送消息的MD5哈希值</span><br>        send_msg(MD5.new(msg[<span class="hljs-number">7</span>:]).digest())<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-time&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-time&#x27;开头，发送当前时间</span><br>        send_msg(<span class="hljs-built_in">str</span>(time.time()))<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-sha1&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-sha1&#x27;开头，发送消息的SHA1哈希值</span><br>        send_msg(SHA.new(msg[<span class="hljs-number">8</span>:]).digest())<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-sha256&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-sha256&#x27;开头，发送消息的SHA256哈希值</span><br>        send_msg(SHA256.new(msg[<span class="hljs-number">10</span>:]).digest())<br>    <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-hmac&#x27;</span>):  <span class="hljs-comment"># 如果消息以&#x27;get-hmac&#x27;开头，发送消息的HMAC哈希值</span><br>        send_msg(HMAC.new(msg[<span class="hljs-number">8</span>:]).digest())<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果消息不符合以上任何一种格式，发送&#x27;command not found&#x27;</span><br>        send_msg(<span class="hljs-string">&#x27;command not found&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    exit(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 如果在接收消息或处理消息过程中出现错误，退出程序</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="主要漏洞"><a href="#主要漏洞" class="headerlink" title="主要漏洞"></a>主要漏洞</h4><p><strong>我们已有的部分</strong></p><ul><li><strong>加密时IV是固定的且已知</strong></li><li><strong><code>Welcome!!</code> 加密后的结果</strong></li><li><strong>我们可以控制IV</strong></li></ul><p><strong>首先，既然我们知道 <code>Welcome!!</code> 加密后的结果，还可以控制 <code>recv_msg</code> 中的 IV，那么根据解密过程</strong><br><strong><center>P<sub>i</sub> &#x3D; D<sub>k</sub>(C<sub>i</sub> ⊕ C<sub>i-1</sub>)<br>C<sub>0</sub> &#x3D; IV</center></strong><br><strong>如果我们将 <code>Welcome!!</code> 加密后的结果输入给 <code>recv_msg</code>，那么直接解密后的结果便是 <code>（Welcome!!+&#39;\x07&#39;*7) xor iv</code>，如果我们恰当的控制解密过程中传递的 iv，那么我们就可以控制解密后的结果。也就是说我们可以执行上述所说的任意命令。从而，我们也就可以知道 <code>flag</code> 解密后的结果。</strong></p><p><strong>其次，在上面的基础之上，如果我们在任何密文 C 后面添加自定义的 IV 和 Welcome 加密后的结果，作为输入传递给 <code>recv_msg</code>，那么我们便可以控制解密之后的消息的最后一个字节，那么由于 <code>unpad</code> 操作，我们便可以控制解密后的消息的长度减小 0 到 255。</strong></p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol><li><strong>绕过 <code>proof of work</code></strong></li><li><strong>根据执行任意命令的方式获取加密后的 flag</strong></li><li><strong>由于 <code>flag</code> 的开头是 <code>hitcon&#123;</code>，一共有 7 个字节，所以我们任然可以通过控制 iv 来使得解密后的前 7 个字节为指定字节。这使得我们可以对于解密后的消息执行 <code>get-md5</code> 命令。而根据 <code>unpad</code> 操作，我们可以控制解密后的消息恰好在消息的第几个字节处。所以我们可以开始时将控制解密后的消息为 <code>hitcon&#123;x</code>，即只保留 <code>hitcon&#123;</code> 后的一个字节。这样便可以获得带一个字节哈希后的加密结果。类似地，我们也可以获得带制定个字节哈希后的加密结果。</strong></li><li><strong>这样的话，我们可以在本地逐字节爆破，计算对应 <code>md5</code>，然后再次利用任意命令执行的方式，控制解密后的明文为任意指定命令，如果控制不成功，那说明该字节不对，需要再次爆破；如果正确，那么就可以直接执行对应的命令。</strong></li></ol><h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br><span class="hljs-keyword">import</span> base64, time, random, string  <br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES  <br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA256, MD5  <br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;REMOTE&#x27;</span>]:  <br>    p = remote(<span class="hljs-string">&#x27;52.193.157.19&#x27;</span>, <span class="hljs-number">9999</span>)<br><span class="hljs-keyword">else</span>:  <br>    p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">7777</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">strxor</span>(<span class="hljs-params">str1, str2</span>):  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(c1) ^ <span class="hljs-built_in">ord</span>(c2)) <span class="hljs-keyword">for</span> c1, c2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(str1, str2)])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">msg</span>):  <br>    pad_length = <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(msg) % <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> msg + <span class="hljs-built_in">chr</span>(pad_length) * pad_length<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpad</span>(<span class="hljs-params">msg</span>): <br>    <span class="hljs-keyword">return</span> msg[:-<span class="hljs-built_in">ord</span>(msg[-<span class="hljs-number">1</span>])]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flipplain</span>(<span class="hljs-params">oldplain, newplain, iv</span>):  <span class="hljs-comment"># 定义一个函数用于进行CBC字节翻转攻击</span><br>    <span class="hljs-string">&quot;&quot;&quot;flip oldplain to new plain, return proper iv&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> strxor(strxor(oldplain, newplain), iv)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bypassproof</span>():  <span class="hljs-comment"># 定义一个函数用于绕过服务器的工作量证明</span><br>    p.recvuntil(<span class="hljs-string">&#x27;SHA256(XXXX+&#x27;</span>)  <span class="hljs-comment"># 读取服务器发来的信息，直到遇到&#x27;SHA256(XXXX+&#x27;为止</span><br>    lastdata = p.recvuntil(<span class="hljs-string">&#x27;)&#x27;</span>, drop=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 读取&#x27;SHA256(XXXX+&#x27;后面的字符，直到遇到&#x27;)&#x27;为止，得到proof的后16个字符</span><br>    p.recvuntil(<span class="hljs-string">&#x27; == &#x27;</span>)  <span class="hljs-comment"># 继续读取服务器发来的信息，直到遇到&#x27; == &#x27;为止</span><br>    digest = p.recvuntil(<span class="hljs-string">&#x27;\nGive me XXXX:&#x27;</span>, drop=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 读取&#x27; == &#x27;后面的字符，直到遇到&#x27;\nGive me X<span class="hljs-doctag">XXX:</span>&#x27;为止，得到SHA256哈希值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">proof</span>(<span class="hljs-params">s</span>):  <span class="hljs-comment"># 定义一个函数，用于检查给定的s是否满足条件</span><br>        <span class="hljs-keyword">return</span> SHA256.new(s + lastdata).hexdigest() == digest  <span class="hljs-comment"># 计算s加上lastdata的SHA256哈希值，然后检查计算出的哈希值是否等于digest</span><br><br>    <span class="hljs-comment"># 使用暴力破解的方法，尝试所有可能的s值，直到找到一个使得proof函数返回True的s值</span><br>    data = pwnlib.util.iters.mbruteforce(<br>        proof, string.ascii_letters + string.digits, <span class="hljs-number">4</span>, method=<span class="hljs-string">&#x27;fixed&#x27;</span>)<br>    p.sendline(data)  <span class="hljs-comment"># 将找到的s值发送给服务器</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Done!\n&#x27;</span>)  <span class="hljs-comment"># 读取服务器的回应，确认工作量证明已经完成</span><br><br>iv_encrypt = <span class="hljs-string">&#x27;2jpmLoSsOlQrqyqE&#x27;</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getmd5enc</span>(<span class="hljs-params">i, cipher_flag, cipher_welcome</span>):  <span class="hljs-comment"># 定义一个函数用于获取flag的前i个字符的MD5哈希值的加密结果</span><br>    <span class="hljs-string">&quot;&quot;&quot;return encrypt( md5( flag[7:7+i] ) )&quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 通过修改iv的前7个字节，使得解密后的明文块的前7个字节变为&#x27;get-md5&#x27;，而后面的字节不变</span><br>    new_iv = flipplain(<span class="hljs-string">&quot;hitcon&#123;&quot;</span>.ljust(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), <span class="hljs-string">&quot;get-md5&quot;</span>.ljust(<br>        <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), iv_encrypt)<br>    payload = new_iv + cipher_flag  <span class="hljs-comment"># 将修改后的iv和cipher_flag连接起来，作为新的payload</span><br><br>    <span class="hljs-comment"># 计算最后一个字节的值，使得解密后的明文块的最后一个字节为len(cipher_flag) + 16 + 16 - (7 + i + 1)</span><br>    <span class="hljs-comment"># 这样可以使得服务器在解密后的明文上调用md5函数，计算出flag的前i个字符的MD5哈希值</span><br>    last_byte_iv = flipplain(<br>        pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>),<br>        <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">15</span> + <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">len</span>(cipher_flag) + <span class="hljs-number">16</span> + <span class="hljs-number">16</span> - (<span class="hljs-number">7</span> + i + <span class="hljs-number">1</span>)), iv_encrypt)<br>    payload += last_byte_iv + cipher_welcome  <span class="hljs-comment"># 将计算出的最后一个字节和cipher_welcome添加到payload的末尾</span><br><br>    p.sendline(base64.b64encode(payload))  <span class="hljs-comment"># 将payload进行base64编码，然后发送给服务器</span><br>    <span class="hljs-keyword">return</span> p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 读取服务器的回应，获取flag的前i个字符的MD5哈希值的加密结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():  <span class="hljs-comment"># 定义主函数</span><br>    bypassproof()  <span class="hljs-comment"># 首先绕过服务器的工作量证明</span><br><br>    <span class="hljs-comment"># 获取加密后的&quot;Welcome!!&quot;的密文</span><br>    cipher = p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br>    cipher_welcome = base64.b64decode(cipher)[<span class="hljs-number">16</span>:]<br>    log.info(<span class="hljs-string">&quot;cipher welcome is : &quot;</span> + cipher_welcome)<br><br>    <span class="hljs-comment"># 执行get-flag命令，获取加密后的flag的密文</span><br>    get_flag_iv = flipplain(pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>), pad(<span class="hljs-string">&quot;get-flag&quot;</span>), iv_encrypt)<br>    payload = base64.b64encode(get_flag_iv + cipher_welcome)<br>    p.sendline(payload)<br>    cipher = p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br>    cipher_flag = base64.b64decode(cipher)[<span class="hljs-number">16</span>:]<br>    flaglen = <span class="hljs-built_in">len</span>(cipher_flag)<br>    log.info(<span class="hljs-string">&quot;cipher flag is : &quot;</span> + cipher_flag)<br><br>    <span class="hljs-comment"># 获取&quot;command not found&quot;的密文</span><br>    p.sendline(base64.b64encode(iv_encrypt + cipher_welcome))<br>    cipher_notfound = p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br><br>    flag = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># 对于flag的每一个字节，使用暴力破解的方法进行猜测</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(flaglen - <span class="hljs-number">7</span>):<br>        md5_indexi = getmd5enc(i, cipher_flag, cipher_welcome)<br>        md5_indexi = base64.b64decode(md5_indexi)[<span class="hljs-number">16</span>:]<br>        log.info(<span class="hljs-string">&quot;get encrypt(md5(flag[7:7+i])): &quot;</span> + md5_indexi)<br>        <span class="hljs-keyword">for</span> guess <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>            <span class="hljs-comment"># 计算猜测的字节的MD5哈希值</span><br>            guess_md5 = MD5.new(flag + <span class="hljs-built_in">chr</span>(guess)).digest()<br>            <span class="hljs-comment"># 通过修改前一个密文块，使得解密后的明文块的值为&#x27;get-time&#x27;，然后发送给服务器</span><br>            payload = flipplain(guess_md5, <span class="hljs-string">&#x27;get-time&#x27;</span>.ljust(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x01&#x27;</span>),<br>                                iv_encrypt)<br>            payload += md5_indexi<br>            p.sendline(base64.b64encode(payload))<br>            res = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>            <span class="hljs-comment"># 如果收到的回应是&#x27;command not found&#x27;的密文，说明猜测的字节是错误的</span><br>            <span class="hljs-keyword">if</span> res == cipher_notfound:<br>                <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Guess &#123;&#125; is wrong.&#x27;</span>.<span class="hljs-built_in">format</span>(guess)<br>            <span class="hljs-comment"># 如果收到的回应不是&#x27;command not found&#x27;的密文，说明猜测的字节是正确的</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Found!&#x27;</span><br>                flag += <span class="hljs-built_in">chr</span>(guess)<br>                <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Flag so far:&#x27;</span>, flag<br>                <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()  <br><br><span class="hljs-comment">#Flag so far: Paddin9_15_ve3y_h4rd__!!&#125;\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10</span><br></code></pre></td></tr></table></figure><hr><h3 id="2017-HITCON-Secret-Server-Revenge"><a href="#2017-HITCON-Secret-Server-Revenge" class="headerlink" title="2017 HITCON Secret Server Revenge"></a>2017 HITCON Secret Server Revenge</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> *<br><br>key = os.urandom(<span class="hljs-number">16</span>)<br>iv = os.urandom(<span class="hljs-number">16</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">msg</span>):<br>  pad_length = <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(msg) % <span class="hljs-number">16</span><br>  <span class="hljs-keyword">return</span> msg + <span class="hljs-built_in">chr</span>(pad_length) * pad_length<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpad</span>(<span class="hljs-params">msg</span>):<br>  <span class="hljs-keyword">return</span> msg[:-<span class="hljs-built_in">ord</span>(msg[-<span class="hljs-number">1</span>])]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">iv, msg</span>):<br>  msg = pad(msg)<br>  cipher = AES.new(key, AES.MODE_CBC, iv)<br>  encrypted = cipher.encrypt(msg)<br>  <span class="hljs-keyword">return</span> encrypted<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">iv, msg</span>):<br>  cipher = AES.new(key, AES.MODE_CBC, iv)<br>  decrypted = cipher.decrypt(msg)<br>  decrypted = unpad(decrypted)<br>  <span class="hljs-keyword">return</span> decrypted<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_msg</span>(<span class="hljs-params">msg</span>):<br>  encrypted = encrypt(iv, msg)<br>  msg = iv + encrypted<br>  msg = base64.b64encode(msg)<br>  <span class="hljs-built_in">print</span> msg<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_msg</span>():<br>  msg = raw_input()  <span class="hljs-comment"># 从用户输入中获取消息</span><br>  <span class="hljs-keyword">try</span>:<br>    msg = base64.b64decode(msg)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(msg)&lt;<span class="hljs-number">500</span>    <span class="hljs-comment"># 检查解码后的消息长度是否小于500</span><br>    decrypted = decrypt(msg[:<span class="hljs-number">16</span>], msg[<span class="hljs-number">16</span>:])<br>    <span class="hljs-keyword">return</span> decrypted<br>  <span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Error&#x27;</span><br>    exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_token</span>(<span class="hljs-params">token</span>):<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Give me the token!&#x27;</span><br>  msg = raw_input()  <span class="hljs-comment"># 从用户输入中获取消息</span><br>  msg = base64.b64decode(msg)<br>  <span class="hljs-keyword">return</span> msg == token<br><br><span class="hljs-comment"># 定义一个函数用来进行工作证明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proof_of_work</span>():<br>  proof = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters+string.digits) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">20</span>)])  <span class="hljs-comment"># 生成一个20字符的随机字符串</span><br>  digest = SHA256.new(proof).hexdigest()  <span class="hljs-comment"># 计算随机字符串的SHA256哈希</span><br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;SHA256(XXXX+%s) == %s&quot;</span> % (proof[<span class="hljs-number">4</span>:],digest)<br>  x = raw_input(<span class="hljs-string">&#x27;Give me XXXX:&#x27;</span>)  <span class="hljs-comment"># 从用户输入中获取响应</span><br>  <span class="hljs-comment"># 检查响应的长度是否为4，以及响应和随机字符串的后16个字符连接后的SHA256哈希是否等于原哈希</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x)!=<span class="hljs-number">4</span> <span class="hljs-keyword">or</span> SHA256.new(x+proof[<span class="hljs-number">4</span>:]).hexdigest() != digest: <br>    exit(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>  proof_of_work()<br>  token = os.urandom(<span class="hljs-number">56</span>)<br>  <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip()<br>  past = <span class="hljs-number">0</span><br>  send_msg(<span class="hljs-string">&#x27;Welcome!!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">340</span>):<br>    <span class="hljs-keyword">try</span>:<br>      cur = time.time()<br>      <span class="hljs-comment"># 如果当前时间和past之差小于1，那么等待一段时间，以确保每次循环至少需要1秒</span><br>      <span class="hljs-keyword">if</span> cur-past &lt; <span class="hljs-number">1</span>: time.sleep(<span class="hljs-number">1</span>-cur+past)<br>      <span class="hljs-comment"># 更新past为当前时间</span><br>      past = cur<br>      <span class="hljs-comment"># 接收消息</span><br>      msg = recv_msg()<br>      <span class="hljs-comment"># 如果消息以&#x27;exit-here&#x27;开头，那么退出程序</span><br>      <span class="hljs-keyword">if</span> msg.startswith(<span class="hljs-string">&#x27;exit-here&#x27;</span>):<br>        exit(<span class="hljs-number">0</span>)<br>      <span class="hljs-comment"># 如果消息以&#x27;get-md5&#x27;开头，那么计算消息的MD5哈希并发送回去</span><br>      <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-md5&#x27;</span>):<br>        send_msg(MD5.new(msg[<span class="hljs-number">7</span>:]).digest())<br>      <span class="hljs-comment"># 如果消息以&#x27;get-time&#x27;开头，那么发送当前时间</span><br>      <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-time&#x27;</span>):<br>        send_msg(<span class="hljs-built_in">str</span>(time.time()))<br>      <span class="hljs-comment"># 如果消息以&#x27;get-sha1&#x27;开头，那么计算消息的SHA1哈希并发送回去</span><br>      <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-sha1&#x27;</span>):<br>        send_msg(SHA.new(msg[<span class="hljs-number">8</span>:]).digest())<br>      <span class="hljs-comment"># 如果消息以&#x27;get-token&#x27;开头，那么发送token</span><br>      <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;get-token&#x27;</span>):<br>        send_msg(<span class="hljs-string">&#x27;token: &#x27;</span> + token)<br>      <span class="hljs-comment"># 如果消息以&#x27;check-token&#x27;开头，那么检查token，如果token匹配，打印flag</span><br>      <span class="hljs-keyword">elif</span> msg.startswith(<span class="hljs-string">&#x27;check-token&#x27;</span>):<br>        <span class="hljs-keyword">if</span> check_token(token):<br>          <span class="hljs-built_in">print</span> flag<br>        <span class="hljs-comment"># 无论token是否匹配，都退出程序</span><br>        exit(<span class="hljs-number">0</span>)<br>      <span class="hljs-comment"># 如果消息不符合上述任何一种格式，那么发送&#x27;command not found&#x27;</span><br>      <span class="hljs-keyword">else</span>:<br>        send_msg(<span class="hljs-string">&#x27;command not found&#x27;</span>)<br>    <span class="hljs-comment"># 如果在上述过程中出现任何错误，退出程序</span><br>    <span class="hljs-keyword">except</span>:<br>      exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  main()<br></code></pre></td></tr></table></figure><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p><strong>这个就是接着上面的来的，不过这次简单的修改了题目</strong></p><ul><li><strong>加密算法的 iv 未知，不过可以根据 <code>Welcome!!</code> 加密后的消息推算出来</strong></li><li><strong>程序多了一个 56 字节的 token</strong></li><li><strong>程序最多能进行 340 操作，因此上述的爆破自然不可行</strong></li></ul><p><strong>程序的大概流程如下</strong></p><ol><li><strong>经过 <code>proof of work</code></strong></li><li><strong>发送 <code>Welcome!!</code> 加密后的消息</strong></li><li><strong>在 340 次操作中，需要猜中 token 的值，然后会自动将 flag 输出</strong></li></ol><h4 id="主要漏洞-1"><a href="#主要漏洞-1" class="headerlink" title="主要漏洞"></a>主要漏洞</h4><p><strong>当然，在上个题目存在的漏洞在这里也有</strong></p><ol><li><strong>任意执行给定命令</strong></li><li><strong>长度截断</strong></li></ol><h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><p><strong>由于 340 的次数限制，虽然我们仍然可以获得 <code>md5(token[:i])</code> 加密后的值（这里需要注意的是这部分加密后恰好是 32 个字节，前 16 个字节是 <code>md5</code> 后加密的值，后面的 16 个字节完全是填充的加密后的字节。这里 <code>md5(token[:i])</code> 特指前 16 个字节）但是，我们不能再次为了获得一个字符去爆破 256 次了。</strong></p><p><strong>既然不能够爆破，那么我们有没有可能一次获取一个字节的大小呢？这里，我们再来梳理一下该程序可能可以泄漏的信息</strong></p><ol><li><strong>某些消息的 md5 值加密后的值，这里我们可以获取 <code>md5(token[:i])</code> 加密后的值</strong></li><li><strong>unpad 每次会对解密后的消息进行 unpad，这个字节是根据解密后的消息的最后一个字节来决定的。如果我们可以计算出这个字节的大小，那么我们就可能可以知道一个字节的值</strong></li></ol><p><strong>这里我们深入分析一下 <code>unpad</code> 的信息泄漏。如果我们将加密 IV 和 <code>encrypt(md5(token[:i]))</code> 放在某个密文 C 的后面，构成 <code>C|IV|encrypt(md5(token[:i]))</code> ，那么解密出来的消息的最后一个明文块就是 <code>md5(token[:i])</code> 。进而，在 <code>unpad</code> 的时候就是利用 <code>md5(token[:i])</code> 的最后一个字节（ 0-255）进行 <code>unpad</code> ，之后对 <code>unpad</code> 后的字符串执行指定的命令（比如 md5）。那么，如果我们事先构造一些消息哈希后加密的样本，然后将上述执行后的结果与样本比较，如果相同，那么我们基本可以确定 <code>md5(token[:i])</code> 的最后一个字节。然而，如果 <code>md5(token[:i])</code> 的最后一个字节小于 16，那么在 <code>unpad</code> 时就会利用一些 <code>md5</code> 中的值，而这部分值，由于对于不同长度的 <code>token[:i]</code> 几乎都不会相同。所以可能需要特殊处理。</strong></p><p><strong>我们已经知道了这个问题的关键，即生成与 unpad 字节大小对应的加密结果样本，以便于查表</strong></p><p><strong>具体利用思路如下</strong></p><ol><li><strong>绕过 <code>proof of work</code></strong></li><li><strong>获取 <code>token</code> 加密后的结果 <code>token_enc</code> ，这里会在 <code>token</code> 前面添加 7 个字节 <code>&quot;token: &quot;</code> 。 因此加密后的长度为 64</strong></li><li><strong>依次获取 <code>encrypt(md5(token[:i]))</code> 的结果，一共是 57 个，包括最后一个 <code>token</code> 的 padding</strong></li><li><strong>构造与 <code>unpad</code> 大小对应的样本。这里我们构造密文 <code>token_enc|padding|IV_indexi|welcome_enc</code> 。由于 <code>IV_indexi</code> 是为了修改最后一个明文块的最后一个字节，所以该字节处于变化之中。我们若想获取一些固定字节的哈希值，这部分自然不能添加。因此这里产生样本时 <code>unpad</code> 的大小范围为 17 ~ 255。如果最后测试时 <code>md5(token[:i])</code> 的最后一个字节小于 17 的话，基本就会出现一些未知的样本。很自然的一个想法是我们直接获取 255-17+1 个这么多个样本，然而，如果这样做的话，根据上面 340 的次数（255-17+1+57+56&gt;340）限制，我们显然不能获取到 <code>token</code> 的所有字节。所以这里我们需要想办法复用一些内容，这里我们选择复用 <code>encrypt(md5(token[:i]))</code> 的结果。那么我们在补充 padding 时需要确保一方面次数够用，另一方面可以复用之前的结果。这里我们设置 <code>unpad</code> 的循环为 17 到 208，并使得 <code>unpad</code> 大于 208 时恰好 <code>unpad</code> 到我们可以复用的地方。这里需要注意的是，当 <code>md5(token[:i])</code> 的最后一个字节为 0 时，会将所有解密后的明文 <code>unpad</code> 掉，因此会出现 <code>command not found</code> 的密文。</strong></li><li><strong>再次构造密文 <code>token_enc|padding|IV|encrypt(md5(token[:i]))</code> ，那么，解密时即使用 <code>md5(token[:i])</code> 的最后一个字节进行 <code>unpad</code> 。如果这个字节不小于 17 或者为 0，则可以处理。如果这个字节小于 17，那么显然，最后返回给用户的 <code>md5</code> 的结果并不在样本范围内，那么我们修改其最后一个字节的最高比特位，使其 <code>unpad</code> 后可以落在样本范围内。这样，我们就可以猜出 <code>md5(token[:i])</code> 的最后一个字节。</strong></li><li><strong>在猜出 <code>md5(token[:i])</code> 的最后一个字节后，我们可以在本地暴力破解 256 次，找出所有哈希值末尾为 <code>md5(token[:i])</code> 的最后一个字节的字符。</strong></li><li><strong>但是，在第六步中，对于一个 <code>md5(token[:i])</code> 可能会找出多个备选字符，因为我们只需要使得其末尾字节是给定字节即可。</strong></li><li><strong>那么，问题来了，如何删除一些多余的备选字符串呢？这里我就选择了一个小 trick，即在逐字节枚举时，同时枚举出 <code>token</code> 的 padding。由于 padding 是 0x01 是固定的，所以我们只需要过滤出所有结尾不是 0x01 的 <code>token</code> 即可。</strong></li></ol><h4 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> base64, time, random, string<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA256, MD5<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">7777</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">strxor</span>(<span class="hljs-params">str1, str2</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(c1) ^ <span class="hljs-built_in">ord</span>(c2)) <span class="hljs-keyword">for</span> c1, c2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(str1, str2)])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">msg</span>):<br>    pad_length = <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(msg) % <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> msg + <span class="hljs-built_in">chr</span>(pad_length) * pad_length<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpad</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">return</span> msg[:-<span class="hljs-built_in">ord</span>(msg[-<span class="hljs-number">1</span>])]  <span class="hljs-comment"># remove pad</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flipplain</span>(<span class="hljs-params">oldplain, newplain, iv</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;flip oldplain to new plain, return proper iv&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> strxor(strxor(oldplain, newplain), iv)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bypassproof</span>():<br>    p.recvuntil(<span class="hljs-string">&#x27;SHA256(XXXX+&#x27;</span>)<br>    lastdata = p.recvuntil(<span class="hljs-string">&#x27;)&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27; == &#x27;</span>)<br>    digest = p.recvuntil(<span class="hljs-string">&#x27;\nGive me XXXX:&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">proof</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-keyword">return</span> SHA256.new(s + lastdata).hexdigest() == digest<br><br>    data = pwnlib.util.iters.mbruteforce(<br>        proof, string.ascii_letters + string.digits, <span class="hljs-number">4</span>, method=<span class="hljs-string">&#x27;fixed&#x27;</span>)<br>    p.sendline(data)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sendmsg</span>(<span class="hljs-params">iv, cipher</span>):<br>    payload = iv + cipher<br>    payload = base64.b64encode(payload)<br>    p.sendline(payload)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recvmsg</span>():<br>    data = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>    data = base64.b64decode(data)<br>    <span class="hljs-keyword">return</span> data[:<span class="hljs-number">16</span>], data[<span class="hljs-number">16</span>:]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getmd5enc</span>(<span class="hljs-params">i, cipher_token, cipher_welcome, iv</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;return encrypt( md5( token[:i+1] ) )&quot;&quot;&quot;</span><br>    <span class="hljs-comment">## keep iv[7:] do not change, so decrypt msg[7:] won&#x27;t change</span><br>    get_md5_iv = flipplain(<span class="hljs-string">&quot;token: &quot;</span>.ljust(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), <span class="hljs-string">&quot;get-md5&quot;</span>.ljust(<br>        <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), iv)<br>    payload = cipher_token<br>    <span class="hljs-comment">## calculate the proper last byte number</span><br>    last_byte_iv = flipplain(<br>        pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>),<br>        <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">15</span> + <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">len</span>(cipher_token) + <span class="hljs-number">16</span> + <span class="hljs-number">16</span> - (<span class="hljs-number">7</span> + i + <span class="hljs-number">1</span>)), iv)<br>    payload += last_byte_iv + cipher_welcome<br>    sendmsg(get_md5_iv, payload)<br>    <span class="hljs-keyword">return</span> recvmsg()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_md5_token_indexi</span>(<span class="hljs-params">iv_encrypt, cipher_welcome, cipher_token</span>):<br>    md5_token_idxi = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cipher_token) - <span class="hljs-number">7</span>):<br>        log.info(<span class="hljs-string">&quot;idx i: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        _, md5_indexi = getmd5enc(i, cipher_token, cipher_welcome, iv_encrypt)<br>        <span class="hljs-keyword">assert</span> (<span class="hljs-built_in">len</span>(md5_indexi) == <span class="hljs-number">32</span>)<br>        <span class="hljs-comment"># remove the last 16 byte for padding</span><br>        md5_token_idxi.append(md5_indexi[:<span class="hljs-number">16</span>])<br>    <span class="hljs-keyword">return</span> md5_token_idxi<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">doin</span>(<span class="hljs-params">unpadcipher, md5map, candidates, flag</span>):<br>    <span class="hljs-keyword">if</span> unpadcipher <span class="hljs-keyword">in</span> md5map:<br>        lastbyte = md5map[unpadcipher]<br>    <span class="hljs-keyword">else</span>:<br>        lastbyte = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:<br>        lastbyte ^= <span class="hljs-number">0x80</span><br>    newcandidates = []<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> candidates:<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>            <span class="hljs-keyword">if</span> MD5.new(x + <span class="hljs-built_in">chr</span>(c)).digest()[-<span class="hljs-number">1</span>] == <span class="hljs-built_in">chr</span>(lastbyte):<br>                newcandidates.append(x + <span class="hljs-built_in">chr</span>(c))<br>    candidates = newcandidates<br>    <span class="hljs-built_in">print</span> candidates<br>    <span class="hljs-keyword">return</span> candidates<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    bypassproof()<br><br>    <span class="hljs-comment"># result of encrypted Welcome!!</span><br>    iv_encrypt, cipher_welcome = recvmsg()<br>    log.info(<span class="hljs-string">&quot;cipher welcome is : &quot;</span> + cipher_welcome)<br><br>    <span class="hljs-comment"># execute get-token</span><br>    get_token_iv = flipplain(pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>), pad(<span class="hljs-string">&quot;get-token&quot;</span>), iv_encrypt)<br>    sendmsg(get_token_iv, cipher_welcome)<br>    _, cipher_token = recvmsg()<br>    token_len = <span class="hljs-built_in">len</span>(cipher_token)<br>    log.info(<span class="hljs-string">&quot;cipher token is : &quot;</span> + cipher_token)<br><br>    <span class="hljs-comment"># get command not found cipher</span><br>    sendmsg(iv_encrypt, cipher_welcome)<br>    _, cipher_notfound = recvmsg()<br><br>    <span class="hljs-comment"># get encrypted(token[:i+1]),57 times</span><br>    md5_token_idx_list = get_md5_token_indexi(iv_encrypt, cipher_welcome,<br>                                              cipher_token)<br>    <span class="hljs-comment"># get md5map for each unpadsize, 209-17 times</span><br>    <span class="hljs-comment"># when upadsize&gt;208, it will unpad ciphertoken</span><br>    <span class="hljs-comment"># then we can reuse</span><br>    md5map = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">for</span> unpadsize <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">17</span>, <span class="hljs-number">209</span>):<br>        log.info(<span class="hljs-string">&quot;get unpad size &#123;&#125; cipher&quot;</span>.<span class="hljs-built_in">format</span>(unpadsize))<br>        get_md5_iv = flipplain(<span class="hljs-string">&quot;token: &quot;</span>.ljust(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), <span class="hljs-string">&quot;get-md5&quot;</span>.ljust(<br>            <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), iv_encrypt)<br>        <span class="hljs-comment">## padding 16*11 bytes</span><br>        padding = <span class="hljs-number">16</span> * <span class="hljs-number">11</span> * <span class="hljs-string">&quot;a&quot;</span><br>        <span class="hljs-comment">## calculate the proper last byte number, only change the last byte</span><br>        <span class="hljs-comment">## set last_byte_iv = iv_encrypted[:15] | proper byte</span><br>        last_byte_iv = flipplain(<br>            pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>),<br>            pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>)[:<span class="hljs-number">15</span>] + <span class="hljs-built_in">chr</span>(unpadsize), iv_encrypt)<br>        cipher = cipher_token + padding + last_byte_iv + cipher_welcome<br>        sendmsg(get_md5_iv, cipher)<br>        _, unpadcipher = recvmsg()<br>        md5map[unpadcipher] = unpadsize<br><br>    <span class="hljs-comment"># reuse encrypted(token[:i+1])</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">209</span>, <span class="hljs-number">256</span>):<br>        target = md5_token_idx_list[<span class="hljs-number">56</span> - (i - <span class="hljs-number">209</span>)]<br>        md5map[target] = i<br><br>    candidates = [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-comment"># get the byte token[i], only 56 byte</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(token_len - <span class="hljs-number">7</span>):<br>        log.info(<span class="hljs-string">&quot;get token[&#123;&#125;]&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        get_md5_iv = flipplain(<span class="hljs-string">&quot;token: &quot;</span>.ljust(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), <span class="hljs-string">&quot;get-md5&quot;</span>.ljust(<br>            <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>), iv_encrypt)<br>        <span class="hljs-comment">## padding 16*11 bytes</span><br>        padding = <span class="hljs-number">16</span> * <span class="hljs-number">11</span> * <span class="hljs-string">&quot;a&quot;</span><br>        cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list[i]<br>        sendmsg(get_md5_iv, cipher)<br>        _, unpadcipher = recvmsg()<br>        <span class="hljs-comment"># already in or md5[token[:i]][-1]=&#x27;\x00&#x27;</span><br>        <span class="hljs-keyword">if</span> unpadcipher <span class="hljs-keyword">in</span> md5map <span class="hljs-keyword">or</span> unpadcipher == cipher_notfound:<br>            candidates = doin(unpadcipher, md5map, candidates, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            log.info(<span class="hljs-string">&quot;unpad size 1-16&quot;</span>)<br>            <span class="hljs-comment"># flip most significant bit of last byte to move it in a good range</span><br>            cipher = cipher[:-<span class="hljs-number">17</span>] + strxor(cipher[-<span class="hljs-number">17</span>], <span class="hljs-string">&#x27;\x80&#x27;</span>) + cipher[-<span class="hljs-number">16</span>:]<br>            sendmsg(get_md5_iv, cipher)<br>            _, unpadcipher = recvmsg()<br>            <span class="hljs-keyword">if</span> unpadcipher <span class="hljs-keyword">in</span> md5map <span class="hljs-keyword">or</span> unpadcipher == cipher_notfound:<br>                candidates = doin(unpadcipher, md5map, candidates, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                log.info(<span class="hljs-string">&#x27;oh my god,,,, it must be in...&#x27;</span>)<br>                exit()<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">len</span>(candidates)<br>    <span class="hljs-comment"># padding 0x01</span><br>    candidates = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[-<span class="hljs-number">1</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-number">0x01</span>), candidates)<br>    <span class="hljs-comment"># only 56 bytes</span><br>    candidates = [x[:-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> candidates]<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">len</span>(candidates)<br>    <span class="hljs-keyword">assert</span> (<span class="hljs-built_in">len</span>(candidates[<span class="hljs-number">0</span>]) == <span class="hljs-number">56</span>)<br><br>    <span class="hljs-comment"># check-token</span><br>    check_token_iv = flipplain(<br>        pad(<span class="hljs-string">&quot;Welcome!!&quot;</span>), pad(<span class="hljs-string">&quot;check-token&quot;</span>), iv_encrypt)<br>    sendmsg(check_token_iv, cipher_welcome)<br>    p.recvuntil(<span class="hljs-string">&quot;Give me the token!\n&quot;</span>)<br>    p.sendline(base64.b64encode(candidates[<span class="hljs-number">0</span>]))<br>    <span class="hljs-built_in">print</span> p.recv()<br><br>    p.interactive()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><hr><p><strong>参考：<a href="https://goodapple.top/archives/217">CBC字节翻转攻击&amp;Padding Oracle Attack原理解析</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cloud.tencent.com/developer/article/2130129">一文搞明白 Padding Oracle Attack</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://ctf-wiki.org/crypto/blockcipher/mode/padding-oracle-attack/">CTF Wiki</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://skatexu.github.io/2024/01/09/2023-%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF-Cry2/">skateXu的博客</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>AES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCG学习</title>
    <link href="/2024/02/28/LCG%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/02/28/LCG%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="LCG学习"><a href="#LCG学习" class="headerlink" title="LCG学习"></a>LCG学习</h1><p><strong>LCG属于PRNG(伪随机数生成器)和stream cipher(流密码)的一种，是一种产生伪随机数的方法。<br>X<sub>n+1</sub> &#x3D; (a*X<sub>n</sub> + b) mod m<br>其中，X<sub>n</sub>代表第n个生成的随机数，X<sub>0</sub>被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</strong></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>LCG的性质与参数的选择密切相关，不同的参数可能导致不同的随机序列。一般按照如下要求选择参数：</strong></p><ul><li><strong>m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。</strong></li><li><strong>a是乘数，必须是一个与m互素的正整数。</strong></li><li><strong>b是增量，也必须是一个与m互素的正整数。</strong></li></ul><p><strong>LCG 的周期最大为 M，但大部分情况都会少于 M。要令 LCG 达到最大周期，应符合以下条件：</strong></p><ul><li><strong>B，M 互质</strong></li><li><strong>M 的所有质因数都能整除 A-1</strong></li><li><strong>若 M 是 4 的倍数，A-1 也是</strong></li><li><strong>A,B,X<sub>0</sub>都比 M 小</strong></li></ul><h2 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h2><p><strong>由X<sub>n+1</sub>反推X<sub>n</sub>：</strong><br><strong><center>X<sub>n</sub> &#x3D; ((X<sub>n+1</sub> - b) * a<sup>-1</sup>) mod m，这里a<sup>-1</sup>是模逆元</center></strong><br><strong>求 a：</strong><br><strong><center>a &#x3D; ((X<sub>n+1</sub> - X<sub>n</sub>) * (X<sub>n</sub> - X<sub>n-1</sub>)<sup>-1</sup>) mod m</center></strong><br><strong>求 b：</strong><br><strong><center>b &#x3D; (X<sub>n+1</sub> - a * X<sub>n</sub>) mod m</center></strong><br><strong>求 m:</strong><br><strong><center>t<sub>n</sub> &#x3D; X<sub>n+1</sub> - X<sub>n</sub> &#x3D; a(X<sub>n</sub> - X<sub>n-1</sub>) &#x3D; a*t<sub>n-1</sub> mod m</center></strong><br><strong><center>t<sub>n+1</sub>t<sub>n-1</sub> - t<sub>n</sub>t<sub>n</sub> &#x3D; a*a* t<sub>n-1</sub>*t<sub>n-1</sub> - a*t<sub>n-1</sub>*a*t<sub>n-1</sub> &#x3D; 0 mod m</center></strong><br><strong><center>即T<sub>n</sub> &#x3D; t<sub>n+1</sub>t<sub>n-1</sub> - t<sub>n</sub>t<sub>n</sub> 是 m 的倍数，故T<sub>n</sub>和T<sub>n-1</sub>的最大公因数即为 m</center></strong></p><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LCG</span>:<br>  a = <span class="hljs-number">672257317069504227</span>  <span class="hljs-comment"># &quot;乘数&quot;</span><br>  b = <span class="hljs-number">7382843889490547368</span>  <span class="hljs-comment"># &quot;增量&quot;</span><br>  m = <span class="hljs-number">9223372036854775783</span>  <span class="hljs-comment"># &quot;模数&quot;</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seed</span>):<br>    <span class="hljs-variable language_">self</span>.state = seed  <span class="hljs-comment"># &quot;种子&quot;</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.state = (<span class="hljs-variable language_">self</span>.state * <span class="hljs-variable language_">self</span>.a + <span class="hljs-variable language_">self</span>.b) % <span class="hljs-variable language_">self</span>.m<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.state<br>gen = LCG(<span class="hljs-number">123</span>)  <span class="hljs-comment"># seed = 123</span><br><span class="hljs-built_in">print</span> gen.<span class="hljs-built_in">next</span>()  <span class="hljs-comment"># 第一个生成值</span><br><span class="hljs-built_in">print</span> gen.<span class="hljs-built_in">next</span>()  <span class="hljs-comment"># 第二个生成值</span><br><span class="hljs-built_in">print</span> gen.<span class="hljs-built_in">next</span>()  <span class="hljs-comment"># 第三个生成值</span><br><span class="hljs-comment"># 7060145557346585242</span><br><span class="hljs-comment"># 3490819368718893392</span><br><span class="hljs-comment"># 6200546448603839134</span><br></code></pre></td></tr></table></figure><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="LCG-1：a，b，m都知道，相当于由Xn-1反推Xn"><a href="#LCG-1：a，b，m都知道，相当于由Xn-1反推Xn" class="headerlink" title="LCG_1：a，b，m都知道，相当于由Xn+1反推Xn"></a>LCG_1：a，b，m都知道，相当于由X<sub>n+1</sub>反推X<sub>n</sub></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LCG</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seed, a, b, m</span>):<br>        <span class="hljs-variable language_">self</span>.seed = seed  <span class="hljs-comment"># 初始种子</span><br>        <span class="hljs-variable language_">self</span>.a = a  <span class="hljs-comment"># 乘数</span><br>        <span class="hljs-variable language_">self</span>.b = b  <span class="hljs-comment"># 增量</span><br>        <span class="hljs-variable language_">self</span>.m = m  <span class="hljs-comment"># 模数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.seed = (<span class="hljs-variable language_">self</span>.a * <span class="hljs-variable language_">self</span>.seed + <span class="hljs-variable language_">self</span>.b) % <span class="hljs-variable language_">self</span>.m<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.seed<br><br><br>lcg = LCG(bytes_to_long(flag), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(getPrime(<span class="hljs-number">16</span>)):<br>    lcg.generate()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a = <span class="hljs-subst">&#123;lcg.a&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;b = <span class="hljs-subst">&#123;lcg.b&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;m = <span class="hljs-subst">&#123;lcg.m&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(lcg.generate())<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="hljs-string">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="hljs-string">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="hljs-string">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><ul><li><strong>迭代的次数是getPrime(16)，我们并不知道迭代了多少次，但是我们知道flag的格式是b’NSSCTF{******}’，不断反推直到符合格式即可</strong></li></ul><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> libnum<br><br>a = <span class="hljs-number">113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br>b = <span class="hljs-number">72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br>m = <span class="hljs-number">72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br>c=<span class="hljs-number">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><br><span class="hljs-comment"># c=(a*c0+b)%m</span><br>a_1=gmpy2.invert(a,m)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>):<br>    c = (c - b) * a_1 % m<br>    <span class="hljs-comment">#print(c)</span><br>    flag=libnum.n2s(<span class="hljs-built_in">int</span>(c))<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#123;&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;recover_init_seed&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="LCG-2：不知道b，用a，m，Xn-1和Xn推出b就和LCG-1一样了"><a href="#LCG-2：不知道b，用a，m，Xn-1和Xn推出b就和LCG-1一样了" class="headerlink" title="LCG_2：不知道b，用a，m，Xn+1和Xn推出b就和LCG_1一样了"></a>LCG_2：不知道b，用a，m，X<sub>n+1</sub>和X<sub>n</sub>推出b就和LCG_1一样了</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LCG</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seed, a, b, m</span>):<br>        <span class="hljs-variable language_">self</span>.seed = seed  <span class="hljs-comment"># 初始种子</span><br>        <span class="hljs-variable language_">self</span>.a = a  <span class="hljs-comment"># 乘数</span><br>        <span class="hljs-variable language_">self</span>.b = b  <span class="hljs-comment"># 增量</span><br>        <span class="hljs-variable language_">self</span>.m = m  <span class="hljs-comment"># 模数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.seed = (<span class="hljs-variable language_">self</span>.a * <span class="hljs-variable language_">self</span>.seed + <span class="hljs-variable language_">self</span>.b) % <span class="hljs-variable language_">self</span>.m<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.seed<br><br><br>lcg = LCG(bytes_to_long(flag), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(getPrime(<span class="hljs-number">16</span>)):<br>    lcg.generate()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a = <span class="hljs-subst">&#123;lcg.a&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;m = <span class="hljs-subst">&#123;lcg.m&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(lcg.generate())<br><span class="hljs-built_in">print</span>(lcg.generate())<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="hljs-string">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="hljs-string">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="hljs-string">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> isPrime<br><br>a = <span class="hljs-number">83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br>m = <span class="hljs-number">77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br>c1=<span class="hljs-number">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br>c2=<span class="hljs-number">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><br>b=(c2-a*c1) % m<br><span class="hljs-comment">#print(b)</span><br><span class="hljs-comment">#print(gmpy2.gcd(b,m))</span><br>a_1 = gmpy2.invert(a,m)<br>c = c1<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>):<br>    c = (c-b) * a_1 % m<br>    flag = libnum.n2s(<span class="hljs-built_in">int</span>(c))<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;recover_b&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="LCG-3：a、b都不知道，先求出a-之后操作同LCG-2"><a href="#LCG-3：a、b都不知道，先求出a-之后操作同LCG-2" class="headerlink" title="LCG_3：a、b都不知道，先求出a,之后操作同LCG_2"></a>LCG_3：a、b都不知道，先求出a,之后操作同LCG_2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LCG</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seed, a, b, m</span>):<br>        <span class="hljs-variable language_">self</span>.seed = seed  <span class="hljs-comment"># 初始种子</span><br>        <span class="hljs-variable language_">self</span>.a = a  <span class="hljs-comment"># 乘数</span><br>        <span class="hljs-variable language_">self</span>.b = b  <span class="hljs-comment"># 增量</span><br>        <span class="hljs-variable language_">self</span>.m = m  <span class="hljs-comment"># 模数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.seed = (<span class="hljs-variable language_">self</span>.a * <span class="hljs-variable language_">self</span>.seed + <span class="hljs-variable language_">self</span>.b) % <span class="hljs-variable language_">self</span>.m<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.seed<br><br><br>lcg = LCG(bytes_to_long(flag), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>), getPrime(<span class="hljs-number">256</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(getPrime(<span class="hljs-number">16</span>)):<br>    lcg.generate()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;m = <span class="hljs-subst">&#123;lcg.m&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(lcg.generate())<br><span class="hljs-built_in">print</span>(lcg.generate())<br><span class="hljs-built_in">print</span>(lcg.generate())<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="hljs-string">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="hljs-string">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="hljs-string">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> libnum<br><br>m = <span class="hljs-number">96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br>c1 = <span class="hljs-number">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br>c2 = <span class="hljs-number">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br>c3 = <span class="hljs-number">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><br>a = (c3-c2) * gmpy2.invert(c2-c1,m) % m<br><span class="hljs-comment"># print(gmpy2.gcd(a,m))</span><br>a_1 = gmpy2.invert(a,m)<br>b = (c2-a*c1) % m<br><span class="hljs-comment"># print(gmpy2.gcd(b,m))</span><br>c = c1<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>):<br>    c = (c-b) * a_1 % m<br>    flag = libnum.n2s(<span class="hljs-built_in">int</span>(c))<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#123;&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;now_recover_a&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="LCG-4：a、b、m都不知道，给出多组输出，让我们恢复初始种子"><a href="#LCG-4：a、b、m都不知道，给出多组输出，让我们恢复初始种子" class="headerlink" title="LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子"></a>LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;flag&#123;******&#125;&#x27;</span><br>seed = bytes_to_long(flag)<br>length = seed.bit_length()<br><br>a = getPrime(length)<br>b = getPrime(length)<br>p = getPrime(length)<br><br>output = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    seed = (a * seed + b) % p<br>    output.append(seed)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;output =&quot;</span>, output)<br><span class="hljs-comment"># output = [168629567557403367186885420444281063317304797350594299096453254, 37810059304430144255796769528019631599115017008645572272676848, 153467674569619182399277890239200868986878351528697622090498978, 130441867851875429652192551507870248584806009516471536255184738, 165072061865233441980188465107233439530695291179218871834569574, 169462757174386331962049136282171771458712297105156982582248590, 5733544729623964834423742564305810327645521588143518180790467, 29307267147593660845277077949962969239999900796071055310564887, 167961532214306463210330398007557832141937447147319867665370457, 18070228848659542858848007252120157475238819346210716562665302]</span><br></code></pre></td></tr></table></figure><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br> <br><span class="hljs-comment"># a = getPrime(length)</span><br><span class="hljs-comment"># b = getPrime(length)</span><br><span class="hljs-comment"># p = getPrime(length)</span><br><br>output = [<span class="hljs-number">168629567557403367186885420444281063317304797350594299096453254</span>, <span class="hljs-number">37810059304430144255796769528019631599115017008645572272676848</span>, <span class="hljs-number">153467674569619182399277890239200868986878351528697622090498978</span>, <span class="hljs-number">130441867851875429652192551507870248584806009516471536255184738</span>, <span class="hljs-number">165072061865233441980188465107233439530695291179218871834569574</span>, <span class="hljs-number">169462757174386331962049136282171771458712297105156982582248590</span>, <span class="hljs-number">5733544729623964834423742564305810327645521588143518180790467</span>, <span class="hljs-number">29307267147593660845277077949962969239999900796071055310564887</span>, <span class="hljs-number">167961532214306463210330398007557832141937447147319867665370457</span>, <span class="hljs-number">18070228848659542858848007252120157475238819346210716562665302</span>]<br><br>gift = output<br><br>t = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gift) - <span class="hljs-number">1</span>):<br>    t.append(gift[i] - gift[i-<span class="hljs-number">1</span>])<br><br>all_p = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t) - <span class="hljs-number">2</span>):<br>    all_p.append(gmpy2.gcd((t[i+<span class="hljs-number">1</span>] * t[i-<span class="hljs-number">1</span>] - t[i] * t[i]), (t[i+<span class="hljs-number">2</span>] * t[i] - t[i+<span class="hljs-number">1</span>] * t[i+<span class="hljs-number">1</span>])))<br><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> all_p:<br>    p = <span class="hljs-built_in">abs</span>(p)<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">continue</span><br>    <br>    <span class="hljs-comment">#求a</span><br>    MMI = <span class="hljs-keyword">lambda</span> A, n, s=<span class="hljs-number">1</span>, t=<span class="hljs-number">0</span>, N=<span class="hljs-number">0</span> : (n&lt;<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> t%N <span class="hljs-keyword">or</span> MMI(n, A%n, t, s-A//n*t, N <span class="hljs-keyword">or</span> n), -<span class="hljs-number">1</span>)[n&lt;<span class="hljs-number">1</span>]  <span class="hljs-comment">#逆元计算</span><br>    a = (gift[<span class="hljs-number">2</span>] - gift[<span class="hljs-number">1</span>]) * MMI((gift[<span class="hljs-number">1</span>] - gift[<span class="hljs-number">0</span>]), p) % p<br>    <br>    <span class="hljs-comment">#求b</span><br>    b = (gift[<span class="hljs-number">1</span>] - a * gift[<span class="hljs-number">0</span>]) % p<br>    <br>    ani = MMI(a, p)<br>    seed = gift[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>):<br>        seed = (ani * (seed - b)) % p<br>    <br>    <span class="hljs-built_in">print</span>(long_to_bytes(seed))<br><br><span class="hljs-comment"># b&#x27;\x02&#x27;</span><br><span class="hljs-comment"># b&#x27;\x02&#x27;</span><br><span class="hljs-comment"># b&#x27;\x17b\xd3\x03\xcaV\x95\x9a\xc5\xe7C\xa6\x1f\xa3\x88\xd5L\x02\xf5\xa9I\xb2\xce\x17/\xc7\xa6&#x27;</span><br><span class="hljs-comment"># b&#x27;\x1e\xb9I\xd93\xbd\x07\xcf\xbc\xbd\xe0\xf1\xf4\x18gB\xe8P\xfe;\x01B\xd2\xccy&gt;&#x27;</span><br><span class="hljs-comment"># b&#x27;\rj5\xb4\x19\xd9\xef\xa4\xee\xb0x\x08y\xc6\x0f\x81\x91@\xaf\x16\xd5\xaf\xdb\x8c)\xca\x9e&#x27;</span><br><span class="hljs-comment"># b&#x27;flag&#123;This_is_a_test_flag!&#125;&#x27;</span><br><span class="hljs-comment"># b&#x27;flag&#123;This_is_a_test_flag!&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>参考文章：<a href="https://blog.csdn.net/m0_74345946/article/details/132888135">LCG入门</a>,<a href="https://blog.csdn.net/weixin_45883223/article/details/115299389">LCG线性同余生成器</a></strong><br><strong>暂时只会这么多了，还有和格相关的算法，等格学明白了再补</strong></p>]]></content>
    
    
    <categories>
      
      <category>LCG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维纳攻击</title>
    <link href="/2024/02/23/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/23/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="维纳攻击"><a href="#维纳攻击" class="headerlink" title="维纳攻击"></a>维纳攻击</h1><h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><p><strong>e过大或过小，可从算法中快速推断出d的值。模数N&#x3D;pq，其中q&lt;p&lt;2q<br>若d &lt; (1&#x2F;3)N<sup>1&#x2F;4</sup>，且ed ≡ 1 mod L(N)<br>L(N) &#x3D; lcm(p-1,q-1) &#x3D; (p-1)(q-1)&#x2F;G &#x3D; φ(N)&#x2F;G，其中G &#x3D; gcd(p-1,q-1)</strong></p><h2 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h2><p><strong>因为ed ≡ 1 mod φ(N)，所以∃K∈Z，s.t. ed &#x3D; Kφ(N) + 1<br>即e&#x2F;φ(N) &#x3D; k&#x2F;d + 1&#x2F;dφ(N)，此时φ(N) ≈ N，且dφ(N)非常大，也就是说k&#x2F;d和e&#x2F;N非常接近<br>而e，N又是公钥，对e&#x2F;N进行连分数展开，得到的一串分数的分母很可能就是d<br>如果要求pq，由于已知N &#x3D; pq，φ(N) &#x3D; (p-1)(q-1) &#x3D; pq - (p+q) - 1，联系韦达定理，可以构造一元二次方程<br>x<sup>2</sup> - (p+q)x + pq &#x3D; x<sup>2</sup> - (N - φ(N) + 1)x + N &#x3D; 0，解出两根即为 p，q</strong></p><h2 id="连分数和渐进分数"><a href="#连分数和渐进分数" class="headerlink" title="连分数和渐进分数"></a>连分数和渐进分数</h2><p><strong>连分数是具有套式结构的分数，有理数和无理数都可以用它来表示。其主要优点之一是可以比小数更方便地写出任意精确度的无理数。<br>最简单的连分数具有如下图的表达形式：</strong></p><p><img src="/img/bg/math.jpg" alt="1"></p><p><strong>或者写成更简单的形式：【a0，a1，a2，a3，，，，】<br>如89&#x2F;26可以写成如下图连分数的形式：</strong></p><p><img src="/img/bg/math2.jpg" alt="2"></p><p><strong>或者写成简单的表达式：89&#x2F;26&#x3D;【3，2，2，1，3】，a0&#x3D;3，a1&#x3D;2，a2&#x3D;2，a3&#x3D;1，a4&#x3D;3。<br>可见连分数就是一个套一个，每一个都是连分数。<br>例如：</strong></p><p><img src="/img/bg/math3.jpg" alt="3"></p><p><strong>以此类推，可以得出【3，【2，2，1，3】】的连分数表达方式。<br>因此，我们可以把连分数写成：<br>【a0, a1, a2,,,,,an】&#x3D;【a0, a1,,,,am-1, 【am, am+1,,,, an】】<br>其中：1 ≦ m ≦ n<br>从而引出渐进分数的概念。<br>我们称【a0, a1,,,,am】是【a0, a1, ,,,, an】的第m级渐进分数，（0 ≦ m ≦ n）。<br>例如：<br>【3】是89&#x2F;26的0级渐进分数，【3】&#x3D;3，89&#x2F;26&#x3D;3.423……，两者的误差为0.423……<br>【3，2】是89&#x2F;26的1级渐进分数，【3，2】&#x3D;3+1&#x2F;2&#x3D;3.5，误差为0.0769……<br>【3，2，2】是89&#x2F;26的2级渐进分数，【3，2，2】&#x3D;3.4，误差为0.02307……<br>可见误差越来越小。<br>89&#x2F;26是一个有理数，如果用小数来表示，是一个无限循环小数，写出来会非常的麻烦。可如果用连分数来表示就简单多了，而且通过渐进分数不断减小表达式的误差。</strong></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#辗转相除法化为连分数形式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">x, y</span>):<br>    res = []<br>    <span class="hljs-keyword">while</span> y:<br>        res.append(x // y)  <br>        x, y = y, x % y  <br>    <span class="hljs-keyword">return</span> res  <br><br><span class="hljs-comment"># 实现连分数的逆向计算，将连分数序列转换为分数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continued_fraction</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br><br><span class="hljs-comment"># 计算连分数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub_fraction</span>(<span class="hljs-params">x, y</span>):<br>    res = transform(x, y)  <span class="hljs-comment"># 获取 x 和 y 的连分数表示</span><br>    res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(continued_fraction, (res[<span class="hljs-number">0</span>:i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(res) + <span class="hljs-number">1</span>))))  <span class="hljs-comment"># 将每一步的连分数转换为分数</span><br>    <span class="hljs-keyword">return</span> res  <span class="hljs-comment"># 返回连分数列表</span><br><br><span class="hljs-comment"># 根据韦达定理获取 p 和 q</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pq</span>(<span class="hljs-params">a, b, c</span>):<br>    par = isqrt(b * b - <span class="hljs-number">4</span> * a * c)  <br>    x1, x2 = (-b + par) // (<span class="hljs-number">2</span> * a), (-b - par) // (<span class="hljs-number">2</span> * a) <br>    <span class="hljs-keyword">return</span> x1, x2 <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params">e, n</span>):<br>    <span class="hljs-keyword">for</span> (k,d) <span class="hljs-keyword">in</span> sub_fraction(e, n):<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (e * d - <span class="hljs-number">1</span>) % k != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        phi = (e * d - <span class="hljs-number">1</span>) // k  <br>        x1, x2 = get_pq(<span class="hljs-number">1</span>, n - phi + <span class="hljs-number">1</span>, n)  <br>        <span class="hljs-keyword">if</span> x1 * x2 == n:<br>            p, q = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(x1)), <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(x2))  <span class="hljs-comment"># 取 p 和 q 的绝对值</span><br>            d = inverse_mod(e, (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>))  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;p = <span class="hljs-subst">&#123;p&#125;</span>&quot;</span>)  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;q = <span class="hljs-subst">&#123;q&#125;</span>&quot;</span>)  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;d = <span class="hljs-subst">&#123;d&#125;</span>&quot;</span>)  <br>            <span class="hljs-keyword">return</span>         <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;该方法不适用&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>注意，在这一段代码中：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">continued_fraction</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br></code></pre></td></tr></table></figure><p><strong>和最后的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params">e, n</span>):<br>    <span class="hljs-keyword">for</span> (k,d) <span class="hljs-keyword">in</span> sub_fraction(e, n):<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (e * d - <span class="hljs-number">1</span>) % k != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        phi = (e * d - <span class="hljs-number">1</span>) // k  <br>        x1, x2 = get_pq(<span class="hljs-number">1</span>, n - phi + <span class="hljs-number">1</span>, n)  <br>        <span class="hljs-keyword">if</span> x1 * x2 == n:<br>            p, q = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(x1)), <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(x2))  <span class="hljs-comment"># 取 p 和 q 的绝对值</span><br>            d = inverse_mod(e, (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>))  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;p = <span class="hljs-subst">&#123;p&#125;</span>&quot;</span>)  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;q = <span class="hljs-subst">&#123;q&#125;</span>&quot;</span>)  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;d = <span class="hljs-subst">&#123;d&#125;</span>&quot;</span>)  <br>            <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;该方法不适用&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>很多博客在for (k,d) in sub_fraction(e,n)这里会是(d,k)，或者强调说是d是分子，但是仔细分析代码发现是continued_fraction(sub_res)这个函数的返回值不一样的问题，返回的numerator对应k，denominator对应d即可（需要注意numerator和denominator的初始值为1还是0）</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="e-N-1，但是-N1-N2-P1-P2"><a href="#e-N-1，但是-N1-N2-P1-P2" class="headerlink" title="e&#x2F;N &lt;&lt; 1，但是(N1&#x2F;N2) &#x3D; (P1&#x2F;P2)2(Q1&#x2F;Q2)"></a>e&#x2F;N &lt;&lt; 1，但是(N1&#x2F;N2) &#x3D; (P1&#x2F;P2)<sup>2</sup>(Q1&#x2F;Q2)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> sympy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">&#x27;GWHT&#123;************&#125;&#x27;</span><br><br>flag1 = flag[:<span class="hljs-number">19</span>].encode()  <span class="hljs-comment">#两截flag</span><br>flag2 = flag[<span class="hljs-number">19</span>:].encode()<br><span class="hljs-keyword">assert</span>(<span class="hljs-built_in">len</span>(flag) == <span class="hljs-number">38</span>)<br><br>P1 = getPrime(<span class="hljs-number">1038</span>)<br>P2 = sympy.nextprime(P1)  <span class="hljs-comment">#p2&gt;p1</span><br><span class="hljs-keyword">assert</span>(P2 - P1 &lt; <span class="hljs-number">1000</span>)<br><br>Q1 = getPrime(<span class="hljs-number">512</span>)<br>Q2 = sympy.nextprime(Q1)  <span class="hljs-comment">#q2&gt;q1</span><br><br>N1 = P1 * P1 * Q1<br>N2 = P2 * P2 * Q2<br><br>E1 = getPrime(<span class="hljs-number">1024</span>)<br>E2 = sympy.nextprime(E1)<br><br>m1 = bytes_to_long(flag1)<br>m2 = bytes_to_long(flag2)<br><br>c1 = <span class="hljs-built_in">pow</span>(m1, E1, N1)<br>c2 = <span class="hljs-built_in">pow</span>(m2, E2, N2)<br><br><br>output = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;secret&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;N1=&#x27;</span> + <span class="hljs-built_in">str</span>(N1) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;c1=&#x27;</span> + <span class="hljs-built_in">str</span>(c1) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;E1=&#x27;</span> + <span class="hljs-built_in">str</span>(E1) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;N2=&#x27;</span> + <span class="hljs-built_in">str</span>(N2) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;c2=&#x27;</span> + <span class="hljs-built_in">str</span>(c2) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.write(<span class="hljs-string">&#x27;E2=&#x27;</span> + <span class="hljs-built_in">str</span>(E2) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>output.close()<br><br>N1=<span class="hljs-number">60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347</span><br>c1=<span class="hljs-number">55094296873556883585060020895253176070835143350249581136609315815308788255684072804968957510292559743192424646169207794748893753882418256401223641287546922358162629295622258913168323493447075410872354874300793298956869374606043622559405978242734950156459436487837698668489891733875650048466360950142617732135781244969524095348835624828008115829566644654403962285001724209210887446203934276651265377137788183939798543755386888532680013170540716736656670269251318800501517579803401154996881233025210176293554542024052540093890387437964747460765498713092018160196637928204190194154199389276666685436565665236397481709703644555328705818892269499380797044554054118656321389474821224725533693520856047736578402581854165941599254178019515615183102894716647680969742744705218868455450832</span><br>E1=<span class="hljs-number">125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820423103</span><br>N2=<span class="hljs-number">60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121</span><br>c2=<span class="hljs-number">39328446140156257571484184713861319722905864197556720730852773059147902283123252767651430278357950872626778348596897711320942449693270603776870301102881405303651558719085454281142395652056217241751656631812580544180434349840236919765433122389116860827593711593732385562328255759509355298662361508611531972386995239908513273236239858854586845849686865360780290350287139092143587037396801704351692736985955152935601987758859759421886670907735120137698039900161327397951758852875291442188850946273771733011504922325622240838288097946309825051094566685479503461938502373520983684296658971700922069426788236476575236189040102848418547634290214175167767431475003216056701094275899211419979340802711684989710130215926526387138538819531199810841475218142606691152928236362534181622201347</span><br>E2=<span class="hljs-number">125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820425393</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><ul><li><strong>wiener attack 是依靠连分数进行的攻击方式，适用于非常接近某一值（比如1）时，求一个比例关系(通常是e &#x2F; N &#x3D; 1)</strong></li><li><strong>此题中e比较大，想到维纳攻击，但题中 e &#x2F; N &lt;&lt; 1, 不符合利用条件，但是N1和N2的关系却合适</strong></li><li><strong>对于这一道题，(N1&#x2F;N2) &#x3D; (P1&#x2F;P2)<sup>2</sup>(Q1&#x2F;Q2)，显然(N1&#x2F;N2) &lt; (Q1&#x2F;Q2)</strong></li><li><strong>所以Q1&#x2F;Q2在区间(N1&#x2F;N2~1)之间，那么就可以对N1&#x2F;N2进行连分数展开并求其各项分数，其中某个连分数的分子可能就是Q1</strong></li></ul><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sympy<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continuedFra</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算连分数</span><br><span class="hljs-string">    :param x: 分子</span><br><span class="hljs-string">    :param y: 分母</span><br><span class="hljs-string">    :return: 连分数列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cf = []<br>    <span class="hljs-keyword">while</span> y:<br>        cf.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> cf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradualFra</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getGradualFra</span>(<span class="hljs-params">cf</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算列表所有的渐近分数</span><br><span class="hljs-string">    :param cf: 连分数列表</span><br><span class="hljs-string">    :return: 该列表所有的渐近分数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    gf = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(cf) + <span class="hljs-number">1</span>):<br>        gf.append(gradualFra(cf[:i]))<br>    <span class="hljs-keyword">return</span> gf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wienerAttack</span>(<span class="hljs-params">e, n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param e:</span><br><span class="hljs-string">    :param n:</span><br><span class="hljs-string">    :return: 私钥d</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cf = continuedFra(e, n)<br>    gf = getGradualFra(cf)<br>    <span class="hljs-keyword">for</span> q1,q2 <span class="hljs-keyword">in</span> gf: <br>        <span class="hljs-keyword">if</span> q1 == <span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> N2 % q2 == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q2 != <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> q2<br><br><br>N1=<span class="hljs-number">60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347</span><br>c1=<span class="hljs-number">55094296873556883585060020895253176070835143350249581136609315815308788255684072804968957510292559743192424646169207794748893753882418256401223641287546922358162629295622258913168323493447075410872354874300793298956869374606043622559405978242734950156459436487837698668489891733875650048466360950142617732135781244969524095348835624828008115829566644654403962285001724209210887446203934276651265377137788183939798543755386888532680013170540716736656670269251318800501517579803401154996881233025210176293554542024052540093890387437964747460765498713092018160196637928204190194154199389276666685436565665236397481709703644555328705818892269499380797044554054118656321389474821224725533693520856047736578402581854165941599254178019515615183102894716647680969742744705218868455450832</span><br>E1=<span class="hljs-number">125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820423103</span><br>N2=<span class="hljs-number">60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121</span><br>c2=<span class="hljs-number">39328446140156257571484184713861319722905864197556720730852773059147902283123252767651430278357950872626778348596897711320942449693270603776870301102881405303651558719085454281142395652056217241751656631812580544180434349840236919765433122389116860827593711593732385562328255759509355298662361508611531972386995239908513273236239858854586845849686865360780290350287139092143587037396801704351692736985955152935601987758859759421886670907735120137698039900161327397951758852875291442188850946273771733011504922325622240838288097946309825051094566685479503461938502373520983684296658971700922069426788236476575236189040102848418547634290214175167767431475003216056701094275899211419979340802711684989710130215926526387138538819531199810841475218142606691152928236362534181622201347</span><br>E2=<span class="hljs-number">125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820425393</span><br>Q2=wienerAttack(N1,N2)<br>Q1 = sympy.prevprime(Q2)<br>P1 = gmpy2.iroot(N1 // Q1,<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>]<br>P2 = sympy.nextprime(P1)<br>phi1 = P1 * (P1 - <span class="hljs-number">1</span>) * (Q1 - <span class="hljs-number">1</span>)<br>phi2 = P2 * (P2 - <span class="hljs-number">1</span>) * (Q2 - <span class="hljs-number">1</span>)<br>d1 = gmpy2.invert(E1,phi1)<br>d2 = gmpy2.invert(E2,phi2)<br>m1 = <span class="hljs-built_in">pow</span>(c1,d1,N1)<br>m2 = <span class="hljs-built_in">pow</span>(c2,d2,N2)<br><span class="hljs-built_in">print</span>(long_to_bytes(m1))<br><span class="hljs-built_in">print</span>(long_to_bytes(m2))<br><br><span class="hljs-comment"># b&#x27;GWHT&#123;3aadab41754799&#x27;</span><br><span class="hljs-comment"># b&#x27;f978669d53e64a3aca&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="t-≡-P-p-58-q-mod-Q-，给出t，Q，P"><a href="#t-≡-P-p-58-q-mod-Q-，给出t，Q，P" class="headerlink" title="t ≡ P(p-58) + q (mod Q)，给出t，Q，P"></a>t ≡ P(p-58) + q (mod Q)，给出t，Q，P</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><br>m=bytes_to_long(flag)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPQ</span>(<span class="hljs-params">p,q</span>):<br>    P=getPrime(<span class="hljs-number">2048</span>)<br>    Q=getPrime(<span class="hljs-number">2048</span>)<br>    t=(p*P-<span class="hljs-number">58</span>*P+q)%Q<br>    <span class="hljs-keyword">assert</span> (isPrime(Q))<br>    <span class="hljs-keyword">return</span> P,Q,t<br><br>B=getRandomNBitInteger(<span class="hljs-number">11</span>)<br>p=getPrime(B)<br>q=getPrime(B)<br>n=p*q<br>e=<span class="hljs-number">65537</span><br>c=<span class="hljs-built_in">pow</span>(m,e,n)<br>P,Q,t=getPQ(p,q)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B=&quot;</span>,B)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;P*P*Q=&quot;</span>,P*P*Q)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;P*Q*Q=&quot;</span>,P*Q*Q)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;t=&quot;</span>,t)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c=&quot;</span>,c)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1023</span><br><span class="hljs-string">17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981</span><br><span class="hljs-string">17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909</span><br><span class="hljs-string">44</span><br><span class="hljs-string">4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><ul><li><strong>P，Q很容易得出</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">PQ = gcd(PPQ,PQQ)<br>P = PPQ // PQ<br>Q = PQQ // PQ<br></code></pre></td></tr></table></figure></li><li><strong>又因为t ≡ P(p-58) + q (mod Q)</strong></li><li><strong>即t + KQ &#x3D; P(p-58) + q</strong></li><li><strong>两边同时除以Q，t&#x2F;Q ≈ 0，q&#x2F;Q ≈ 0</strong></li><li><strong>所以化简为K&#x2F;(p-58) ≈ P&#x2F;Q，对后者进行连分数展开即可得到p</strong></li></ul><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continuedFra</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算连分数</span><br><span class="hljs-string">    :param x: 分子</span><br><span class="hljs-string">    :param y: 分母</span><br><span class="hljs-string">    :return: 连分数列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cf = []<br>    <span class="hljs-keyword">while</span> y:<br>        cf.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> cf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradualFra</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getGradualFra</span>(<span class="hljs-params">cf</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算列表所有的渐近分数</span><br><span class="hljs-string">    :param cf: 连分数列表</span><br><span class="hljs-string">    :return: 该列表所有的渐近分数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    gf = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(cf) + <span class="hljs-number">1</span>):<br>        gf.append(gradualFra(cf[:i]))<br>    <span class="hljs-keyword">return</span> gf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wienerAttack</span>(<span class="hljs-params">e, n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param e:</span><br><span class="hljs-string">    :param n:</span><br><span class="hljs-string">    :return: 私钥d</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cf = continuedFra(e, n)<br>    gf = getGradualFra(cf)<br>    <span class="hljs-keyword">for</span> _,p_58 <span class="hljs-keyword">in</span> gf: <br>        <span class="hljs-keyword">if</span> isPrime(p_58 + <span class="hljs-number">58</span>) <span class="hljs-keyword">and</span> (p_58 + <span class="hljs-number">58</span>).bit_length() == <span class="hljs-number">1023</span>:<br>            <span class="hljs-keyword">return</span> p_58 + <span class="hljs-number">58</span><br><br><br>P = <span class="hljs-number">25947339118736016261419550658264175914664266822085997909314096786508816404704696671837899420298768803641977765786592354116676036035881712512184992851487828263900367476619650087372125353190561974783134059421570649293920248116730478378196277387377082481961542018611824082110164117796622604412648512092528479878502094797494405077897059911764470830302447618882229233093021156725194893124743848364119720591518073753197359351271987724752861168913839307431377592888760273762302003490303315903644695784992125784390012046834505490167165377346036077504298195544062111718133371983287540723388743607671934081891907851056034062109</span><br>Q = <span class="hljs-number">26068172028162605137516470004551766376185367701690988148920400408760716114172673253571631718337447931195718779018987169967053546674529251665443499183399035216407895285607965767100708187327533611193709308966698251023076404422362272378862918994525181107002728889256377161661579892599243396304207048944032235378667269998644227976609632271355152717352269223310163307304914315780234040829575689991453848537587516055955657960061856059046256125836544109066275645648666876772298883460637600522819402448386193499472702636751025558486665290530268273787746964353937663176851849214999005525738643454160169651485201028944583316101</span><br>p=wienerAttack(P,Q)<br>q = ((<span class="hljs-number">58</span> - p) * P +<span class="hljs-number">44</span>) % Q<br>c=<span class="hljs-number">4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746</span><br>e=<span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e,phi)<br>m = long_to_bytes(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">pow</span>(c,d,p * q)))<br><span class="hljs-built_in">print</span>(m)<br><span class="hljs-comment"># DASCTF&#123;8f3djoj9wedj2_dkc903cwckckdk&#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意，在这里m &lt; p，所以直接用p算可以得到flag<br>还有一种解法，可以通过构造格来解(还没学会，转载一下原文写法)<br>P,Q 2048bits，p，q大概是1200多bits</strong></p><p><img src="/img/bg/math4.jpg" alt=" "></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>B=<span class="hljs-number">1023</span><br>PPQ=<span class="hljs-number">17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981</span><br>PQQ=<span class="hljs-number">17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909</span><br>t=<span class="hljs-number">44</span><br>c=<span class="hljs-number">4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746</span><br>PQ = gcd(PPQ,PQQ)<br>P = PPQ // PQ<br>Q = PQQ // PQ<br><span class="hljs-built_in">print</span>(P)<br><span class="hljs-built_in">print</span>(Q)<br>e=<span class="hljs-number">65537</span><br>mat = [[<span class="hljs-number">1</span>,P],[<span class="hljs-number">0</span>,Q]]<br>m = matrix(ZZ,mat)<br>p_58,t_q = m.LLL()[<span class="hljs-number">0</span>]<br>p_58 = <span class="hljs-built_in">abs</span>(p_58)<br>t_q = <span class="hljs-built_in">abs</span>(t_q)<br>p = p_58 + <span class="hljs-number">58</span><br>q = t_q + t<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e,phi)<br>m = long_to_bytes(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">pow</span>(c,d,p * q)))<br><span class="hljs-built_in">print</span>(m)<br></code></pre></td></tr></table></figure><hr><h3 id="已知n，e，d-求p，q"><a href="#已知n，e，d-求p，q" class="headerlink" title="已知n，e，d,求p，q"></a>已知n，e，d,求p，q</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *<br><br>gift = <span class="hljs-number">0x98efa1cac6d4a1031759ddfb2cb2a1361b76a0327802e5b99e2f98a1a410705fe93f36979441c6b5eab2737bacc66565d425c56c434d04cbc2b3d756d264995f8b198d6887ec2dddfa640d88932604115d80a9f1f0d18538a738016292057518e02b8520d1322f2cc8c500438d24e041ef9d3e70244e327e28d03c371b7d119a387bf7dfaf7b1ad89ce68f0bdf5858d961b48a6080c589a7e5ac9505cb3893510670299d2f4570acca050e26f828056a4276387b69f64a1498552754ede89e21a1c4a5e0754b41aa2c17823b6d84666896d865c9627a3be5cb8ede76461b44f7ed2398cb29f52073f23c5b0b5ac1af048d310ddec9b683ae0535670195ea510012eb16fb60186a5c26f6c516addeade9bed3dea308fc9196de5b5e99b8f8354b9116995dffb350b5b71ee8ae21b776e122508bf4acd8c9c69bb67a8003291b9a217301656ff332d6802db63605aee2a881e0ddf08904e5c8ace0cd44bffdeee7b10e1b5d868b25ddb1248802c7341267f9862b9319cbaada6d7b557425273256505470d2d610232c00d53475693db249299594ee62271589ec4ebd92c0f37d05ca24c556948dd30b3e6b124f059e4776ef219766e805bf7b1003734172e8d2cda130966bd6c5643071efef3e39bc11f6bdfef4ba6e9fa450f7605bcf9ca22c5f12fdec2f8b3ead07a34a427e3602792939873a2481a8dd0e454305b5ce374a77</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_gift</span>(<span class="hljs-params">p, q</span>):<br>    n_bits = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(p * q)) - <span class="hljs-number">2</span><br>    phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>    r = randint(<span class="hljs-number">11</span>, <span class="hljs-number">111</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        a = getPrime(n_bits // <span class="hljs-number">4</span> - r)<br>        <span class="hljs-keyword">if</span> gcd(a, phi) != <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br>        b = invert(a, phi)<br>        e = invert(b, gift)<br>        <span class="hljs-keyword">if</span> gcd(e, phi) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>    d = invert(e, phi)<br>    <span class="hljs-keyword">return</span> (e, d)<br><br>p = getPrime(<span class="hljs-number">2048</span>)<br>q = getPrime(<span class="hljs-number">2048</span>)<br>n = p * q<br>e, d = make_gift(p, q)<br>c = <span class="hljs-built_in">pow</span>(bytes_to_long(flag), e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n:&quot;</span>, <span class="hljs-built_in">hex</span>(n))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;e:&quot;</span>, <span class="hljs-built_in">hex</span>(e))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c:&quot;</span>, <span class="hljs-built_in">hex</span>(c))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n: 0xf5da802f4a0d148a957254c9287bf1515c81088416067574fb614342d15757b84014125fa9b0b2e8158a7321a0bcde32c6b98abede5da9e526dd2e67c148f89ac0787fa55dd2a2922bc0595e67cb347ab923ee251b1e7c395706a8956335032914f152fe30556feb48592be713c120186266a085a96dee08d86283362dd2593c0df06d83050ad7d3ce5a0ae482b32800a80f66f5d8bfa306b365faec72f4cfc02846c222602a660bd024c8b05055ee824a7a14d6c3d1227ecff1c5b95016ba4ac82f3d493c51ba5e07f3d220ec633358165c97062ffe35abba6745cb7e9182aade6f867fe1ade89515ef61e1c20f08b81b19afbc09be357b2cb328fbb341408bc2ac3fbd66ab7eb7470123e8bea12c3f46082c1f37dd9eb9716d2fe92c090b63f64b8fe3e456f08ced64068e9232309c1d71f9723a2cdf643aa3eca2c0d5fcb1ffe95f9c25bd090ea94f408411e1e030016a91b024eba077fd709d69feec798a86160b921fdc058a5d6b041997737789cd4afbab4a92a80f53152ef4c6cfed432de2bf5c1cb53e33cbed6776a1f7ea4b543f688f34c7765eb441246fdccd34f0c07dca305649375d59f62087d5b2bb863f1fc6d74fe47ab1e8cbf948473e7bc08d6bb8801518d908548624a6eea403ac7ec8531920bbb319681887e70fe1c67def9a431e3ed342fae3fe4bbed35f3081ffe54b8d41409a9d017963ceb1261745</span><br><span class="hljs-string">e: 0x324029b96d92446e3315b04d321db7228b30a3d0f0be3d16b7356b4259bf54e9203756fbb08713b88dbdc4986cc7ca676888f7b286b648028428af30175f4568d6443ba8f3a96a168fbe60a71addaf63b307e619c1047c24c88f2619c54b565a20fb066639c74bd7187f66e641384acca5dd59ae652873ebf715de7e1ccaa13187377e1a3c2f7ef2a3607a03bd216ef34ba3788bdb4a23b2a0ae158282c773e19635494907f65798e2a8927d6df96a4eb24ff3b40689d8ea4a82587d6dc7a268e5094c049e2321689c9d0f3fe6e261642970946d7454911518198b6e3cf7227a8e5467a6efa2ffff369307121216c65670e1319cfa20da72b4b5f5cd4a2115f360d9da94b84469466ca886d30184059dec26caca654e601c62c17b33dc30dcd66e1b89578267df7cbc4fe5270b72a23861d54426e86e3dfd7a6ae5a38168229d3f6352dfcd3d21674f349af741cc6a858a3e67c55329fb8c0fd21fb50fd2c3174b0ec2e365b0a0f444de1759ecb98a56dbd7830401e663782a564b4de2208606bee3aa98e0970d6f7cdf923c12852caaf86ef75ff438b1879da69b30564fcc7cc9aa38691ce1353fec995eaf4b8d97792b4f627bb7b631ec0dfcf8ee9333f592462ca6f16e99ef5ecece276c25ddb57b03f87266be0038bc78d374161bb8f558b8fca419a7716c984499bf17832ea2eb2e68fd4118fdb2e5a6d49d08dba0db69</span><br><span class="hljs-string">c: 0x5951976397efab4db75cecd1d669f64e31da28c82f383b920fe83a1b99a913d1cb60db9d5fc58795ae011a5c5949cc0b1f53ce28e1505aad93a5ffc9e71418f32aff300ff7d9d5de83c5f53535ea6f25bbc31b56bb7f785d95edf10672bb458f6dba81acc3fd9c2de79506ea7520068b17018359642f34c365580a8e200d411f5a80f38b673706b365f0e6d2e6fb3732208acc0ab64e6159310f8fe4076f9cff17192cb8cbf37c0278e5772c1ac7c80314fc8ec6eaa39852a8e67c5592a5d87dd406e189c19c8db635f8d50e48051dc6e29d1d52e233a490cb53e1d1a592fd3883ef25f02beaf90eb4323a6e3b37c814969689c11e696422125ccd7f8a2e4fcb5276784f1d2cb5aaa2b5a5944f6330684c1c9b9c8da6ca25b18b4024d6e859014ed488643193fe1f8a4b7fdc94ad59965e00cc6cfcbb123a04c13bacbfdf2a3fc240d08c416cbb0acfaa416c81aa351c43ab62020ab39ffa3d2ccde402cb7afbde6dcb61ad0270c44560dced8eb70ae6eeb4c3c092428e94fcf334afab39e10eb1a48a02444358d32ca2ebee3045b473c3b7f9629bbce56d599969c2e2e43d6c2d10079c0e7358f5e944020f77d5f79f6cf78952434cc038ffdadccc6ef1e88f0b8cf6cfe1a6b3f0f5ac1492b387c1dc29f6624f6b20fa86c0ed5d71296275df3388467680bf5208afbb39277045f0dd6a3230418e8220ee7a213888a712d682</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><ul><li><strong>已知e &#x3D; invert(b，gift) &#x3D;&gt; b &#x3D; invert(e，gift)</strong></li><li><strong>又因为a*b ≡ 1 (mod phi)，a，b都很大，可以想到维纳攻击（把b看成e，a看成d）</strong></li><li><strong>维纳攻击有一个条件d &lt; (1&#x2F;3)N<sup>1&#x2F;4</sup>，恰巧代码中有一行a &#x3D; getPrime(n_bits &#x2F;&#x2F; 4 - r)</strong></li><li><strong>维纳攻击后得到a，那就相当于得到了n，e（实际是a），d（实际是b）,还要求p，q</strong></li><li><strong>有一个算法<a href="https://www.cnblogs.com/meancoder/p/RSA-given-e-d-n-factorize-n.html">已知n，e，d,求p，q</a>，解出p，q后就是简单RSA了</strong></li></ul><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continuedFra</span>(<span class="hljs-params">x, y</span>):<br>    cf = []<br>    <span class="hljs-keyword">while</span> y:<br>        cf.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> cf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradualFra</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getGradualFra</span>(<span class="hljs-params">cf</span>):<br>    gf = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(cf) + <span class="hljs-number">1</span>):<br>        gf.append(gradualFra(cf[:i]))<br>    <span class="hljs-keyword">return</span> gf<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wienerAttack</span>(<span class="hljs-params">e, n</span>):<br>    cf = continuedFra(e, n)<br>    gf = getGradualFra(cf)<br>    n_bits = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(n)) - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> _,a <span class="hljs-keyword">in</span> gf: <br>        <span class="hljs-keyword">if</span>  a.bit_length() &lt; (n_bits // <span class="hljs-number">4</span> - <span class="hljs-number">11</span>) <span class="hljs-keyword">and</span> a.bit_length() &gt; (n_bits // <span class="hljs-number">4</span> - <span class="hljs-number">111</span>) <span class="hljs-keyword">and</span> isPrime(a):<br>            <span class="hljs-keyword">return</span> a<br><br>n=<span class="hljs-number">0xf5da802f4a0d148a957254c9287bf1515c81088416067574fb614342d15757b84014125fa9b0b2e8158a7321a0bcde32c6b98abede5da9e526dd2e67c148f89ac0787fa55dd2a2922bc0595e67cb347ab923ee251b1e7c395706a8956335032914f152fe30556feb48592be713c120186266a085a96dee08d86283362dd2593c0df06d83050ad7d3ce5a0ae482b32800a80f66f5d8bfa306b365faec72f4cfc02846c222602a660bd024c8b05055ee824a7a14d6c3d1227ecff1c5b95016ba4ac82f3d493c51ba5e07f3d220ec633358165c97062ffe35abba6745cb7e9182aade6f867fe1ade89515ef61e1c20f08b81b19afbc09be357b2cb328fbb341408bc2ac3fbd66ab7eb7470123e8bea12c3f46082c1f37dd9eb9716d2fe92c090b63f64b8fe3e456f08ced64068e9232309c1d71f9723a2cdf643aa3eca2c0d5fcb1ffe95f9c25bd090ea94f408411e1e030016a91b024eba077fd709d69feec798a86160b921fdc058a5d6b041997737789cd4afbab4a92a80f53152ef4c6cfed432de2bf5c1cb53e33cbed6776a1f7ea4b543f688f34c7765eb441246fdccd34f0c07dca305649375d59f62087d5b2bb863f1fc6d74fe47ab1e8cbf948473e7bc08d6bb8801518d908548624a6eea403ac7ec8531920bbb319681887e70fe1c67def9a431e3ed342fae3fe4bbed35f3081ffe54b8d41409a9d017963ceb1261745</span><br>e=<span class="hljs-number">0x324029b96d92446e3315b04d321db7228b30a3d0f0be3d16b7356b4259bf54e9203756fbb08713b88dbdc4986cc7ca676888f7b286b648028428af30175f4568d6443ba8f3a96a168fbe60a71addaf63b307e619c1047c24c88f2619c54b565a20fb066639c74bd7187f66e641384acca5dd59ae652873ebf715de7e1ccaa13187377e1a3c2f7ef2a3607a03bd216ef34ba3788bdb4a23b2a0ae158282c773e19635494907f65798e2a8927d6df96a4eb24ff3b40689d8ea4a82587d6dc7a268e5094c049e2321689c9d0f3fe6e261642970946d7454911518198b6e3cf7227a8e5467a6efa2ffff369307121216c65670e1319cfa20da72b4b5f5cd4a2115f360d9da94b84469466ca886d30184059dec26caca654e601c62c17b33dc30dcd66e1b89578267df7cbc4fe5270b72a23861d54426e86e3dfd7a6ae5a38168229d3f6352dfcd3d21674f349af741cc6a858a3e67c55329fb8c0fd21fb50fd2c3174b0ec2e365b0a0f444de1759ecb98a56dbd7830401e663782a564b4de2208606bee3aa98e0970d6f7cdf923c12852caaf86ef75ff438b1879da69b30564fcc7cc9aa38691ce1353fec995eaf4b8d97792b4f627bb7b631ec0dfcf8ee9333f592462ca6f16e99ef5ecece276c25ddb57b03f87266be0038bc78d374161bb8f558b8fca419a7716c984499bf17832ea2eb2e68fd4118fdb2e5a6d49d08dba0db69</span><br>c=<span class="hljs-number">0x5951976397efab4db75cecd1d669f64e31da28c82f383b920fe83a1b99a913d1cb60db9d5fc58795ae011a5c5949cc0b1f53ce28e1505aad93a5ffc9e71418f32aff300ff7d9d5de83c5f53535ea6f25bbc31b56bb7f785d95edf10672bb458f6dba81acc3fd9c2de79506ea7520068b17018359642f34c365580a8e200d411f5a80f38b673706b365f0e6d2e6fb3732208acc0ab64e6159310f8fe4076f9cff17192cb8cbf37c0278e5772c1ac7c80314fc8ec6eaa39852a8e67c5592a5d87dd406e189c19c8db635f8d50e48051dc6e29d1d52e233a490cb53e1d1a592fd3883ef25f02beaf90eb4323a6e3b37c814969689c11e696422125ccd7f8a2e4fcb5276784f1d2cb5aaa2b5a5944f6330684c1c9b9c8da6ca25b18b4024d6e859014ed488643193fe1f8a4b7fdc94ad59965e00cc6cfcbb123a04c13bacbfdf2a3fc240d08c416cbb0acfaa416c81aa351c43ab62020ab39ffa3d2ccde402cb7afbde6dcb61ad0270c44560dced8eb70ae6eeb4c3c092428e94fcf334afab39e10eb1a48a02444358d32ca2ebee3045b473c3b7f9629bbce56d599969c2e2e43d6c2d10079c0e7358f5e944020f77d5f79f6cf78952434cc038ffdadccc6ef1e88f0b8cf6cfe1a6b3f0f5ac1492b387c1dc29f6624f6b20fa86c0ed5d71296275df3388467680bf5208afbb39277045f0dd6a3230418e8220ee7a213888a712d682</span><br>gift = <span class="hljs-number">0x98efa1cac6d4a1031759ddfb2cb2a1361b76a0327802e5b99e2f98a1a410705fe93f36979441c6b5eab2737bacc66565d425c56c434d04cbc2b3d756d264995f8b198d6887ec2dddfa640d88932604115d80a9f1f0d18538a738016292057518e02b8520d1322f2cc8c500438d24e041ef9d3e70244e327e28d03c371b7d119a387bf7dfaf7b1ad89ce68f0bdf5858d961b48a6080c589a7e5ac9505cb3893510670299d2f4570acca050e26f828056a4276387b69f64a1498552754ede89e21a1c4a5e0754b41aa2c17823b6d84666896d865c9627a3be5cb8ede76461b44f7ed2398cb29f52073f23c5b0b5ac1af048d310ddec9b683ae0535670195ea510012eb16fb60186a5c26f6c516addeade9bed3dea308fc9196de5b5e99b8f8354b9116995dffb350b5b71ee8ae21b776e122508bf4acd8c9c69bb67a8003291b9a217301656ff332d6802db63605aee2a881e0ddf08904e5c8ace0cd44bffdeee7b10e1b5d868b25ddb1248802c7341267f9862b9319cbaada6d7b557425273256505470d2d610232c00d53475693db249299594ee62271589ec4ebd92c0f37d05ca24c556948dd30b3e6b124f059e4776ef219766e805bf7b1003734172e8d2cda130966bd6c5643071efef3e39bc11f6bdfef4ba6e9fa450f7605bcf9ca22c5f12fdec2f8b3ead07a34a427e3602792939873a2481a8dd0e454305b5ce374a77</span><br><br>b = invert(e,gift)<br><br>a = wienerAttack(b,n)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide_pq</span>(<span class="hljs-params">e, d, n</span>):<br>    k = e*d - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        g = random.randint(<span class="hljs-number">2</span>, n-<span class="hljs-number">1</span>)<br>        t = k<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> t % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            t //= <span class="hljs-number">2</span><br>            x = <span class="hljs-built_in">pow</span>(g, t, n)<br>            <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> gcd(x-<span class="hljs-number">1</span>, n) &gt; <span class="hljs-number">1</span>:<br>                p = gcd(x-<span class="hljs-number">1</span>, n)<br>                <span class="hljs-keyword">return</span> (p, n//p)<br><br>p,q = divide_pq(a,b,n)<br>d = inverse(e,(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(long_to_bytes(<span class="hljs-built_in">pow</span>(c,d,n)))<br><span class="hljs-comment"># flag&#123;W1nn3r_4tt4ck_1s_0k_!&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="已知n，d，求e"><a href="#已知n，d，求e" class="headerlink" title="已知n，d，求e"></a>已知n，d，求e</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> invert<br><span class="hljs-keyword">from</span> md5 <span class="hljs-keyword">import</span> md5<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> p, q<br><br>e = ?????<br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>ans = gcd(e,phi)<br><br><span class="hljs-built_in">print</span> n, e, d<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Flag: DASCTF&#123;%s&#125;&quot;</span> %md5(<span class="hljs-built_in">str</span>(p + q)).hexdigest()<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="hljs-string">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><p><img src="/img/bg/math5.jpg" alt=" "></p><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">continuedFra</span>(<span class="hljs-params">x, y</span>):<br>    cf = []<br>    <span class="hljs-keyword">while</span> y:<br>        cf.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> cf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradualFra</span>(<span class="hljs-params">sub_res</span>):<br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:<br>        denominator, numerator = numerator, i * numerator + denominator  <span class="hljs-comment"># 计算新的分子和分母</span><br>    <span class="hljs-keyword">return</span> numerator, denominator  <span class="hljs-comment"># 返回分数形式的结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getGradualFra</span>(<span class="hljs-params">cf</span>):<br>    gf = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(cf) + <span class="hljs-number">1</span>):<br>        gf.append(gradualFra(cf[:i]))<br>    <span class="hljs-keyword">return</span> gf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wienerAttack</span>(<span class="hljs-params">d, n</span>):<br>    cf = continuedFra(d, n)<br>    gf = getGradualFra(cf)<br>    <span class="hljs-keyword">for</span> k,e <span class="hljs-keyword">in</span> gf: <br>        <span class="hljs-keyword">if</span> e == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (e * d - <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(k)<br>            <span class="hljs-built_in">print</span>(e)<br>            p_q = n + <span class="hljs-number">1</span> - (e * d - <span class="hljs-number">1</span>) // k<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;p + q =&#x27;</span>, p_q)<br><br>n = <span class="hljs-number">80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br>d = <span class="hljs-number">14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br>a = wienerAttack(d,n)<br></code></pre></td></tr></table></figure><hr><h3 id="直接给出小数形式"><a href="#直接给出小数形式" class="headerlink" title="直接给出小数形式"></a>直接给出小数形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br> <br>flag = <span class="hljs-string">b&#x27;--hidden_message--&#x27;</span><br>data1 = getPrime(<span class="hljs-number">256</span>)<br>data2 = getPrime(<span class="hljs-number">256</span>)<br>m = bytes_to_long(flag)+data2<br>prec = <span class="hljs-number">600</span><br>ring = RealField(prec)<br>data3 = ring(data1) / ring(data2)<br><span class="hljs-built_in">print</span>(data3)<br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    p = randint(<span class="hljs-number">2</span>**<span class="hljs-number">255</span>, data1)<br>    q = randint(<span class="hljs-number">2</span>**<span class="hljs-number">255</span>, data2)<br>    <span class="hljs-keyword">if</span> isPrime(p) <span class="hljs-keyword">and</span> isPrime(q) <span class="hljs-keyword">and</span> p!=q:<br>        <span class="hljs-keyword">break</span><br> <br>n = p*q<br>e = <span class="hljs-number">65537</span><br>leak = <span class="hljs-built_in">pow</span>(p-q, data1, data1*data2)<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-built_in">print</span>(leak)<br> <br> <br> <br>data3 = <span class="hljs-number">1.42870767357206600351348423521722279489230609801270854618388981989800006431663026299563973511233193052826781891445323183272867949279044062899046090636843802841647378505716932999588</span><br>c = <span class="hljs-number">1046004343125860480395943301139616023280829254329678654725863063418699889673392326217271296276757045957276728032702540618505554297509654550216963442542837</span><br>n = <span class="hljs-number">2793178738709511429126579729911044441751735205348276931463015018726535495726108249975831474632698367036712812378242422538856745788208640706670735195762517</span><br>leak = <span class="hljs-number">1788304673303043190942544050868817075702755835824147546758319150900404422381464556691646064734057970741082481134856415792519944511689269134494804602878628</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><ul><li><strong>d直接给出了data3 &#x3D; data1&#x2F;data2，小数形式，可以直接取其连分数获得data1和data2</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sage">#sage代码<br>data3=1.42870767357206600351348423521722279489230609801270854618388981989800006431663026299563973511233193052826781891445323183272867949279044062899046090636843802841647378505716932999588<br><br>c = continued_fraction(data3)<br>alist = c.convergents()<br>for i in alist:<br>    a = str(i).split(&#x27;/&#x27;)<br>    if len(a)&gt;1 and gcd(int(a[0]),int(a[1])) == 1 and is_prime(int(a[0])) and is_prime(int(a[1])) and int(a[0]).bit_length()==256 and int(a[1]).bit_length()==256:<br>            print(a)<br>#[&#x27;97093002077798295469816641595207740909547364338742117628537014186754830773717&#x27;,&#x27;67958620138887907577348085925738704755742144710390414146201367031822084270769&#x27;]<br></code></pre></td></tr></table></figure></li><li><strong>然后就是求解p，q</strong></li><li><strong>leak &#x3D; (p-q)<sup>data1</sup> (mod data1*data2)</strong></li><li><strong>(p-q)<sup>data1</sup> ≡ leak (mod data1)</strong></li><li><strong>p - q ≡ leak (mod data1)，所以解方程就可以得到p，q</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sympy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> inverse,long_to_bytes<br>data1 = <span class="hljs-number">97093002077798295469816641595207740909547364338742117628537014186754830773717</span><br>data2 = <span class="hljs-number">67958620138887907577348085925738704755742144710390414146201367031822084270769</span><br>n=<span class="hljs-number">2793178738709511429126579729911044441751735205348276931463015018726535495726108249975831474632698367036712812378242422538856745788208640706670735195762517</span><br>leak=<span class="hljs-number">1788304673303043190942544050868817075702755835824147546758319150900404422381464556691646064734057970741082481134856415792519944511689269134494804602878628</span><br>leak1=leak%data1<br>p,q = sympy.symbols(<span class="hljs-string">&quot;p q&quot;</span>)  <br>h = sympy.solve([p*q-n,p-q-leak1],[p,q])<br>p=h[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>q=h[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(p,q)<br><span class="hljs-comment">#89050782851818876669770322556796705712770640993210984822169118425068336611139 31366133449465349655535843217834713141354178841659172525867412449648339136903</span><br></code></pre></td></tr></table></figure><strong>p，q得到后就是正常RSA解密</strong></li></ul><hr><p><strong>参考文章<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130515028">RSA–维纳攻击–代码和题目分析</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>RSA算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Franklin-Reiter相关消息攻击</title>
    <link href="/2024/02/22/Franklin-Reiter%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2024/02/22/Franklin-Reiter%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Franklin-Reiter相关消息攻击"><a href="#Franklin-Reiter相关消息攻击" class="headerlink" title="Franklin-Reiter相关消息攻击"></a>Franklin-Reiter相关消息攻击</h1><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><p><strong>m1和m2两个明文存在线性关系如 M<sub>1</sub> ≡ F(M<sub>2</sub>) (mod n)，其中F表示类似于ax+b的线性关系，且都在相同的e和n下加密</strong></p><h2 id="解密原理"><a href="#解密原理" class="headerlink" title="解密原理"></a>解密原理</h2><p><strong>首先,我们知道C<sub>1</sub> ≡ M<sub>1</sub><sup>e</sup>(mod n)，并且M<sub>1</sub> ≡ F(M<sub>2</sub>)(mod n)，那么我们可以知道M<sub>2</sub>是F(x)<sup>e</sup> ≡ C<sub>1</sub>(mod n)的一个根。同样的M<sub>2</sub>是x<sup>e</sup> - C<sub>2</sub>在模n意义下的一个根。所以说x - M<sub>2</sub>同时整除以上两个多项式。因此我们可以求得以上两个多项式的最大公因子，如果最大公因子恰好是线性的话，那么我们就求得了M<sub>2</sub>。需要注意的是当 e&#x3D;3 的情况下，最大公因子一定是线性的。</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="m1-a-m2-b，c1-pow-m1-e-n-，c2-pow-m2-e-n"><a href="#m1-a-m2-b，c1-pow-m1-e-n-，c2-pow-m2-e-n" class="headerlink" title="m1&#x3D;a*m2+b，c1&#x3D;pow(m1,e,n)，c2&#x3D;pow(m2,e,n)"></a>m1&#x3D;a*m2+b，c1&#x3D;pow(m1,e,n)，c2&#x3D;pow(m2,e,n)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n=<span class="hljs-number">51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span><br>a=<span class="hljs-number">13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span><br>b=<span class="hljs-number">12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span><br>c1=<span class="hljs-number">18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span><br>c2=<span class="hljs-number">14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span><br>e=<span class="hljs-number">17</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">franklinReiter</span>(<span class="hljs-params">n,e,c1,c2,a,b</span>):<br>    x = PolynomialRing(Zmod(n),<span class="hljs-string">&#x27;x&#x27;</span>).gen()<br>    g1 = (x)**e - c1<br>    g2 = (a*x+b)**e - c2<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">g1, g2</span>):<br>        <span class="hljs-keyword">while</span> g2:<br>            g1, g2 = g2, g1 % g2<br>        <span class="hljs-keyword">return</span> g1.monic() <span class="hljs-comment"># </span><br>    <span class="hljs-keyword">return</span> -gcd(g1, g2)[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">使用辗转相除法求多项式的最大公因子</span><br><span class="hljs-string">在代数中，一个多项式的首项系数通常被称为该多项式的引导系数（leading coefficient），而将多项式变成首项系数为1的形式被称为将多项式化为首一形式（monic form）</span><br><span class="hljs-string">调用函数g1.monic()将g1转换为首一多项式（monic polynomial），并返回该多项式。</span><br><span class="hljs-string">使用g.monic()[0]，则会返回g(x)除以引导系数后得到的多项式的常数项</span><br><span class="hljs-string">比如：g.monic() = x + 32412345</span><br><span class="hljs-string">那么：g.monic()[0] = 32412345</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>m=franklinReiter(n,e,c1,c2,a,b)<br><span class="hljs-built_in">print</span>(long_to_bytes(<span class="hljs-built_in">int</span>(m)))<br><span class="hljs-comment"># flag&#123;a593591a-3749-cc52-0c27-e897fac2c967&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="c1-pow-2m-3-17-n-c2-pow-4m-11-17-n"><a href="#c1-pow-2m-3-17-n-c2-pow-4m-11-17-n" class="headerlink" title="c1 &#x3D; pow(2m+3,17,n) c2 &#x3D; pow(4m+11,17,n)"></a>c1 &#x3D; pow(2m+3,17,n) c2 &#x3D; pow(4m+11,17,n)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime,bytes_to_long,long_to_bytes<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag, x, y<br><br>m = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br>n = p*q<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-keyword">assert</span>(reduce(<span class="hljs-keyword">lambda</span> x,y:x&amp;y,[(i-<span class="hljs-number">5</span>)*i+<span class="hljs-number">6</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]))<br><span class="hljs-keyword">assert</span>(reduce(<span class="hljs-keyword">lambda</span> x,y:x&amp;y,[(j-<span class="hljs-number">15</span>)*j+<span class="hljs-number">44</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> y]))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(reduce(<span class="hljs-keyword">lambda</span> x,y:x*m+y,x),<span class="hljs-number">17</span>,n))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(reduce(<span class="hljs-keyword">lambda</span> x,y:x*m+y,y),<span class="hljs-number">17</span>,n))<br><br><span class="hljs-comment"># n = 23772599983135215481563178266884362291876571759991288577057472733374903836591330410574958472090396886895304944176208711481780781286891334062794555288959410390926474473859289842654809538435377431088422352076225067494924657598298955407771484146155998883073439266427190212827600119365643065276814044272790573450938596830336430371987561905132579730619341196199420897034988685012777895002554746080384319298123154671447844799088258541911028041717897434816921424155687677867019535399434825468160227242441375503664915265223696139025407768146464383537556265875013085702422829200814612395116961538432886116917063119749068212699</span><br><span class="hljs-comment"># c1 = 10900151504654409767059699202929100225155892269473271859207513720755903691031362539478242920144073599515746938827937863835169270383721094542639011665235593065932998091574636525973099426040452626893461449084383663453549354608769727777329036059746386523843912382289597182615339786437186169811342356085836838520978047561127661777189045888648773949147220411427306098338616422692914110656004863767719312410906124366000507952960331116878197129010412361636679449281808407214524741732730279777729251515759320442591663641984363061618865267606007355576230009922421807527598213455112981354590909603317525854070358390622096569841</span><br><span class="hljs-comment"># c2 = 17298679220717326374674940612143058330715465693318467692839033642321129433471254547497087746971317567301086124779289015934582615377165560688447452762043163082394944604062014490446763247008217251611443338103074143809936437694543761369945095202092750900940979469994907399829695696313513303922266742415376818434932335640062684245008822643258497589196668426788916969378417960200705779461808292296450298558001909603602502604228973101048082095642290047196235959438278631661658312398313171590515776453711432353011579809351076532129444735206408591345372296372378396539831385036814349328459266432393612919118094115543053115450</span><br></code></pre></td></tr></table></figure><p><strong>题目分析</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span>(reduce(<span class="hljs-keyword">lambda</span> x,y:x&amp;y,[(i-<span class="hljs-number">5</span>)*i+<span class="hljs-number">6</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]))<br></code></pre></td></tr></table></figure><ol><li>[(i-5)*i+6&#x3D;&#x3D;0 for i in x] 使用列表推导式判断等式是否成立，若成立，返回True，否则False,故列表中最终得到的是[True,True]，</li><li>由此可以反推出x &#x3D; [2,3] (解方程得到)，显然也可以知道下一串中y &#x3D; [4,11]</li><li>reduce函数是应用lambda表达式对列表([True,True])中的每一个元素依次进行异或操作</li><li>PS：“lambda x,y:x&amp;y”中的‘x’与“[(i-5)*i+6&#x3D;&#x3D;0 for i in x]”中的‘x’并不是同一个</li></ol><p>所以能够得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">4</span>,<span class="hljs-number">11</span>]<br></code></pre></td></tr></table></figure><p>看reduce函数，举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>result = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, x)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><ol><li>初始时，reduce 函数将列表中的第一个元素 1 作为初始的累积结果 x。</li><li>然后，对于列表中的每个元素 y，都将当前的累积结果 x 和该元素 y 传递给匿名函数 lambda x, y: x * y 进行积累操作。</li><li>第一次迭代中，x 是 1，y 是 2，所以累积结果是 1 * 2 &#x3D; 2。</li><li>第二次迭代中，x 是 2（上一次的累积结果），y 是 3（列表中的下一个元素），所以累积结果是 2 * 3 &#x3D; 6。</li><li>第三次迭代中，x 是 6，y 是 4，所以累积结果是 6 * 4 &#x3D; 24。</li></ol><p>所以题目中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(<span class="hljs-keyword">lambda</span> x,y:x*m+y,x) = <span class="hljs-number">2</span>*m+<span class="hljs-number">3</span><br>reduce(<span class="hljs-keyword">lambda</span> x,y:x*m+y,y) = <span class="hljs-number">4</span>*m+<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>最终得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">c1 = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>*m+<span class="hljs-number">3</span>,<span class="hljs-number">17</span>,n)<br>c2 = <span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>*m+<span class="hljs-number">11</span>,<span class="hljs-number">17</span>,n)<br></code></pre></td></tr></table></figure><p><strong>解题代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">23772599983135215481563178266884362291876571759991288577057472733374903836591330410574958472090396886895304944176208711481780781286891334062794555288959410390926474473859289842654809538435377431088422352076225067494924657598298955407771484146155998883073439266427190212827600119365643065276814044272790573450938596830336430371987561905132579730619341196199420897034988685012777895002554746080384319298123154671447844799088258541911028041717897434816921424155687677867019535399434825468160227242441375503664915265223696139025407768146464383537556265875013085702422829200814612395116961538432886116917063119749068212699</span><br>c1 = <span class="hljs-number">10900151504654409767059699202929100225155892269473271859207513720755903691031362539478242920144073599515746938827937863835169270383721094542639011665235593065932998091574636525973099426040452626893461449084383663453549354608769727777329036059746386523843912382289597182615339786437186169811342356085836838520978047561127661777189045888648773949147220411427306098338616422692914110656004863767719312410906124366000507952960331116878197129010412361636679449281808407214524741732730279777729251515759320442591663641984363061618865267606007355576230009922421807527598213455112981354590909603317525854070358390622096569841</span><br>c2 = <span class="hljs-number">17298679220717326374674940612143058330715465693318467692839033642321129433471254547497087746971317567301086124779289015934582615377165560688447452762043163082394944604062014490446763247008217251611443338103074143809936437694543761369945095202092750900940979469994907399829695696313513303922266742415376818434932335640062684245008822643258497589196668426788916969378417960200705779461808292296450298558001909603602502604228973101048082095642290047196235959438278631661658312398313171590515776453711432353011579809351076532129444735206408591345372296372378396539831385036814349328459266432393612919118094115543053115450</span><br>e = <span class="hljs-number">17</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">franklinReiter</span>(<span class="hljs-params">n,e,c1,c2</span>):<br>    x = PolynomialRing(Zmod(n),<span class="hljs-string">&#x27;x&#x27;</span>).gen()<br>    g1 = (<span class="hljs-number">2</span>*x+<span class="hljs-number">3</span>)**e - c1<br>    g2 = (<span class="hljs-number">4</span>*x+<span class="hljs-number">11</span>)**e - c2<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">g1, g2</span>):<br>        <span class="hljs-keyword">while</span> g2:<br>            g1, g2 = g2, g1 % g2<br>        <span class="hljs-keyword">return</span> g1.monic()<br>    <span class="hljs-keyword">return</span> -gcd(g1, g2)[<span class="hljs-number">0</span>]<br><br>m=franklinReiter(n,e,c1,c2)<br><span class="hljs-built_in">print</span>(long_to_bytes(<span class="hljs-built_in">int</span>(m)))<br><span class="hljs-comment"># flag&#123;r54__r3l473d_m355463_4774ck_4l50_c4ll3d_fr4nkl1n_r3173r_4774ck~&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="d-e未知，但是中间量存在线性关系"><a href="#d-e未知，但是中间量存在线性关系" class="headerlink" title="d,e未知，但是中间量存在线性关系"></a>d,e未知，但是中间量存在线性关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> nextprime<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span> (p1,p2,e):<br>    not_hint = (p1 + <span class="hljs-number">1</span>) * (p2 + <span class="hljs-number">1</span>)<br>    S = gmpy2.invert(e, not_hint)<br>    not_p = S%(p1+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> not_p<br><br>flag = <span class="hljs-string">b&#x27;Neepu&#123;********************&#125;&#x27;</span><br>flag = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*q<br>e = nextprime(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>))<br>d = gmpy2.invert(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>c = <span class="hljs-built_in">pow</span>(flag, e, n)<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(n)<br><br>m = encode(p, q, e)<br>c1 = <span class="hljs-built_in">pow</span>(m, <span class="hljs-number">7</span>, n)<br>c2 = <span class="hljs-built_in">pow</span>(m+e, <span class="hljs-number">7</span>, n)<br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-built_in">print</span>(c2)<br><br>c = <span class="hljs-number">78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671</span><br>n = <span class="hljs-number">91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br>c1 = <span class="hljs-number">10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892</span><br>c2 = <span class="hljs-number">46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119</span><br></code></pre></td></tr></table></figure><p><strong>这里的加密关系</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">c1 = <span class="hljs-built_in">pow</span>(m, <span class="hljs-number">7</span>, n)<br>c2 = <span class="hljs-built_in">pow</span>(m+e, <span class="hljs-number">7</span>, n)<br></code></pre></td></tr></table></figure><p><strong>其中有两个未知数，可以把e直接爆破出来（原文便用到了短填充攻击(Coppersmith’s short-pad attack)的代码，暂时没研究明白）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params">c1, c2, n, e</span>):<br>    x = PolynomialRing(Zmod(n),<span class="hljs-string">&#x27;x&#x27;</span>).gen()  <span class="hljs-comment"># 初始化多项式环，模n的多项式环PR</span><br>    g1 = (x)**<span class="hljs-number">7</span> - c1  <span class="hljs-comment"># 计算g1，即x的7次方减去c1</span><br>    g2 = (x+e)**<span class="hljs-number">7</span> - c2  <span class="hljs-comment"># 计算g2，即(x+e)的7次方减去c2</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">g1, g2</span>):<br>        <span class="hljs-keyword">while</span> g2:<br>            g1, g2 = g2, g1 % g2  <span class="hljs-comment"># 使用欧几里得算法计算最大公因式</span><br>        <span class="hljs-keyword">return</span> g1.monic()  <span class="hljs-comment"># 返回最大公因式的首项系数为1的最简形式</span><br><br>    <span class="hljs-keyword">return</span> -gcd(g1, g2)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回最大公因式的最简形式的首项系数的负值</span><br><br>c1 = <span class="hljs-number">10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892</span><br>c2 = <span class="hljs-number">46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119</span><br>n = <span class="hljs-number">91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>):<span class="hljs-comment">#直接爆破e</span><br>    m = attack(c1, c2, n, e)  <span class="hljs-comment"># 调用attack函数解密密文</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(m, <span class="hljs-number">7</span>, n) == c1:  <span class="hljs-comment"># 判断解密是否成功</span><br>            <span class="hljs-built_in">print</span>((e, m))  <span class="hljs-comment"># 打印解密成功的结果</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-comment">#结果：(71, 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859)</span><br><span class="hljs-comment">#e = 71</span><br><span class="hljs-comment">#m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859</span><br></code></pre></td></tr></table></figure><p><strong>求出m了，根据题目的加密方式 m &#x3D; s % (p+1) &#x3D; d % (p+1)，类似于dp泄露</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>e = <span class="hljs-number">71</span><br><span class="hljs-comment"># m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859</span><br>c = <span class="hljs-number">78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671</span><br>n = <span class="hljs-number">91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br><span class="hljs-comment"># dp = m ,类似的dp</span><br>dp = <span class="hljs-number">129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">65535</span>):<br>    p = (dp*e-<span class="hljs-number">1</span>)//i-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n%p == <span class="hljs-number">0</span>:<br>        q = n//p<br>        d = gmpy2.invert(e, (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>))<br>        flag = <span class="hljs-built_in">pow</span>(c,d,n)<br>        <span class="hljs-built_in">print</span>(long_to_bytes(flag))<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># Neepu&#123;Have-a-g00d-day12138&#125;</span><br></code></pre></td></tr></table></figure><h3 id="e-比较大的时候的half-gcd算法"><a href="#e-比较大的时候的half-gcd算法" class="headerlink" title="e 比较大的时候的half-gcd算法"></a>e 比较大的时候的half-gcd算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br>m = bytes_to_long(flag)<br>p1, q1 = getPrime(<span class="hljs-number">512</span>), getPrime(<span class="hljs-number">512</span>)<br>n1 = p1*q1<br>e = <span class="hljs-number">65537</span><br><br>p2, q2 = getPrime(<span class="hljs-number">512</span>), getPrime(<span class="hljs-number">512</span>)<br>n2 = p2*q2<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n1 = <span class="hljs-subst">&#123;n1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n2 = <span class="hljs-subst">&#123;n2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;<span class="hljs-built_in">pow</span>(m,e,n2)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;<span class="hljs-built_in">pow</span>(n1-m,e,n2)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># n1 = 52579135273678950581073020233998071974221658902576724000130040488018033110534210901239397446395736563148970863970460542205225993317478251099451639165369081820130823165642873594136020122857712288395352930384057524510346112486008850200845915783772351449146183974239444691330777565342525218070680067550270554767</span><br><span class="hljs-comment"># n2 = 68210568831848267339414957973218186686176324296418282565773310695862151827108036984694027795077376921170907068110296451176263520249799154781062517066423984526868547296781709439425857993705489037768605485740968600877866332458671029054092942851472208033494968784822459369206497698469167909174346042658361616469</span><br><span class="hljs-comment"># c1 = 42941712708129054668823891960764339394032538100909746015733801598044118605733969558717842106784388091495719003761324737091667431446354282990525549196642753967283958283202592037329821712755519455155110675327321252333824912095517427885925854391047828862338332559137577789387455868761466777370476884779752953853</span><br><span class="hljs-comment"># c2 = 62704043252861638895370674827559804184650708692227789532879941590038911799857232898692335429773480889624046167792573885125945511356456073688435911975161053231589019934427151230924004944847291434167067905803180207183209888082275583120633408232749119300200555327883719466349164062163459300518993952046873724005</span><br></code></pre></td></tr></table></figure><p><strong>这道题比较特殊，e很大，用上面的脚本跑大概要1个小时，这里引入另一种解法,half gcd算法</strong><br><strong>（这个half gcd算法也没看明白,以后看明白再写一篇）</strong><br><strong>参考:<a href="https://www.cnblogs.com/whx1003/p/16217087.html">多项式 gcd 的正确姿势：Half-GCD 算法</a></strong></p><p><strong>常规算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>e = <span class="hljs-number">65537</span><br>n1 = <span class="hljs-number">52579135273678950581073020233998071974221658902576724000130040488018033110534210901239397446395736563148970863970460542205225993317478251099451639165369081820130823165642873594136020122857712288395352930384057524510346112486008850200845915783772351449146183974239444691330777565342525218070680067550270554767</span><br>n2 = <span class="hljs-number">68210568831848267339414957973218186686176324296418282565773310695862151827108036984694027795077376921170907068110296451176263520249799154781062517066423984526868547296781709439425857993705489037768605485740968600877866332458671029054092942851472208033494968784822459369206497698469167909174346042658361616469</span><br>c1 = <span class="hljs-number">42941712708129054668823891960764339394032538100909746015733801598044118605733969558717842106784388091495719003761324737091667431446354282990525549196642753967283958283202592037329821712755519455155110675327321252333824912095517427885925854391047828862338332559137577789387455868761466777370476884779752953853</span><br>c2 = <span class="hljs-number">62704043252861638895370674827559804184650708692227789532879941590038911799857232898692335429773480889624046167792573885125945511356456073688435911975161053231589019934427151230924004944847291434167067905803180207183209888082275583120633408232749119300200555327883719466349164062163459300518993952046873724005</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params">c1, c2</span>):<br>    PR.&lt;x&gt;=PolynomialRing(Zmod(n2))<br>    g1 = x^e - c1<br>    g2 = (n1-x)^e - c2<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">g1, g2</span>):<br>        <span class="hljs-keyword">while</span> g2:<br>            g1, g2 = g2, g1 % g2<br>            <span class="hljs-keyword">if</span>(g2.degree() % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>):<br>                <span class="hljs-built_in">print</span>(g2.degree())<br>        <span class="hljs-keyword">return</span> g1.monic()<br>    <span class="hljs-keyword">return</span> -gcd(g1, g2)[<span class="hljs-number">0</span>]<br><br>m1 = attack(c1, c2)<br>flag = long_to_bytes(<span class="hljs-built_in">int</span>(m1))<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p><strong>half gcd算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">HGCD</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * b.degree() &lt;= a.degree() <span class="hljs-keyword">or</span> a.degree() == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    m = a.degree() // <span class="hljs-number">2</span><br>    a_top, a_bot = a.quo_rem(x**m)<br>    b_top, b_bot = b.quo_rem(x**m)<br>    R00, R01, R10, R11 = HGCD(a_top, b_top)<br>    c = R00 * a + R01 * b<br>    d = R10 * a + R11 * b<br>    q, e = c.quo_rem(d)<br>    d_top, d_bot = d.quo_rem(x**(m // <span class="hljs-number">2</span>))<br>    e_top, e_bot = e.quo_rem(x**(m // <span class="hljs-number">2</span>))<br>    S00, S01, S10, S11 = HGCD(d_top, e_top)<br>    RET00 = S01 * R00 + (S00 - q * S01) * R10<br>    RET01 = S01 * R01 + (S00 - q * S01) * R11<br>    RET10 = S11 * R00 + (S10 - q * S11) * R10<br>    RET11 = S11 * R01 + (S10 - q * S11) * R11<br>    <span class="hljs-keyword">return</span> RET00, RET01, RET10, RET11<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GCD</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a.degree(), b.degree())<br>    q, r = a.quo_rem(b)<br>    <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> b<br>    R00, R01, R10, R11 = HGCD(a, b)<br>    c = R00 * a + R01 * b<br>    d = R10 * a + R11 * b<br>    <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> c.monic()<br>    q, r = c.quo_rem(d)<br>    <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> d<br>    <span class="hljs-keyword">return</span> GCD(d, r)<br><br>sys.setrecursionlimit(<span class="hljs-number">500000</span>)<br><br>e = <span class="hljs-number">65537</span><br>n1 = <span class="hljs-number">52579135273678950581073020233998071974221658902576724000130040488018033110534210901239397446395736563148970863970460542205225993317478251099451639165369081820130823165642873594136020122857712288395352930384057524510346112486008850200845915783772351449146183974239444691330777565342525218070680067550270554767</span><br>n2 = <span class="hljs-number">68210568831848267339414957973218186686176324296418282565773310695862151827108036984694027795077376921170907068110296451176263520249799154781062517066423984526868547296781709439425857993705489037768605485740968600877866332458671029054092942851472208033494968784822459369206497698469167909174346042658361616469</span><br>c1 = <span class="hljs-number">42941712708129054668823891960764339394032538100909746015733801598044118605733969558717842106784388091495719003761324737091667431446354282990525549196642753967283958283202592037329821712755519455155110675327321252333824912095517427885925854391047828862338332559137577789387455868761466777370476884779752953853</span><br>c2 = <span class="hljs-number">62704043252861638895370674827559804184650708692227789532879941590038911799857232898692335429773480889624046167792573885125945511356456073688435911975161053231589019934427151230924004944847291434167067905803180207183209888082275583120633408232749119300200555327883719466349164062163459300518993952046873724005</span><br><br>x = PolynomialRing(Zmod(n2),<span class="hljs-string">&#x27;x&#x27;</span>).gen()<br>f = x**e - c1<br>g = (n1 - x)**e - c2<br><br>res = GCD(f,g)<br><span class="hljs-built_in">print</span>(long_to_bytes(<span class="hljs-built_in">int</span>(-res.monic().coefficients()[<span class="hljs-number">0</span>])))<br></code></pre></td></tr></table></figure><p><strong>gcd的结果是 ax - b，我们要得到的是x - m，用monic()将ax - b化为首一多项式即x系数位1，如此得到x - m，然后用coefficients()[0]提取到-m，最后再添个符号得到flag。</strong></p><p><strong>参考文章<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226?spm=1001.2014.3001.5502">Franklin-Reiter相关消息攻击</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>RSA算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coppersmith算法</title>
    <link href="/2024/02/21/Coppersmith%E7%AE%97%E6%B3%95/"/>
    <url>/2024/02/21/Coppersmith%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>(有待更新，这篇很旧以前写的，当时学的不太懂)</p><h1 id="Coppersmith算法"><a href="#Coppersmith算法" class="headerlink" title="Coppersmith算法"></a>Coppersmith算法</h1><ol><li><strong>需要关注题目给的数据需不需要再去补0，二进制就需要2<strong>，十进制就10</strong></strong></li><li><strong>如果题目给的p&gt;&gt;100 &#x3D; 2101051…这种就需要在后面补零*2**100或者p&lt;&lt;100</strong></li><li><strong>以已知p高位或者低位的题型来说，不考虑episilon参数(就是small_roots()里的beta参数)，coppersmith至少需要288&#x2F;512位，576&#x2F;1024位</strong></li><li><strong>epsilon参数通常设置0.01，在需要位数不够时设置</strong></li><li><strong>beta参数的设置，small_roots()为空就是mod Zmod(?)里的参数</strong></li><li><strong>beta参数的设置，如果Zmod(n),p&gt;n**k,beta&#x3D;k,此时就是mod p ，并且还会向上找</strong></li><li><strong>X是估计的x范围，如果方程建立在模T上，那上界就是T<sup>(beta<sup>2</sup>&#x2F;d - epsilon)</sup>这里是x最大不超过多少</strong></li></ol><h2 id="Boneh-and-Durfee-attack"><a href="#Boneh-and-Durfee-attack" class="headerlink" title="Boneh and Durfee attack"></a>Boneh and Durfee attack</h2><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p><strong>当 d 较小时，满足 d &lt; N<sup>0.292</sup> 时，我们可以使用这个攻击，比 Winner 攻击要强一些</strong><br><strong>更简单的判断方式就是 e 非常大，并且 Winner 攻击用不了的时候</strong></p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><strong>首先</strong></p><p><strong><center>ed ≡ 1 mod φ(N) &#x2F; 2</center></strong></p><p><strong>进而</strong></p><p><strong><center>ed + kφ(N) &#x2F; 2 &#x3D; 1</center></strong></p><p><strong>即</strong></p><p><strong><center>kφ(N) &#x2F; 2 ≡ 1 mod e</center></strong></p><p><strong>又</strong></p><p><strong><center>φ(N) &#x3D; (p-1)(q-1) &#x3D; pq - q - p + 1 &#x3D; N - q - p + 1</center></strong></p><p><strong>所以</strong></p><p><strong><center>k(N−p−q+1) &#x2F; 2 ≡ 1 mod e</center></strong></p><p><strong>假设 A &#x3D; <sup>N + 1</sup>&frasl;<sub>2</sub> , y &#x3D; <sup>-p-q</sup>&frasl;<sub>2</sub> ，A + y &#x3D; φ(N) ，原式可以化为</strong></p><p><strong><center>f(k,y) &#x3D; k(A + y) ≡ 1 mod e</center></strong></p><p><strong>其中</strong></p><p><strong><center>|k| &lt; <sup>2ed</sup>&frasl;<sub>φ(N)</sub> &lt; <sup>3ed</sup>&frasl;<sub>N</sub> &#x3D; 3 * <sup>e</sup>&frasl;<sub>N</sub> * d &lt; 3 * <sup>e</sup>&frasl;<sub>N</sub> * N<sup>delta</sup></center></strong><br><strong><center>|y| &lt; 2 * N<sup>0.5</sup></center></strong></p><p><strong>y 估计使用了p，q比较接近的假设，这里delta为预估的小于0.292的值</strong><br><strong>如果我们求得了该二元方程的根，那么我们也就可以解一元二次方程 N &#x3D; pq,p+q &#x3D; −2y 来得到 p 与 q</strong></p><p><strong>根据题目具体的数据来修改 A 和 Y ， delta &lt;&#x3D; <sup>d的位数</sup>&frasl;<sub>N的位数</sub> ，m是构建格基的维度，m的值越大找到解的可能性就越高，但是时间复杂度也会指数级增加（一般取4到7）</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="python2版本"><a href="#python2版本" class="headerlink" title="python2版本"></a>python2版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Config</span><br><span class="hljs-comment">##########################################</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting debug to true will display more informations</span><br><span class="hljs-string">about the lattice, the bounds, the vectors...</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>debug = <span class="hljs-literal">True</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting strict to true will stop the algorithm (and</span><br><span class="hljs-string">return (-1, -1)) if we don&#x27;t have a correct</span><br><span class="hljs-string">upperbound on the determinant. Note that this</span><br><span class="hljs-string">doesn&#x27;t necesseraly mean that no solutions</span><br><span class="hljs-string">will be found since the theoretical upperbound is</span><br><span class="hljs-string">usualy far away from actual results. That is why</span><br><span class="hljs-string">you should probably use `strict = False`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>strict = <span class="hljs-literal">False</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is experimental, but has provided remarkable results</span><br><span class="hljs-string">so far. It tries to reduce the lattice as much as it can</span><br><span class="hljs-string">while keeping its efficiency. I see no reason not to use</span><br><span class="hljs-string">this option, but if things don&#x27;t work, you should try</span><br><span class="hljs-string">disabling it</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>helpful_only = <span class="hljs-literal">True</span><br>dimension_min = <span class="hljs-number">7</span> <span class="hljs-comment"># stop removing if lattice reaches that dimension</span><br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Functions</span><br><span class="hljs-comment">##########################################</span><br><br><span class="hljs-comment"># display stats on helpful vectors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">helpful_vectors</span>(<span class="hljs-params">BB, modulus</span>):<br>    nothelpful = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> BB[ii,ii] &gt;= modulus:<br>            nothelpful += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(nothelpful, <span class="hljs-string">&quot;/&quot;</span>, BB.dimensions()[<span class="hljs-number">0</span>], <span class="hljs-string">&quot; vectors are not helpful&quot;</span>)<br><br><span class="hljs-comment"># display matrix picture with 0 and X</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_overview</span>(<span class="hljs-params">BB, bound</span>):<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        a = (<span class="hljs-string">&#x27;%02d &#x27;</span> % ii)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">1</span>]):<br>            a += <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">if</span> BB[ii,jj] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">60</span>:<br>                a += <span class="hljs-string">&#x27; &#x27;</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            a += <span class="hljs-string">&#x27;~&#x27;</span><br>        <span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-comment"># tries to remove unhelpful vectors</span><br><span class="hljs-comment"># we start at current = n-1 (last vector)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_unhelpful</span>(<span class="hljs-params">BB, monomials, bound, current</span>):<br>    <span class="hljs-comment"># end of our recursive function</span><br>    <span class="hljs-keyword">if</span> current == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt;= dimension_min:<br>        <span class="hljs-keyword">return</span> BB<br><br>    <span class="hljs-comment"># we start by checking from the end</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(current, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># if it is unhelpful:</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            affected_vectors = <span class="hljs-number">0</span><br>            affected_vector_index = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># let&#x27;s check if it affects other vectors</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ii + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                <span class="hljs-comment"># if another vector is affected:</span><br>                <span class="hljs-comment"># we increase the count</span><br>                <span class="hljs-keyword">if</span> BB[jj, ii] != <span class="hljs-number">0</span>:<br>                    affected_vectors += <span class="hljs-number">1</span><br>                    affected_vector_index = jj<br><br>            <span class="hljs-comment"># level:0</span><br>            <span class="hljs-comment"># if no other vectors end up affected</span><br>            <span class="hljs-comment"># we remove it</span><br>            <span class="hljs-keyword">if</span> affected_vectors == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* removing unhelpful vector&quot;</span>, ii)<br>                BB = BB.delete_columns([ii])<br>                BB = BB.delete_rows([ii])<br>                monomials.pop(ii)<br>                BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> BB<br><br>            <span class="hljs-comment"># level:1</span><br>            <span class="hljs-comment"># if just one was affected we check</span><br>            <span class="hljs-comment"># if it is affecting someone else</span><br>            <span class="hljs-keyword">elif</span> affected_vectors == <span class="hljs-number">1</span>:<br>                affected_deeper = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(affected_vector_index + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                    <span class="hljs-comment"># if it is affecting even one vector</span><br>                    <span class="hljs-comment"># we give up on this one</span><br>                    <span class="hljs-keyword">if</span> BB[kk, affected_vector_index] != <span class="hljs-number">0</span>:<br>                        affected_deeper = <span class="hljs-literal">False</span><br>                <span class="hljs-comment"># remove both it if no other vector was affected and</span><br>                <span class="hljs-comment"># this helpful vector is not helpful enough</span><br>                <span class="hljs-comment"># compared to our unhelpful one</span><br>                <span class="hljs-keyword">if</span> affected_deeper <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(bound - BB[affected_vector_index, affected_vector_index]) &lt; <span class="hljs-built_in">abs</span>(bound - BB[ii, ii]):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* removing unhelpful vectors&quot;</span>, ii, <span class="hljs-string">&quot;and&quot;</span>, affected_vector_index)<br>                    BB = BB.delete_columns([affected_vector_index, ii])<br>                    BB = BB.delete_rows([affected_vector_index, ii])<br>                    monomials.pop(affected_vector_index)<br>                    monomials.pop(ii)<br>                    BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> BB<br>    <span class="hljs-comment"># nothing happened</span><br>    <span class="hljs-keyword">return</span> BB<br><br><span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">Returns:</span><br><span class="hljs-string">* 0,0   if it fails</span><br><span class="hljs-string">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound</span><br><span class="hljs-string">* x0,y0 the solutions of `pol`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">boneh_durfee</span>(<span class="hljs-params">pol, modulus, mm, tt, XX, YY</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Boneh and Durfee revisited by Herrmann and May</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    finds a solution if:</span><br><span class="hljs-string">    * d &lt; N^delta</span><br><span class="hljs-string">    * |x| &lt; e^delta</span><br><span class="hljs-string">    * |y| &lt; e^0.5</span><br><span class="hljs-string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># substitution (Herrman and May)</span><br>    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)<br>    Q = PR.quotient(x*y + <span class="hljs-number">1</span> - u) <span class="hljs-comment"># u = xy + 1</span><br>    polZ = Q(pol).lift()<br><br>    UU = XX*YY + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># x-shifts</span><br>    gg = []<br>    <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mm + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mm - kk + <span class="hljs-number">1</span>):<br>            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk<br>            gg.append(xshift)<br>    gg.sort()<br><br>    <span class="hljs-comment"># x-shifts list of monomials</span><br>    monomials = []<br>    <span class="hljs-keyword">for</span> polynomial <span class="hljs-keyword">in</span> gg:<br>        <span class="hljs-keyword">for</span> monomial <span class="hljs-keyword">in</span> polynomial.monomials():<br>            <span class="hljs-keyword">if</span> monomial <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> monomials:<br>                monomials.append(monomial)<br>    monomials.sort()<br>    <br>    <span class="hljs-comment"># y-shifts (selected by Herrman and May)</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, tt + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(mm/tt) * jj, mm + <span class="hljs-number">1</span>):<br>            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)<br>            yshift = Q(yshift).lift()<br>            gg.append(yshift) <span class="hljs-comment"># substitution</span><br>    <br>    <span class="hljs-comment"># y-shifts list of monomials</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, tt + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(mm/tt) * jj, mm + <span class="hljs-number">1</span>):<br>            monomials.append(u^kk * y^jj)<br><br>    <span class="hljs-comment"># construct lattice B</span><br>    nn = <span class="hljs-built_in">len</span>(monomials)<br>    BB = Matrix(ZZ, nn)<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>        BB[ii, <span class="hljs-number">0</span>] = gg[ii](<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ii + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> monomials[jj] <span class="hljs-keyword">in</span> gg[ii].monomials():<br>                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)<br><br>    <span class="hljs-comment"># Prototype to reduce the lattice</span><br>    <span class="hljs-keyword">if</span> helpful_only:<br>        <span class="hljs-comment"># automatically remove</span><br>        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># reset dimension</span><br>        nn = BB.dimensions()[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> nn == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;failure&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># check if vectors are helpful</span><br>    <span class="hljs-keyword">if</span> debug:<br>        helpful_vectors(BB, modulus^mm)<br>    <br>    <span class="hljs-comment"># check if determinant is correctly bounded</span><br>    det = BB.det()<br>    bound = modulus^(mm*nn)<br>    <span class="hljs-keyword">if</span> det &gt;= bound:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;We do not have det &lt; bound. Solutions might not be found.&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Try with highers m and t.&quot;</span>)<br>        <span class="hljs-keyword">if</span> debug:<br>            diff = (log(det) - log(bound)) / log(<span class="hljs-number">2</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;size det(L) - size e^(m*n) = &quot;</span>, floor(diff))<br>        <span class="hljs-keyword">if</span> strict:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)<br><br>    <span class="hljs-comment"># display the lattice basis</span><br>    <span class="hljs-keyword">if</span> debug:<br>        matrix_overview(BB, modulus^mm)<br><br>    <span class="hljs-comment"># LLL</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)<br><br>    BB = BB.LLL()<br><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LLL is done!&quot;</span>)<br><br>    <span class="hljs-comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;looking for independent vectors in the lattice&quot;</span>)<br>    found_polynomials = <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-keyword">for</span> pol1_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> pol2_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pol1_idx + <span class="hljs-number">1</span>, nn):<br>            <span class="hljs-comment"># for i and j, create the two polynomials</span><br>            PR.&lt;w,z&gt; = PolynomialRing(ZZ)<br>            pol1 = pol2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>                pol1 += monomials[jj](w*z+<span class="hljs-number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)<br>                pol2 += monomials[jj](w*z+<span class="hljs-number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)<br><br>            <span class="hljs-comment"># resultant</span><br>            PR.&lt;q&gt; = PolynomialRing(ZZ)<br>            rr = pol1.resultant(pol2)<br><br>            <span class="hljs-comment"># are these good polynomials?</span><br>            <span class="hljs-keyword">if</span> rr.is_zero() <span class="hljs-keyword">or</span> rr.monomials() == [<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;found them, using vectors&quot;</span>, pol1_idx, <span class="hljs-string">&quot;and&quot;</span>, pol2_idx)<br>                found_polynomials = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> found_polynomials:<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found_polynomials:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;no independant vectors could be found. This should very rarely happen...&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <br>    rr = rr(q, q)<br><br>    <span class="hljs-comment"># solutions</span><br>    soly = rr.roots()<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(soly) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Your prediction (delta) is too small&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    soly = soly[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    ss = pol1(q, soly)<br>    solx = ss.roots()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-keyword">return</span> solx, soly<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>():<br>    <span class="hljs-comment">############################################</span><br>    <span class="hljs-comment"># How To Use This Script</span><br>    <span class="hljs-comment">##########################################</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># The problem to solve (edit the following values)</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># the modulus</span><br>    N = <span class="hljs-number">0xc2fd2913bae61f845ac94e4ee1bb10d8531dda830d31bb221dac5f179a8f883f15046d7aa179aff848db2734b8f88cc73d09f35c445c74ee35b01a96eb7b0a6ad9cb9ccd6c02c3f8c55ecabb55501bb2c318a38cac2db69d510e152756054aaed064ac2a454e46d9b3b755b67b46906fbff8dd9aeca6755909333f5f81bf74db</span><br>    <span class="hljs-comment"># the public exponent</span><br>    e = <span class="hljs-number">0x19441f679c9609f2484eb9b2658d7138252b847b2ed8ad182be7976ed57a3e441af14897ce041f3e07916445b88181c22f510150584eee4b0f776a5a487a4472a99f2ddc95efdd2b380ab4480533808b8c92e63ace57fb42bac8315fa487d03bec86d854314bc2ec4f99b192bb98710be151599d60f224114f6b33f47e357517</span><br><br>    <span class="hljs-comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span><br>    delta = <span class="hljs-number">.18</span> <span class="hljs-comment"># this means that d &lt; N^delta</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Lattice (tweak those values)</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span><br>    m = <span class="hljs-number">4</span> <span class="hljs-comment"># size of the lattice (bigger the better/slower)</span><br><br>    <span class="hljs-comment"># you need to be a lattice master to tweak these</span><br>    t = <span class="hljs-built_in">int</span>((<span class="hljs-number">1</span>-<span class="hljs-number">2</span>*delta) * m)  <span class="hljs-comment"># optimization from Herrmann and May</span><br>    X = <span class="hljs-number">2</span>*floor(N^delta)  <span class="hljs-comment"># this _might_ be too much</span><br>    Y = floor(N^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))    <span class="hljs-comment"># correct if p, q are ~ same size</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Don&#x27;t touch anything below</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># Problem put in equation</span><br>    P.&lt;x,y&gt; = PolynomialRing(ZZ)<br>    A = <span class="hljs-built_in">int</span>((N+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)<br>    pol = <span class="hljs-number">1</span> + x * (A + y)<br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Find the solutions!</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># Checking bounds</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== checking values ===&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* delta:&quot;</span>, delta)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* delta &lt; 0.292&quot;</span>, delta &lt; <span class="hljs-number">0.292</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* size of e:&quot;</span>, <span class="hljs-built_in">int</span>(log(e)/log(<span class="hljs-number">2</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* size of N:&quot;</span>, <span class="hljs-built_in">int</span>(log(N)/log(<span class="hljs-number">2</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* m:&quot;</span>, m, <span class="hljs-string">&quot;, t:&quot;</span>, t)<br><br>    <span class="hljs-comment"># boneh_durfee</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== running algorithm ===&quot;</span>)<br>        start_time = time.time()<br><br>    solx, soly = boneh_durfee(pol, e, m, t, X, Y)<br><br>    <span class="hljs-comment"># found a solution?</span><br>    <span class="hljs-keyword">if</span> solx &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== solution found ===&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x:&quot;</span>, solx)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y:&quot;</span>, soly)<br><br>        d = <span class="hljs-built_in">int</span>(pol(solx, soly) / e)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;private key found:&quot;</span>, d)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== no solution was found ===&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>((<span class="hljs-string">&quot;=== %s seconds ===&quot;</span> % (time.time() - start_time)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    example()<br></code></pre></td></tr></table></figure><hr><h4 id="python3版本"><a href="#python3版本" class="headerlink" title="python3版本"></a>python3版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting debug to true will display more informations</span><br><span class="hljs-string">about the lattice, the bounds, the vectors...</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>debug = <span class="hljs-literal">True</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting strict to true will stop the algorithm (and</span><br><span class="hljs-string">return (-1, -1)) if we don&#x27;t have a correct </span><br><span class="hljs-string">upperbound on the determinant. Note that this </span><br><span class="hljs-string">doesn&#x27;t necesseraly mean that no solutions </span><br><span class="hljs-string">will be found since the theoretical upperbound is</span><br><span class="hljs-string">usualy far away from actual results. That is why</span><br><span class="hljs-string">you should probably use `strict = False`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>strict = <span class="hljs-literal">False</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is experimental, but has provided remarkable results</span><br><span class="hljs-string">so far. It tries to reduce the lattice as much as it can</span><br><span class="hljs-string">while keeping its efficiency. I see no reason not to use</span><br><span class="hljs-string">this option, but if things don&#x27;t work, you should try</span><br><span class="hljs-string">disabling it</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>helpful_only = <span class="hljs-literal">True</span><br>dimension_min = <span class="hljs-number">7</span> <span class="hljs-comment"># stop removing if lattice reaches that dimension</span><br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Functions</span><br><span class="hljs-comment">##########################################</span><br><br><span class="hljs-comment"># display stats on helpful vectors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">helpful_vectors</span>(<span class="hljs-params">BB, modulus</span>):<br>    nothelpful = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> BB[ii,ii] &gt;= modulus:<br>            nothelpful += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span> (nothelpful, <span class="hljs-string">&quot;/&quot;</span>, BB.dimensions()[<span class="hljs-number">0</span>], <span class="hljs-string">&quot; vectors are not helpful&quot;</span>)<br><br><span class="hljs-comment"># display matrix picture with 0 and X</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_overview</span>(<span class="hljs-params">BB, bound</span>):<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        a = (<span class="hljs-string">&#x27;%02d &#x27;</span> % ii)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">1</span>]):<br>            a += <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">if</span> BB[ii,jj] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">60</span>:<br>                a += <span class="hljs-string">&#x27; &#x27;</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            a += <span class="hljs-string">&#x27;~&#x27;</span><br>        <span class="hljs-built_in">print</span> (a)<br><br><span class="hljs-comment"># tries to remove unhelpful vectors</span><br><span class="hljs-comment"># we start at current = n-1 (last vector)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_unhelpful</span>(<span class="hljs-params">BB, monomials, bound, current</span>):<br>    <span class="hljs-comment"># end of our recursive function</span><br>    <span class="hljs-keyword">if</span> current == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt;= dimension_min:<br>        <span class="hljs-keyword">return</span> BB<br><br>    <span class="hljs-comment"># we start by checking from the end</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(current, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># if it is unhelpful:</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            affected_vectors = <span class="hljs-number">0</span><br>            affected_vector_index = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># let&#x27;s check if it affects other vectors</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ii + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                <span class="hljs-comment"># if another vector is affected:</span><br>                <span class="hljs-comment"># we increase the count</span><br>                <span class="hljs-keyword">if</span> BB[jj, ii] != <span class="hljs-number">0</span>:<br>                    affected_vectors += <span class="hljs-number">1</span><br>                    affected_vector_index = jj<br><br>            <span class="hljs-comment"># level:0</span><br>            <span class="hljs-comment"># if no other vectors end up affected</span><br>            <span class="hljs-comment"># we remove it</span><br>            <span class="hljs-keyword">if</span> affected_vectors == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* removing unhelpful vector&quot;</span>, ii)<br>                BB = BB.delete_columns([ii])<br>                BB = BB.delete_rows([ii])<br>                monomials.pop(ii)<br>                BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> BB<br><br>            <span class="hljs-comment"># level:1</span><br>            <span class="hljs-comment"># if just one was affected we check</span><br>            <span class="hljs-comment"># if it is affecting someone else</span><br>            <span class="hljs-keyword">elif</span> affected_vectors == <span class="hljs-number">1</span>:<br>                affected_deeper = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(affected_vector_index + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                    <span class="hljs-comment"># if it is affecting even one vector</span><br>                    <span class="hljs-comment"># we give up on this one</span><br>                    <span class="hljs-keyword">if</span> BB[kk, affected_vector_index] != <span class="hljs-number">0</span>:<br>                        affected_deeper = <span class="hljs-literal">False</span><br>                <span class="hljs-comment"># remove both it if no other vector was affected and</span><br>                <span class="hljs-comment"># this helpful vector is not helpful enough</span><br>                <span class="hljs-comment"># compared to our unhelpful one</span><br>                <span class="hljs-keyword">if</span> affected_deeper <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(bound - BB[affected_vector_index, affected_vector_index]) &lt; <span class="hljs-built_in">abs</span>(bound - BB[ii, ii]):<br>                    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* removing unhelpful vectors&quot;</span>, ii, <span class="hljs-string">&quot;and&quot;</span>, affected_vector_index)<br>                    BB = BB.delete_columns([affected_vector_index, ii])<br>                    BB = BB.delete_rows([affected_vector_index, ii])<br>                    monomials.pop(affected_vector_index)<br>                    monomials.pop(ii)<br>                    BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> BB<br>    <span class="hljs-comment"># nothing happened</span><br>    <span class="hljs-keyword">return</span> BB<br><br><span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">Returns:</span><br><span class="hljs-string">* 0,0   if it fails</span><br><span class="hljs-string">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound</span><br><span class="hljs-string">* x0,y0 the solutions of `pol`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">boneh_durfee</span>(<span class="hljs-params">pol, modulus, mm, tt, XX, YY</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Boneh and Durfee revisited by Herrmann and May</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    finds a solution if:</span><br><span class="hljs-string">    * d &lt; N^delta</span><br><span class="hljs-string">    * |x| &lt; e^delta</span><br><span class="hljs-string">    * |y| &lt; e^0.5</span><br><span class="hljs-string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># substitution (Herrman and May)</span><br>    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)<br>    Q = PR.quotient(x*y + <span class="hljs-number">1</span> - u) <span class="hljs-comment"># u = xy + 1</span><br>    polZ = Q(pol).lift()<br><br>    UU = XX*YY + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># x-shifts</span><br>    gg = []<br>    <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mm + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mm - kk + <span class="hljs-number">1</span>):<br>            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk<br>            gg.append(xshift)<br>    gg.sort()<br><br>    <span class="hljs-comment"># x-shifts list of monomials</span><br>    monomials = []<br>    <span class="hljs-keyword">for</span> polynomial <span class="hljs-keyword">in</span> gg:<br>        <span class="hljs-keyword">for</span> monomial <span class="hljs-keyword">in</span> polynomial.monomials():<br>            <span class="hljs-keyword">if</span> monomial <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> monomials:<br>                monomials.append(monomial)<br>    monomials.sort()<br>    <br>    <span class="hljs-comment"># y-shifts (selected by Herrman and May)</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, tt + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(mm/tt) * jj, mm + <span class="hljs-number">1</span>):<br>            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)<br>            yshift = Q(yshift).lift()<br>            gg.append(yshift) <span class="hljs-comment"># substitution</span><br>    <br>    <span class="hljs-comment"># y-shifts list of monomials</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, tt + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(mm/tt) * jj, mm + <span class="hljs-number">1</span>):<br>            monomials.append(u^kk * y^jj)<br><br>    <span class="hljs-comment"># construct lattice B</span><br>    nn = <span class="hljs-built_in">len</span>(monomials)<br>    BB = Matrix(ZZ, nn)<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>        BB[ii, <span class="hljs-number">0</span>] = gg[ii](<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ii + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> monomials[jj] <span class="hljs-keyword">in</span> gg[ii].monomials():<br>                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)<br><br>    <span class="hljs-comment"># Prototype to reduce the lattice</span><br>    <span class="hljs-keyword">if</span> helpful_only:<br>        <span class="hljs-comment"># automatically remove</span><br>        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># reset dimension</span><br>        nn = BB.dimensions()[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> nn == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;failure&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># check if vectors are helpful</span><br>    <span class="hljs-keyword">if</span> debug:<br>        helpful_vectors(BB, modulus^mm)<br>    <br>    <span class="hljs-comment"># check if determinant is correctly bounded</span><br>    det = BB.det()<br>    bound = modulus^(mm*nn)<br>    <span class="hljs-keyword">if</span> det &gt;= bound:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;We do not have det &lt; bound. Solutions might not be found.&quot;</span>)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Try with highers m and t.&quot;</span>)<br>        <span class="hljs-keyword">if</span> debug:<br>            diff = (log(det) - log(bound)) / log(<span class="hljs-number">2</span>)<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;size det(L) - size e^(m*n) = &quot;</span>, floor(diff))<br>        <span class="hljs-keyword">if</span> strict:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)<br><br>    <span class="hljs-comment"># display the lattice basis</span><br>    <span class="hljs-keyword">if</span> debug:<br>        matrix_overview(BB, modulus^mm)<br><br>    <span class="hljs-comment"># LLL</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)<br><br>    BB = BB.LLL()<br><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;LLL is done!&quot;</span>)<br><br>    <span class="hljs-comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;looking for independent vectors in the lattice&quot;</span>)<br>    found_polynomials = <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-keyword">for</span> pol1_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> pol2_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pol1_idx + <span class="hljs-number">1</span>, nn):<br>            <span class="hljs-comment"># for i and j, create the two polynomials</span><br>            PR.&lt;w,z&gt; = PolynomialRing(ZZ)<br>            pol1 = pol2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>                pol1 += monomials[jj](w*z+<span class="hljs-number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)<br>                pol2 += monomials[jj](w*z+<span class="hljs-number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)<br><br>            <span class="hljs-comment"># resultant</span><br>            PR.&lt;q&gt; = PolynomialRing(ZZ)<br>            rr = pol1.resultant(pol2)<br><br>            <span class="hljs-comment"># are these good polynomials?</span><br>            <span class="hljs-keyword">if</span> rr.is_zero() <span class="hljs-keyword">or</span> rr.monomials() == [<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;found them, using vectors&quot;</span>, pol1_idx, <span class="hljs-string">&quot;and&quot;</span>, pol2_idx)<br>                found_polynomials = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> found_polynomials:<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found_polynomials:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;no independant vectors could be found. This should very rarely happen...&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <br>    rr = rr(q, q)<br><br>    <span class="hljs-comment"># solutions</span><br>    soly = rr.roots()<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(soly) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Your prediction (delta) is too small&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    soly = soly[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    ss = pol1(q, soly)<br>    solx = ss.roots()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-keyword">return</span> solx, soly<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>():<br>    <span class="hljs-comment">############################################</span><br>    <span class="hljs-comment"># How To Use This Script</span><br>    <span class="hljs-comment">##########################################</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># The problem to solve (edit the following values)</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># the modulus</span><br>    N = <span class="hljs-number">0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27</span><br>    <span class="hljs-comment"># the public exponent</span><br>    e = <span class="hljs-number">0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb</span><br><br>    <span class="hljs-comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span><br>    delta = <span class="hljs-number">0.280</span> <span class="hljs-comment"># this means that d &lt; N^delta</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Lattice (tweak those values)</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span><br>    m = <span class="hljs-number">4</span> <span class="hljs-comment"># size of the lattice (bigger the better/slower)</span><br><br>    <span class="hljs-comment"># you need to be a lattice master to tweak these</span><br>    t = <span class="hljs-built_in">int</span>((<span class="hljs-number">1</span>-<span class="hljs-number">2</span>*delta) * m)  <span class="hljs-comment"># optimization from Herrmann and May</span><br>    X = <span class="hljs-number">2</span>*floor(N^delta)  <span class="hljs-comment"># this _might_ be too much</span><br>    Y = floor(N^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))    <span class="hljs-comment"># correct if p, q are ~ same size</span><br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Don&#x27;t touch anything below</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># Problem put in equation</span><br>    P.&lt;x,y&gt; = PolynomialRing(ZZ)<br>    A = <span class="hljs-built_in">int</span>((N+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)<br>    pol = <span class="hljs-number">1</span> + x * (A + y)<br><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># Find the solutions!</span><br>    <span class="hljs-comment">#</span><br><br>    <span class="hljs-comment"># Checking bounds</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;=== checking values ===&quot;</span>)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* delta:&quot;</span>, delta)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* delta &lt; 0.292&quot;</span>, delta &lt; <span class="hljs-number">0.292</span>)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* size of e:&quot;</span>, <span class="hljs-built_in">int</span>(log(e)/log(<span class="hljs-number">2</span>)))<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* size of N:&quot;</span>, <span class="hljs-built_in">int</span>(log(N)/log(<span class="hljs-number">2</span>)))<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;* m:&quot;</span>, m, <span class="hljs-string">&quot;, t:&quot;</span>, t)<br><br>    <span class="hljs-comment"># boneh_durfee</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;=== running algorithm ===&quot;</span>)<br>        start_time = time.time()<br><br>    solx, soly = boneh_durfee(pol, e, m, t, X, Y)<br><br>    <span class="hljs-comment"># found a solution?</span><br>    <span class="hljs-keyword">if</span> solx &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;=== solution found ===&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;x:&quot;</span>, solx)<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;y:&quot;</span>, soly)<br><br>        d = <span class="hljs-built_in">int</span>(pol(solx, soly) / e)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;private key found:&quot;</span>, d)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;=== no solution was found ===&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== %s seconds ===&quot;</span> % (time.time() - start_time))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    example()<br></code></pre></td></tr></table></figure><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="常规已知-n-e-c"><a href="#常规已知-n-e-c" class="headerlink" title="常规已知 n,e,c"></a>常规已知 n,e,c</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<br><span class="hljs-keyword">import</span> os<br><br>flag = os.getenv(<span class="hljs-string">&#x27;GZCTF_FLAG&#x27;</span>)<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br>d = getPrime(<span class="hljs-number">560</span>)<br>n = p * q<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = bytes_to_long(pad(flag.encode(),<span class="hljs-number">222</span>))<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n = <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;e = <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c = <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br>n = <span class="hljs-number">14601067491478388891196428642955385854381362089276149620540033972444184180653971992362397556042123749143566174035054232897606256207553016097600290274095111983646188689579428058996868234783247049026229249711359642950304587528089184526528194454778697850627714831936448072963791260200432332267388262114904812354322747822156514629800500385624392332501844729497567844119000212696659387978513381498935146598050414687525131694536961654757026709830526784424052569395617624715648118482602551920685453722105036848008745871963622514146750974348576263625483465992465635937790079856226644982976049924188512032166847518491515437777</span><br>e = <span class="hljs-number">3424096478450687489422589157197886388592174399339580186883302516517438561781828466326210347131515001154983181438855721363594740589395575522020125029797011188165129572202051213345687655693753622048815404409747860640904993636044304588092532787776668550434845324482947348306801011347458111129547694481482179564757981296938254719788126545621173205866251644217106357614891649296999461470672912761207502768525663314935988743075695089541801739540052523478980735237920438610740626972917577665257825264340462604466356712045778955020116903902985681974166952172555014559867763139497360530192899517165229381960493351005016630689</span><br>c = <span class="hljs-number">8943345320366515714594335283198228276689391488232846129758567588672972289305126025856975755494864173056497629074646236252061267098714162051698440036532781165991427039057686199623628069048620304824897947058623634394751763382551354259047709635426341752749329983456470885412580068721720063685187914903675165145560966397023296544662458271400533408651865467169500338858446813036863640098200932320348155228698309024078310219608798907834276404903566888165155371416286645415785714754337834210004259439344797003679367562282861097915829585672625253494637007628088869572548134833200696111719665443522298547402190829740680799696</span><br></code></pre></td></tr></table></figure><p><strong>直接修改代码中的N，e数据即可，根据题目中的 d 位数可以得到 delta &#x3D; <sup>560</sup>&frasl;<sub>2048</sub> &#x3D; 0.273，m &#x3D; 7</strong></p><hr><h4 id="已知-n，e，c，leak"><a href="#已知-n，e，c，leak" class="headerlink" title="已知 n，e，c，leak"></a>已知 n，e，c，leak</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<br><span class="hljs-keyword">import</span> os<br><br>flag = os.getenv(<span class="hljs-string">&#x27;GZCTF_FLAG&#x27;</span>)<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br>d = getPrime(<span class="hljs-number">660</span>)<br>n = p * q<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = bytes_to_long(pad(flag.encode(),<span class="hljs-number">222</span>))<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br>leak = (p + q) &gt;&gt; <span class="hljs-number">860</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n = <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;e = <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c = <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;leak = <span class="hljs-subst">&#123;leak&#125;</span>&quot;</span>)<br>n = <span class="hljs-number">28499311431420652622185437635546175122631439607489486275710810248611918382947528900713052064871914398870249241742853735303789709007345980317669553801334983928965104264315960962218176088331958664424212688981089763971003794075829161916721947709815505810624515918865786476748352436456024926893777381409702246349482569339103048403365853090929149208509615903183966296268936603554733946910835404801199396594234708269630401432343314418162306978676849375886957329509540512464950274296113463591145518819620863351700366098264249021228706668585942496742587719519765724029730268566194056422351098559521728883428519820304507749127</span><br>e = <span class="hljs-number">24294331303905752409883601325550852655550756470753015146469034989685888173831059841836162412595809067916945494411801350582825284164060366116761525371704186971596498694100993207092688666631925482366535786520271980545937458206921523523324732668273590479639731214366286191612187553685785608806032314082374262885119591771546561720494740639374493865925094515692580289903659926701163563788448137497799013174069275527353837769909426860288171659493571081804782231959813286669418830313897018251632756483669797951702404647673384891783434888190715981826763109645132912804661406596363991029029328294791032885047128175280972678637</span><br>c = <span class="hljs-number">8607079479615192083928289716451933183318924908448280943642588452712894727581643613583945838120069088477640978021357179486897614140713780733469495052851732689070967156161328413474294062735486984882656963880208997977034544856718820560447162303177867387948522785795780327361474445348648875274835219523501811640379833682855310066221836094195111460874124522635789432223525116824253449868110450963700127119462059439674361668377487888397371361683390432204270160231844144646263387964398843268509590012434886254547569326809818457453470995352333476545776266340180308817689744409214256905984865390305010275310924228087289843676</span><br>leak = <span class="hljs-number">43941289481411439730141192077473641764664807729202</span><br></code></pre></td></tr></table></figure><p><strong>一样的数据处理，delta &#x3D; <sup>660</sup>&frasl;<sub>2048</sub> &#x3D; 0.323，m &#x3D; 7</strong><br><strong>在这里对于 A 和 Y 有些修改，原来代码中的是 A &#x3D; <sup>N + 1</sup>&frasl;<sub>2</sub> , y &#x3D; <sup>-p-q</sup>&frasl;<sub>2</sub> ，求解方程</strong></p><p><strong><center>k(A + y) ≡ 1 mod e</center></strong></p><p><strong>我们在这里将已知高位的条件代入进去可以得到</strong></p><p><strong><center>ed &#x3D; 2k(<sup>N + 1</sup>&frasl;<sub>2</sub> - <sup>p<sub>h</sub> + q<sub>h</sub></sup>&frasl;<sub>2</sub> - <sup>p<sub>l</sub> + q<sub>l</sub></sup>&frasl;<sub>2</sub>) + 1</center></strong></p><p><strong>所以可以类似的记 A &#x3D; <sup>N + 1</sup>&frasl;<sub>2</sub> - <sup>p<sub>h</sub> + q<sub>h</sub></sup>&frasl;<sub>2</sub> ，y &#x3D; <sup>-p<sub>l</sub> - q<sub>l</sub></sup>&frasl;<sub>2</sub> ，就有</strong></p><p><strong><center>2k(A + y) ≡ 1 mod e</center></strong></p><p><strong>就可以用Coppersmith方法解，而且问题形式跟上面的一模一样</strong></p><h2 id="常规例题"><a href="#常规例题" class="headerlink" title="常规例题"></a>常规例题</h2><h3 id="已知明文m高位求低位"><a href="#已知明文m高位求低位" class="headerlink" title="已知明文m高位求低位"></a>已知明文m高位求低位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>n=<span class="hljs-number">13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211</span><br><br>e=<span class="hljs-number">3</span><br><br>c=<span class="hljs-number">15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517</span><br><br>high_m=<span class="hljs-number">2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coppersmith1</span>(<span class="hljs-params">high_m,n,c</span>):<br>    x = PolynomialRing(Zmod(n), <span class="hljs-string">&#x27;x&#x27;</span>).gen()<br>    <br>    m = high_m + x<br>    <br>    M = m((m**<span class="hljs-number">3</span>-c).small_roots()[<span class="hljs-number">0</span>])<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程一&quot;</span>,<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(M)))<br><br>coppersmith1(high_m,n,c)<br></code></pre></td></tr></table></figure><hr><h3 id="已知p高位求低位"><a href="#已知p高位求低位" class="headerlink" title="已知p高位求低位"></a>已知p高位求低位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>n=<span class="hljs-number">12784625729032789592766625203074018101354917751492952685083808825504221816847310910447532133616954262271205877651255598995305639194329607493047941212754523879402744065076183778452640602625242851184095546100200565113016690161053808950384458996881574266573992526357954507491397978278604102524731393059303476350167738237822647246425836482533150025923051544431330502522043833872580483142594571802189321599016725741260254170793393777293145010525686561904427613648184843619301241414264343057368192416551134404100386155751297424616254697041043851852081071306219462991969849123668248321130382231769250865190227630009181759219</span><br><br>e=<span class="hljs-number">65537</span><br><br>c=<span class="hljs-number">627824086157119245056478875800598959553774250161670787506083253960788230737588761787385686125828765665617567887904228030839535317987589608761534500003128247164233774794784231518212804270056404565710426613938264302998015421153393879729263551292024543756422702956470022959537221269172084619081368498693930550456153543628170306324206266216348386707008661128717431426237486511309767286175518238620230507201952867261283880986868752676549613958785288914989429224582849218395471672295410036858881836363364885164276983237312235831591858044908369376855484127614933545955544787160352042318378588039587911741028067576722790778</span><br><span class="hljs-comment">#p&gt;&gt;128&lt;&lt;128=high_p</span><br>high_p=<span class="hljs-number">97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560391380395697098964411821716664506908672</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coppersmith2</span>(<span class="hljs-params">high_p,n,c,e</span>):<br>    x = PolynomialRing(Zmod(n),<span class="hljs-string">&#x27;x&#x27;</span>).gen()<br>    <br>    p = high_p + x<br>    <br>    x0 = p.small_roots(X = <span class="hljs-number">2</span>**<span class="hljs-number">128</span>,beta = <span class="hljs-number">0.1</span>)[<span class="hljs-number">0</span>]<span class="hljs-comment">#在这里p&gt;n**0.4,控制beta参数后就是mod p了，不是mod n , X参数是x的上界</span><br>    <br>    P = <span class="hljs-built_in">int</span>(p(x0))<br>    <br>    Q = n // P<br>    <br>    d = inverse_mod(e, (P-<span class="hljs-number">1</span>)*(Q-<span class="hljs-number">1</span>))<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程二&quot;</span>,<span class="hljs-built_in">hex</span>(power_mod(c, d, n)))<br><br>coppersmith2(high_p,n,c,e)<br></code></pre></td></tr></table></figure><hr><h3 id="已知d高位求p，q"><a href="#已知d高位求p，q" class="headerlink" title="已知d高位求p，q"></a>已知d高位求p，q</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sage.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> * <span class="hljs-comment">#vscode里跑不了，放sage里跑</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getFullP</span>(<span class="hljs-params">low_p, n</span>):<br>    R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="hljs-string">&#x27;NTL&#x27;</span>)<br>    f = x*<span class="hljs-number">2</span>^<span class="hljs-number">512</span> + low_p<span class="hljs-comment">#x补零，原题给了d mod 2**512 ，即d的低512位</span><br>    res = f.monic().small_roots(X = <span class="hljs-number">2</span>^<span class="hljs-number">128</span>, beta = <span class="hljs-number">0.4</span>)<br>    <span class="hljs-keyword">if</span> res:<br>        p = <span class="hljs-built_in">int</span>(f(res[<span class="hljs-number">0</span>]))<br>        <span class="hljs-keyword">return</span> p<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">phase4</span>(<span class="hljs-params">low_d, n, c</span>):<br>    maybe_p = []<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        p = var(<span class="hljs-string">&#x27;p&#x27;</span>)<br>        p0 = solve_mod([<span class="hljs-number">3</span>*p*low_d  == p + k*(n*p - p^<span class="hljs-number">2</span> - n + p)], <span class="hljs-number">2</span>^<span class="hljs-number">512</span>)<span class="hljs-comment">#根据题目写出的同余方程</span><br>        maybe_p += [<span class="hljs-built_in">int</span>(x[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> p0]<br>    <span class="hljs-built_in">print</span>(maybe_p)<span class="hljs-comment">#计算出来的是p低512位，</span><br>    <br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> maybe_p:<br>        P = getFullP(x, n)<br>        <span class="hljs-keyword">if</span> P: <span class="hljs-keyword">break</span><br>    <br>    P = <span class="hljs-built_in">int</span>(P)<br>    Q = n // P<br>    <br>    <span class="hljs-keyword">assert</span> P*Q == n<br>    <br>    d = inverse_mod(<span class="hljs-number">3</span>, (P-<span class="hljs-number">1</span>)*(Q-<span class="hljs-number">1</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(power_mod(c, d, n))[<span class="hljs-number">2</span>:])<br>    <br><br><br>n = <span class="hljs-number">92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183</span><br>c = <span class="hljs-number">56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530</span><br>low_d = <span class="hljs-number">787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955</span><br><br>phase4(low_d, n, c)<br></code></pre></td></tr></table></figure><hr><p><strong>参考：<a href="https://www.ruanx.net/coppersmith/">Coppersmith 攻击</a></strong><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage">RSA-and-LLL-attacks</a></strong><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_coppersmith_attack/#boneh-and-durfee-attack">CTF Wiki</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>RSA算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rabin算法</title>
    <link href="/2024/02/21/Rabin%E7%AE%97%E6%B3%95/"/>
    <url>/2024/02/21/Rabin%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabin算法"><a href="#Rabin算法" class="headerlink" title="Rabin算法"></a>Rabin算法</h1><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>选取两个大素数 $p$ 与 $q$，满足 $p,q \equiv 3 \pmod{4}$<br>对于明文 $m$ 和密文 $c$，定义以下加密过程：$c \equiv m^2 \pmod{n}$（一般情况下 $e$ 取 2，$e$ 也可取 2 的倍数）</p><h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><p>解密就是求解 $c$ 模 $n$ 的平方根，即求解同余式<br>$$<br>x^2 \equiv c \pmod{n}<br>$$<br>由中国剩余定理可知，求解同余式等价于解同余方程组<br>$$<br>\begin{cases}<br>x^2 \equiv c \pmod{p} \\<br>x^2 \equiv c \pmod{q}<br>\end{cases}<br>$$<br>由于 $p,q \equiv 3 \pmod{4}$，可知每个方程有两个解<br>$$<br>\begin{cases}<br>x \equiv \pm c^{\frac{1}{4}(p+1)} \pmod{p} \\<br>x \equiv \pm c^{\frac{1}{4}(q+1)} \pmod{q}<br>\end{cases}<br>$$<br>通过拓展的欧几里得定理分别求得整数 $s,t$ 满足<br>$$<br>\begin{cases}<br>sq \equiv 1 \pmod{p} \\<br>tp \equiv 1 \pmod{q}<br>\end{cases}<br>$$<br>根据中国剩余定理得到四个解<br>$$<br>[\pm c^{\frac{1}{4}(p+1)} \pmod{p}]sq + [\pm c^{\frac{1}{4}(q+1)} \pmod{q}]tp \pmod{n}<br>$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>在这一道题中e&#x3D;11*2**16</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Rabin算法只有在p，q都%4=3的情况下才能使用,还有一个特征是e=2的倍数  </span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Rabin_decrypt</span>(<span class="hljs-params">p, q, c</span>):<br>    n = p * q<br>    mp = <span class="hljs-built_in">pow</span>(c, (p + <span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, p)<br>    mq = <span class="hljs-built_in">pow</span>(c, (q + <span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, q)<br>    yp = gmpy2.invert(p, q)<br>    yq = gmpy2.invert(q, p)<br>    <span class="hljs-comment"># 计算四个明文</span><br>    r = (yp * p * mq + yq * q * mp) % n<br>    rr = n - r<br>    s = (yp * p * mq - yq * q * mp) % n<br>    ss = n - s<br>    <span class="hljs-keyword">return</span> (r, rr, s, ss)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Rabin</span>(<span class="hljs-params">p, q, e, c</span>):<br>    <span class="hljs-keyword">assert</span> p % <span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q % <span class="hljs-number">4</span> == <span class="hljs-number">3</span><br>    <span class="hljs-keyword">assert</span> e &amp; (e-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>  <span class="hljs-comment"># 确保 e 是 2 的幂次方</span><br>    cs = [c]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(gmpy2.log2(e))):<br>        ps = []<br>        <span class="hljs-keyword">for</span> c_ <span class="hljs-keyword">in</span> cs:<br>            ps.extend(Rabin_decrypt(p, q, c_))<br>        cs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(ps))<br>    <span class="hljs-comment"># 最后一层的四个明文</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> cs:<br>        <span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br>p = <span class="hljs-number">7789591348561112069062036258358846485064075647678305757108894839399612845301208683326183281448934541308319593732293251449480952381682222481111712823689403</span><br>q = <span class="hljs-number">11843985748190035400123239047046120615842488890207046522632012792661959669466825284114805235100514154443418211946648772038611835569684484924078305412048239</span><br>c = <span class="hljs-number">56375886252330945863796100146788284026284575124540705402766406570186848250541965030413492814326044028889436839480443287548796428401787742194995976041781857264225844371755006942983206638749208098849661879359667211157469234559833948233580696384823163040243094991418212296959615785232531545231813567101713253539</span><br><span class="hljs-comment">#e是2的几次方就Rabin几次，Rabin了16次,e=720896=11*2**16</span><br>e_ = <span class="hljs-number">2</span>**<span class="hljs-number">16</span><br>n = p * q<br><span class="hljs-comment">#余数11拿来计算d</span><br>d = gmpy2.invert(<span class="hljs-number">11</span>, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>cd = <span class="hljs-built_in">pow</span>(c, d, n)<br><br>Rabin(p, q, e_, cd)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b&#x27;\x83a\xe0O\xaa.R/rjk\xff\xec\xb5]\xe8\xb4\xe0\x9bO\x8e\xbc\x97yS\x90\xfd\x9eC[\xde\x875\x9c\xf4\xfa:\x04e3\x10\x97\x81j\xef\xba,B\x826\x95\xe6s&lt;[\xa4Qk\xe4\xf6c\xed\x90\xa0\xcd\xbd\xab\x1dv\xc2W\x0b\x84\xe1J\x8f\x17\x1f\x0f\\\xc4I%\x7f\x8c\x0c]^_n\xde\x98\x83\xb5\xf7)\xa0\x93s8\xa8\x07!7\x11\xe9\x1fJkx0\x03\xd8\xbd\x95\x8c\xd9\x80\xfc5\t\x05E\xdf\xdd\xd9\xa5\x98&#x27;</span><br><span class="hljs-string">b&#x27;flag&#123;5b8743c3-8ffb-4b00-a54a-afc93c8e7252&#125;&#x27;</span><br><span class="hljs-string">b&#x27;jk;\xba&quot;T\xd9\x92\xbb\xca\x180\x00\xd1W\xde\xc3\x93\xedB\x95y\&#x27;\xbf79 /J\x01\xae\xb5\xcd\xee6\xc4H\xa1&#125;Lv\&#x27;\xfd\xb2\x85#:c&quot;G\xfe\x0e(\x0e\xfd\x99\\\xdcCG\x8d\x83\x9c&lt;\x1f(f\x1f\x99\xb2\xde\xc0! \xb8\x1e.]\x07\xc6\xbc.\x80t\xcb;pHs@\xc5B,\xb2\x9b\xd3~*r\xb3G\x971@\x81\xc7\xec25\xd5&quot;\xa6\xcd\x11\xd7&#125;\x7f\xe4\xaba&#125;\xc7\x86\xf7*:4K&#x27;</span><br><span class="hljs-string">b&#x27;\x18\xf6\xa4\x95\x87\xd9x\x9c\xb6\xa0S\xcf\xeb\xe4\x06\t\xf1L\xae\x0c\xf9Co\xba\x1cW\xddn\xf9Z/\xd1g\xae\xbe5\xf1b\xe7\xe6\x9ao\x83\xb8j\x96\xf1\xdf_\xee\x97\xd8K-^\n\xf4\x8f\xa1\xae\xd6i\xf4d\xae\x95D\xfd\xdd\x0fxKc\xc0\x92p\xe8\xc2\x07\x96\x08\x1a\xa5\n\xc0\xd1S\x82M\x95\x94\x8b\xb9;\x92\x8aU\xcc3\xb2\x98\xd6VX\xbdU\x95He\xd0n\x92@\x0c\xebp\xbf\xff\x8a\x06\xeev$\x1f\xe5\xd4\xa3\xca&#x27;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RSA算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
